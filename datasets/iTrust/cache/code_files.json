{"BeanBuilder.java": "package edu.ncsu.csc.itrust;\n\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Takes a parameter map and creates a bean from that map of the appropriate type.\n * @param <T> The type to be returned from the appropriate parameter map.\n */\npublic class BeanBuilder<T> {\n\t/**\n\t * The code here is not obvious, but this method should not need rewriting unless a bug is found\n\t * \n\t * @param map -\n\t *            typically a request.getParameterMap; also can be a HashMap\n\t * @param bean -\n\t *            an instantiated bean to be loaded. Loaded bean is returned.\n\t * @return a loaded \"bean\"\n\t * @throws Exception -\n\t *             Several exceptions are thrown here, so promotion seemed fitting\n\t */\n\t// this warning is only suppressed because Map isn't parameterized (old JSP)\n\t@SuppressWarnings(\"unchecked\")\n\tpublic T build(Map map, T bean) throws Exception {\n\t\t// JavaBeans should not have overloaded methods, according to their API\n\t\t// (a stupid limitation!)\n\t\t// Nevertheless, we should check for it\n\t\tcheckOverloadedMethods(bean);\n\n\t\t// Use an introspector to find all of the getXXX or setXXX, we only want\n\t\t// the setXXX\n\t\tPropertyDescriptor[] propertyDescriptors = Introspector.getBeanInfo(bean.getClass())\n\t\t\t\t.getPropertyDescriptors();\n\t\tfor (PropertyDescriptor descriptor : propertyDescriptors) {\n\t\t\t// if object is null, either it was ignored or empty - just go with\n\t\t\t// bean's default\n\t\t\tString[] value = (String[]) map.get(descriptor.getName());\n\t\t\tMethod writeMethod = descriptor.getWriteMethod();\n\t\t\tif (!\"class\".equals(descriptor.getName()) && value != null && writeMethod != null) {\n\t\t\t\t// descriptor's name is the name of your property; like\n\t\t\t\t// firstName\n\t\t\t\t// only take the first string\n\t\t\t\ttry {\n\t\t\t\t\t// Skip the setters for enumerations\n\t\t\t\t\tif (writeMethod.getParameterTypes()[0].getEnumConstants() == null)\n\t\t\t\t\t\twriteMethod.invoke(bean, new Object[] { value[0] });\n\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\t// Throw a more informative exception\n\t\t\t\t\tthrow new IllegalArgumentException(e.getMessage() + \" with \" + writeMethod.getName()\n\t\t\t\t\t\t\t+ \" and \" + value[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn bean;\n\t}\n\n\t/**\n\t * Checks for overloaded methods\n\t * \n\t * @param bean item to check\n\t */\n\tprivate void checkOverloadedMethods(T bean) {\n\t\tMethod[] methods = bean.getClass().getDeclaredMethods();\n\t\tHashMap<String, String> nameMap = new HashMap<String, String>(methods.length);\n\t\tfor (Method method : methods) {\n\t\t\tif (nameMap.get(method.getName()) != null)\n\t\t\t\tthrow new IllegalArgumentException(bean.getClass().getName()\n\t\t\t\t\t\t+ \" should not have any overloaded methods, like \" + method.getName());\n\t\t\tif (!\"equals\".equals(method.getName())) // allow an equals override\n\t\t\t\tnameMap.put(method.getName(), \"exists\");\n\t\t}\n\n\t}\n}", "DateUtil.java": "package edu.ncsu.csc.itrust;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\n\n/**\n * Provides a few extra date utilities\n * \n * @author Andy\n * \n */\npublic class DateUtil {\n\tpublic static final long YEAR_IN_MS = 1000L * 60L * 60L * 24L * 365L;\n\n\t/**\n\t * Returns a MM/dd/yyyy format of the date for the given years ago\n\t * \n\t * @param years\n\t * @return\n\t */\n\tpublic static String yearsAgo(long years) {\n\t\tlong time = System.currentTimeMillis();\n\t\treturn new SimpleDateFormat(\"MM/dd/yyyy\").format(new Date(time - years * YEAR_IN_MS));\n\t}\n\n\t/**\n\t * Checks to see if a given date is within a range of months <strong>INCLUSIVELY</strong>, agnostic of\n\t * the year. <br />\n\t * <br />\n\t * \n\t * The range \"wraps\" so that if the first month is after the second month, then the definition of \"is in\n\t * month range\" is:<br />\n\t * the date falls outside of secondMonth, firstMonth, but including secondMonth and firstMonth.\n\t * \n\t * Modular arithmetic is used to adjust month values into the valid range.\n\t * \n\t * @param date\n\t * @param firstMonth\n\t * @param secondMonth\n\t * @return\n\t */\n\tpublic static boolean isInMonthRange(java.util.Date date, int firstMonth, int secondMonth) {\n\t\tCalendar cal = new GregorianCalendar();\n\t\tcal.setTime(date);\n\t\tfirstMonth %= 12;\n\t\tsecondMonth %= 12;\n\t\tif (secondMonth >= firstMonth) {\n\t\t\treturn ((cal.get(Calendar.MONTH) >= firstMonth) && (cal.get(Calendar.MONTH) <= secondMonth));\n\t\t}\n\t\treturn ((cal.get(Calendar.MONTH) >= firstMonth) || (cal.get(Calendar.MONTH) <= secondMonth));\n\t}\n\n\t/**\n\t * Same as isInMonthRange but uses the current date as the date value.\n\t * \n\t * @see DateUtil#isInMonthRange(Date, int, int)\n\t * @param firstMonth\n\t * @param secondMonth\n\t * @return\n\t */\n\tpublic static boolean currentlyInMonthRange(int firstMonth, int secondMonth) {\n\t\treturn isInMonthRange(new Date(), firstMonth, secondMonth);\n\t}\n\n\t/**\n\t * Returns the date a certain number of years ago\n\t * @param years how many years ago\n\t * @return the date it was however many years ago\n\t */\n\tpublic static Date getDateXyearsAgoFromNow(int years) {\n\t\tCalendar cal = new GregorianCalendar();\n\t\tcal.add(Calendar.YEAR, -years);\n\t\treturn cal.getTime();\n\t}\n\n\t/**\n\t * Returns the date a certain number of years ago\n\t * @param years how many years ago\n\t * @return the date it was however many years ago\n\t */\n\tpublic static java.sql.Date getSQLdateXyearsAgoFromNow(int years) {\n\t\treturn new java.sql.Date(getDateXyearsAgoFromNow(years).getTime());\n\t}\n\n\t/**\n\t * Returns the date a certain number of days ago\n\t * @param days how many days ago\n\t * @return the date it was however many days ago\n\t */\n\tpublic static Date getDateXDaysAgoFromNow(int days) {\n\t\tCalendar cal = new GregorianCalendar();\n\t\tcal.add(Calendar.DAY_OF_YEAR, -days);\n\t\treturn cal.getTime();\n\t}\n\t\n\t/**\n\t * Returns the date a certain number of days ago\n\t * @param days how many days ago\n\t * @return the date it was however many days ago\n\t */\n\tpublic static java.sql.Date getSQLdateXDaysAgoFromNow(int days) {\n\t\treturn new java.sql.Date(getDateXDaysAgoFromNow(days).getTime());\n\t}\n\n\t/**\n\t * <!--Pass in INSTANTIATED sql date objects and they will be set to the specified range, ie, FROM\n\t * <current year> - yearsAgo1/monthValue1/01 TO <current year> - yearsAgo2/monthValue2/<last day of\n\t * month2>--> Pass in INSTANTIATED sql date objects and they will be set to the specified range, ie, FROM\n\t * &lt;current year&gt; - yearsAgo1/monthValue1/01 TO &lt;current year&gt; -\n\t * yearsAgo2/monthValue2/&lt;last day of month2&gt;\n\t * \n\t * @param month1\n\t *            First sql.Date object to be set\n\t * @param monthValue1\n\t * @param yearsAgo1\n\t * @param month2\n\t *            Second sql.Date object to be set\n\t * @param monthValue2\n\t * @param yearsAgo2\n\t */\n\tpublic static void setSQLMonthRange(java.sql.Date month1, int monthValue1, int yearsAgo1,\n\t\t\tjava.sql.Date month2, int monthValue2, int yearsAgo2) {\n\t\tGregorianCalendar cal = new GregorianCalendar();\n\t\tcal.add(Calendar.YEAR, -yearsAgo1);\n\t\tcal.set(Calendar.MONTH, monthValue1);\n\t\tcal.set(Calendar.DAY_OF_MONTH, 1);\n\t\tmonth1.setTime(cal.getTimeInMillis());\n\t\tcal.add(Calendar.YEAR, yearsAgo1);\n\t\tcal.add(Calendar.YEAR, -yearsAgo2);\n\t\tcal.set(Calendar.MONTH, monthValue2);\n\t\tcal.set(Calendar.DAY_OF_MONTH, cal.getActualMaximum(Calendar.DAY_OF_MONTH));\n\t\tmonth2.setTime(cal.getTimeInMillis());\n\t}\n}", "DBUtil.java": "package edu.ncsu.csc.itrust;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\n\n/**\n * Provides a few database utilties\n * \n * @author Andy\n * \n */\npublic class DBUtil {\n\t/**\n\t * Used to check if we can actually obtain a connection.\n\t * \n\t * @return\n\t */\n\tpublic static boolean canObtainProductionInstance() {\n\t\ttry {\n\t\t\tDAOFactory.getProductionInstance().getConnection().close();\n\t\t\treturn true;\n\t\t} catch (SQLException e) {\n\t\t\tSystem.out.println(e);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Close the prepared statement and the connection in a proper way\n\t * \n\t * @param conn\n\t * @param ps\n\t */\n\tpublic static void closeConnection(Connection conn, PreparedStatement ps) {\n\t\ttry {\n\t\t\tif (ps != null)\n\t\t\t\tps.close();\n\t\t\tif (conn != null)\n\t\t\t\tconn.close();\n\t\t} catch (SQLException e) {\n\t\t\tSystem.err.println(\"Error closing connections\");\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\t/**\n\t * Returns the last ID that was generated for an auto-increment column. Please note that this does NOT\n\t * cause transaction problems! last_insert_id() returns the last generated ID on a per-connection basis.\n\t * See the MySQL documentation at the following location to confirm this:\n\t * {@link http://dev.mysql.com/doc/refman/5.0/en/getting-unique-id.html}\n\t * \n\t * Don't believe me? see {@link AutoIncrementTest}\n\t * \n\t * @param conn\n\t * @return last generated id\n\t * @throws SQLException\n\t */\n\tpublic static long getLastInsert(Connection conn) throws SQLException {\n\t\tResultSet rs = conn.createStatement().executeQuery(\"SELECT LAST_INSERT_ID()\");\n\t\trs.next();\n\t\treturn rs.getLong(1);\n\t}\n}", "EmailUtil.java": "package edu.ncsu.csc.itrust;\n\nimport edu.ncsu.csc.itrust.beans.Email;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\n\n/**\n * Sends email to users. Since we don't want to train spammers in 326, this just inserts into a database. If\n * we put this into an actual system, we would replace this class with stuff from javax.mail\n * \n * @author Andy\n * \n */\npublic class EmailUtil {\n\tprivate DAOFactory factory;\n\n\tpublic EmailUtil(DAOFactory factory) {\n\t\tthis.factory = factory;\n\t}\n\n\t// DO NOT SEND REAL EMAILS!!!!!\n\t// Sending emails - even to a throwaway account, is a waste of bandwidth and looks very suspicious.\n\t// If you want to know how to send emails from Java, just Google it on your own time.\n\tpublic void sendEmail(Email email) throws DBException {\n\t\tfactory.getFakeEmailDAO().sendEmailRecord(email);\n\t}\n}", "HtmlEncoder.java": "package edu.ncsu.csc.itrust;\n\n/**\n * Escapes a few key HTML characters and does some other checking\n * \n * @author Andy\n * \n */\npublic class HtmlEncoder {\n\t/**\n\t *  Escapes a few key HTML characters\n\t * @param input String to check and escape\n\t * @return\n\t */\n\tpublic static String encode(String input) {\n\t\tif (input == null)\n\t\t\treturn input;\n\t\tString str = input.replaceAll(\"<\", \"&lt;\");\n\t\tstr = str.replaceAll(\">\", \"&gt;\");\n\t\tstr = str.replaceAll(\"\\n\", \"<br />\");\n\t\treturn str;\n\t}\n\n\t/**\n\t * Checks URL\n\t * \n\t * @param input URL to check\n\t * @return false if the input contains http://, true otherwise\n\t */\n\tpublic static boolean URLOnSite(String input) {\n\t\treturn !(input.contains(\"http://\"));\n\t}\n}", "Localization.java": "package edu.ncsu.csc.itrust;\n\nimport java.util.Locale;\n\n/** Provides a singleton for accessing the current locale of iTrust\n *  Could possibly load the country and language from a file.\n *\n */\npublic class Localization {\n\tprivate Locale currentLocale;\n\t\n\tpublic Localization(){\n\t\tcurrentLocale = new Locale(\"en\",\"US\");\n\t}\n\n\t/**\n\t * Returns the current locale\n\t * @return the current locale\n\t */\n\tpublic Locale getCurrentLocale(){\n\t\treturn currentLocale;\n\t}\n\t\n\tstatic Localization currentInstance = null;\n\t\n\t/**\n\t * singleton method, may want to make this thread safe, as far as I know\n\t * iTrust doesn't do any multithreading though...\n\t * @return Localization instance\n\t */\n\tpublic static Localization instance(){\n\t\tif(currentInstance == null){\n\t\t\tcurrentInstance = new Localization();\n\t\t}\n\t\treturn currentInstance;\n\t}\n}", "Messages.java": "package edu.ncsu.csc.itrust;\n\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\n\npublic class Messages {\n\tprivate static final String BUNDLE_NAME = \"edu.ncsu.csc.itrust.messages\"; //$NON-NLS-1$\n\n\tprivate static final ResourceBundle RESOURCE_BUNDLE = ResourceBundle.getBundle(BUNDLE_NAME,Localization.instance().getCurrentLocale());\n\n\tpublic static String getString(String key) {\n\t\ttry {\n\t\t\treturn RESOURCE_BUNDLE.getString(key);\n\t\t} catch (MissingResourceException e) {\n\t\t\treturn '!' + key + '!';\n\t\t}\n\t}\n}", "ParameterUtil.java": "package edu.ncsu.csc.itrust;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Provides a utility method that converts the \"Map\" from the JSP container to a type-checked hashmap\n * \n * @author Andy\n * \n */\npublic class ParameterUtil {\n\t/**\n\t * Provides a utility method that converts the \"Map\" from the JSP container to a type-checked hashmap\n\t * @param params Map to convert\n\t * @return converted Map\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static HashMap<String, String> convertMap(Map params) {\n\t\tHashMap<String, String> myMap = new HashMap<String, String>();\n\t\tfor (Object key : params.keySet()) {\n\t\t\tString[] value = ((String[]) params.get(key));\n\t\t\tif (value != null)\n\t\t\t\tmyMap.put(key.toString(), value[0]);\n\t\t\telse\n\t\t\t\tmyMap.put(key.toString(), null);\n\t\t}\n\t\treturn myMap;\n\t}\n}", "RandomPassword.java": "package edu.ncsu.csc.itrust;\n\nimport java.util.Random;\n\n/**\n * Generates a random string of characters\n * \n * @author Andy\n * \n */\npublic class RandomPassword {\n\tprivate static final Random rand = new Random();\n\n\t/**\n\t * Returns a string of random characters\n\t * \n\t * @return a string of random characters\n\t */\n\tpublic static String getRandomPassword() {\n\t\tString str = \"\";\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tstr += (char) (rand.nextInt(26) + 'a');\n\t\t}\n\t\treturn str;\n\t}\n}", "AddApptAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport edu.ncsu.csc.itrust.beans.ApptBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.ApptDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.PatientDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\nimport edu.ncsu.csc.itrust.validate.ApptBeanValidator;\n\npublic class AddApptAction {\n\tprivate long loggedInMID;\n\tprivate ApptDAO apptDAO;\n\tprivate TransactionDAO transDAO;\n\tprivate PatientDAO patientDAO;\n\tprivate PersonnelDAO personnelDAO;\n\tprivate ApptBeanValidator validator = new ApptBeanValidator();\n\t\n\tpublic AddApptAction(DAOFactory factory, long loggedInMID) {\n\t\tthis.loggedInMID = loggedInMID;\n\t\tthis.apptDAO = factory.getApptDAO();\n\t\tthis.transDAO = factory.getTransactionDAO();\n\t\tthis.patientDAO = factory.getPatientDAO();\n\t\tthis.personnelDAO = factory.getPersonnelDAO();\n\t}\n\t\n\tpublic String addAppt(ApptBean appt) throws FormValidationException, SQLException {\n\t\tvalidator.validate(appt);\n\t\tif(appt.getDate().before(new Timestamp(System.currentTimeMillis()))) {\n\t\t\treturn \"The scheduled date of this Appointment (\"+appt.getDate()+\") has already passed.\";\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tapptDAO.scheduleAppt(appt);\n\t\t\ttransDAO.logTransaction(TransactionType.ADD_APPT, loggedInMID, 0L,\n\t\t\t\t\t\"Added Appointment \" + appt.getApptType());\n\t\t\treturn \"Success: \" + appt.getApptType() + \" for \" + appt.getDate() + \" added\";\n\t\t}\n\t\tcatch (DBException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn e.getMessage();\n\t\t} \n\t}\n\t\n\t/**\n\t * Gets a users's name from their MID\n\t * \n\t * @param mid the MID of the user\n\t * @return the user's name\n\t * @throws iTrustException\n\t */\n\tpublic String getName(long mid) throws iTrustException {\n\t\tif(mid < 7000000000L)\n\t\t\treturn patientDAO.getName(mid);\n\t\telse\n\t\t\treturn personnelDAO.getName(mid);\n\t}\n}", "AddERespAction.java": "package edu.ncsu.csc.itrust.action;\n\n\nimport edu.ncsu.csc.itrust.RandomPassword;\nimport edu.ncsu.csc.itrust.beans.PersonnelBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.AuthDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.Role;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\nimport edu.ncsu.csc.itrust.validate.AddPersonnelValidator;\n\n/**\n * Used for Add Personnel page (addPersonnel.jsp). This just adds an empty HCP/UAP, creates a random password\n * for them.\n * \n * Very similar to {@link AddOfficeVisitAction} and {@link AddPatientAction}\n * \n * @author Andy Meneely\n * \n * Copied from AddHCPAction \n */\n\n\npublic class AddERespAction {\n\tprivate PersonnelDAO personnelDAO;\n\tprivate AuthDAO authDAO;\n\tprivate TransactionDAO transDAO;\n\tprivate long loggedInMID;\n\n/**\n * Sets up the defaults for the class\n * \n * @param factory factory for creating the defaults.\n * @param loggedInMID person currently logged in \n * @author Andy Meneely\n */\t\n\t\n\tpublic AddERespAction(DAOFactory factory, long loggedInMID) {\n\t\tthis.personnelDAO = factory.getPersonnelDAO();\n\t\tthis.authDAO = factory.getAuthDAO();\n\t\tthis.transDAO = factory.getTransactionDAO();\n\t\tthis.loggedInMID = loggedInMID;\n\t}\n\n\t/**\n\t * Adds the new user.  Event is logged.\n\t * \n\t * @param p bean containing the information for the new user\n\t * @return MID of the new user.\n\t * @throws FormValidationException\n\t * @throws iTrustException\n\t */\n\tpublic long add(PersonnelBean p) throws FormValidationException, iTrustException {\n\t\tnew AddPersonnelValidator().validate(p);\n\t\tlong newMID = personnelDAO.addEmptyPersonnel(Role.ER);\n\t\tp.setMID(newMID);\n\t\tpersonnelDAO.editPersonnel(p);\n\t\tString pwd = authDAO.addUser(newMID, Role.ER, RandomPassword.getRandomPassword());\n\t\tp.setPassword(pwd);\n\n\t\ttransDAO.logTransaction(TransactionType.CREATE_DISABLE_ER, loggedInMID, newMID, \"Added New \" + p.getRole().name());\n\t\treturn newMID;\n\t}\n\n}", "AddHCPAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport edu.ncsu.csc.itrust.RandomPassword;\nimport edu.ncsu.csc.itrust.beans.PersonnelBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.AuthDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.Role;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\nimport edu.ncsu.csc.itrust.validate.AddPersonnelValidator;\n\n/**\n * Used for Add Personnel page (addPersonnel.jsp). This just adds an empty HCP/UAP, creates a random password\n * for them.\n * \n * Very similar to {@link AddOfficeVisitAction} and {@link AddPatientAction}\n * \n * @author Andy Meneely\n * \n */\npublic class AddHCPAction {\n\tprivate PersonnelDAO personnelDAO;\n\tprivate AuthDAO authDAO;\n\tprivate TransactionDAO transDAO;\n\tprivate long loggedInMID;\n\n\t/**\n\t * Sets up the defaults for the class\n\t * \n\t * @param factory factory for creating the defaults.\n\t * @param loggedInMID person currently logged in \n\t * @author Andy Meneely\n\t */\t\n\t\n\tpublic AddHCPAction(DAOFactory factory, long loggedInMID) {\n\t\tthis.personnelDAO = factory.getPersonnelDAO();\n\t\tthis.authDAO = factory.getAuthDAO();\n\t\tthis.transDAO = factory.getTransactionDAO();\n\t\tthis.loggedInMID = loggedInMID;\n\t}\n\t\n\t/**\n\t * Adds the new user.   Event is logged.\n\t * \n\t * @param p bean containing the information for the new user\n\t * @return MID of the new user.\n\t * @throws FormValidationException\n\t * @throws iTrustException\n\t */\n\tpublic long add(PersonnelBean p) throws FormValidationException, iTrustException {\n\t\tnew AddPersonnelValidator().validate(p);\n\t\tlong newMID = personnelDAO.addEmptyPersonnel(Role.HCP);\n\t\tp.setMID(newMID);\n\t\tpersonnelDAO.editPersonnel(p);\n\t\tString pwd = authDAO.addUser(newMID, Role.HCP, RandomPassword.getRandomPassword());\n\t\tp.setPassword(pwd);\n\t\t//transDAO.logTransaction(TransactionType.CREATE_DISABLE_PATIENT_HCP, loggedInMID);\n\t\ttransDAO.logTransaction(TransactionType.CREATE_DISABLE_PATIENT_HCP, loggedInMID, newMID, \"Added New HCP\");\n\t\treturn newMID;\n\t}\n\n}", "AddOfficeVisitAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport java.util.List;\nimport edu.ncsu.csc.itrust.action.base.PatientBaseAction;\nimport edu.ncsu.csc.itrust.beans.OfficeVisitBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.OfficeVisitDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\n\n/**\n * Used for Document Office Visit page (documentOfficeVisit.jsp). This just adds an empty office visit, and\n * provides a list of office visits in case you want to edit an old office visit.\n * \n * Very similar to {@link AddPatientAction}\n * \n * @author Andy Meneely\n * \n */\npublic class AddOfficeVisitAction extends PatientBaseAction {\n\tprivate DAOFactory factory;\n\tprivate OfficeVisitDAO ovDAO;\n\tprivate TransactionDAO transDAO;\n\n\t/**\n\t * Sets up the defaults for the class\n\t * @param factory\n\t * @param pidString\n\t *            Patient ID to be validated by the superclass, {@link PatientBaseAction}\n\t * @throws iTrustException\n\t */\n\tpublic AddOfficeVisitAction(DAOFactory factory, String pidString) throws iTrustException {\n\t\tsuper(factory, pidString);\n\t\tthis.factory = factory;\n\t\tthis.transDAO = factory.getTransactionDAO();\n\t\tovDAO = factory.getOfficeVisitDAO();\n\t}\n\n\t/**\n\t * Adds an empty office visit\n\t * \n\t * @param loggedInMID\n\t *            For logging purposes\n\t * @return Office visit ID (primary key) of the new office visit\n\t * @throws DBException\n\t */\n\tpublic long addEmptyOfficeVisit(long loggedInMID) throws DBException {\n\t\tOfficeVisitBean ov = new OfficeVisitBean();\n\t\tov.setHcpID(loggedInMID);\n\t\tov.setPatientID(pid);\n\t\tlong visitID = ovDAO.add(ov);\n\t\ttransDAO.logTransaction(TransactionType.DOCUMENT_OFFICE_VISIT, loggedInMID, pid, \"visit id: \"\n\t\t\t\t+ visitID);\n\t\treturn visitID;\n\t}\n\n\t/**\n\t * Lists all office visits for a particular patient, regardless of who originally documented the office\n\t * visit.\n\t * \n\t * @return List of office visits,\n\t * @throws iTrustException\n\t */\n\tpublic List<OfficeVisitBean> getAllOfficeVisits() throws iTrustException {\n\t\treturn ovDAO.getAllOfficeVisits(pid);\n\t}\n\n\t/**\n\t * Returns the full name of the patient with this MID\n\t * \n\t * @return name in the form of a string\n\t * @throws DBException\n\t * @throws iTrustException\n\t */\n\tpublic String getUserName() throws DBException, iTrustException {\n\t\treturn factory.getAuthDAO().getUserName(pid);\n\t}\n}", "AddPatientAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport edu.ncsu.csc.itrust.RandomPassword;\nimport edu.ncsu.csc.itrust.beans.PatientBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.PatientDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.AuthDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.Role;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\nimport edu.ncsu.csc.itrust.validate.AddPatientValidator;\n\n/**\n * Used for Add Patient page (addPatient.jsp). This just adds an empty patient, creates a random password for\n * that patient.\n * \n * Very similar to {@link AddOfficeVisitAction}\n * \n * @author Andy Meneely\n * \n */\npublic class AddPatientAction {\n\tprivate TransactionDAO transDAO;\n\tprivate PatientDAO patientDAO;\n\tprivate AuthDAO authDAO;\n\tprivate long loggedInMID;\n\n\t/**\n\t * Just the factory and logged in MID\n\t * \n\t * @param factory\n\t * @param loggedInMID\n\t */\n\tpublic AddPatientAction(DAOFactory factory, long loggedInMID) {\n\t\tthis.patientDAO = factory.getPatientDAO();\n\t\tthis.transDAO = factory.getTransactionDAO();\n\t\tthis.loggedInMID = loggedInMID;\n\t\tthis.authDAO = factory.getAuthDAO();\n\t}\n\n\t/**\n\t * Creates a new patient, returns the new MID. Adds a new user to the table along with a random password.\n\t * \n\t * @return the new MID of the patient\n\t * @throws DBException\n\t * @throws FormValidationException\n\t */\n\tpublic long addPatient(PatientBean p) throws DBException, FormValidationException {\n\t\tnew AddPatientValidator().validate(p);\n\t\tlong newMID = patientDAO.addEmptyPatient();\n\t\tp.setMID(newMID);\n\t\tString pwd = authDAO.addUser(newMID, Role.PATIENT, RandomPassword.getRandomPassword());\n\t\tp.setPassword(pwd);\n\t\tpatientDAO.editPatient(p);\n\t\ttransDAO.logTransaction(TransactionType.CREATE_DISABLE_PATIENT_HCP, loggedInMID, newMID, \"New Patient Added\");\n\t\treturn newMID;\n\t}\n\n}", "AddPHAAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport edu.ncsu.csc.itrust.RandomPassword;\nimport edu.ncsu.csc.itrust.beans.PersonnelBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.AuthDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.Role;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\nimport edu.ncsu.csc.itrust.validate.AddPersonnelValidator;\n\n/**\n * Used for Add Personnel page (addPersonnel.jsp). This just adds an empty PHA, creates a random password\n * for them.\n * \n * Very similar to {@link AddOfficeVisitAction} and {@link AddPatientAction}\n * \n */\npublic class AddPHAAction {\n\tprivate PersonnelDAO personnelDAO;\n\tprivate AuthDAO authDAO;\n\tprivate TransactionDAO transDAO;\n\tprivate long loggedInMID;\n\n\t/**\n\t * Sets up the defaults for the class\n\t * \n\t * @param factory factory for creating the defaults.\n\t * @param loggedInMID person currently logged in \n\t * @author Andy Meneely\n\t */\t\n\t\n\tpublic AddPHAAction(DAOFactory factory, long loggedInMID) {\n\t\tthis.personnelDAO = factory.getPersonnelDAO();\n\t\tthis.authDAO = factory.getAuthDAO();\n\t\tthis.transDAO = factory.getTransactionDAO();\n\t\tthis.loggedInMID = loggedInMID;\n\t}\n\t\n\t/**\n\t * Adds the new user.   Event is logged.\n\t * \n\t * @param p bean containing the information for the new user\n\t * @return MID of the new user.\n\t * @throws FormValidationException\n\t * @throws iTrustException\n\t */\n\tpublic long add(PersonnelBean p) throws FormValidationException, iTrustException {\n\t\tnew AddPersonnelValidator().validate(p);\n\t\tlong newMID = personnelDAO.addEmptyPersonnel(Role.PHA);\n\t\tp.setMID(newMID);\n\t\tpersonnelDAO.editPersonnel(p);\n\t\tString pwd = authDAO.addUser(newMID, Role.PHA, RandomPassword.getRandomPassword());\n\t\tp.setPassword(pwd);\n\t\t//transDAO.logTransaction(TransactionType.CREATE_DISABLE_PATIENT_HCP, loggedInMID);\n\t\ttransDAO.logTransaction(TransactionType.CREATE_DISABLE_PHA, loggedInMID, newMID, \"Added New PHA\");\n\t\treturn newMID;\n\t}\n\n}", "AddRemoteMonitoringDataAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport edu.ncsu.csc.itrust.beans.RemoteMonitoringDataBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.AuthDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.RemoteMonitoringDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\nimport edu.ncsu.csc.itrust.validate.RemoteMonitoringDataBeanValidator;\n\n/**\n * Handles adding remote monitoring patient data to the database\n * \n */\npublic class AddRemoteMonitoringDataAction {\n\tprivate RemoteMonitoringDataBeanValidator validator = new RemoteMonitoringDataBeanValidator();\n\tprivate RemoteMonitoringDAO rmDAO;\n\tprivate TransactionDAO transDAO;\n\tprivate AuthDAO authDAO;\n\tprivate long loggedInMID;\n\tprivate long patientMID;\n\n\t/**\n\t * Constructor\n\t * \n\t * @param factory The DAOFactory used to create the DAOs used in this action.\n\t * @param loggedInMID The MID of the person recording the patient's data.\n\t * @param patientMID The MID of the patient\n\t */\n\tpublic AddRemoteMonitoringDataAction(DAOFactory factory, long loggedInMID, long patientMID) {\n\t\tthis.loggedInMID = loggedInMID;\n\t\tthis.rmDAO = factory.getRemoteMonitoringDAO();\n\t\tthis.transDAO = factory.getTransactionDAO();\n\t\tthis.authDAO = factory.getAuthDAO();\n\t\tthis.patientMID = patientMID;\n\t}\n\n\t/**\n\t * Adds a patients remote monitoring data to the database.\n\t * \n\t * @param glucoseLevel\n\t * @throws DBException\n\t */\n\tpublic void addRemoteMonitoringData(int glucoseLevel)\n\t  throws DBException, FormValidationException,iTrustException {\n\t\t//Validation - Only need to validate the three integer parameters\n\t\tRemoteMonitoringDataBean m = new RemoteMonitoringDataBean();\n\t\tm.setGlucoseLevel(glucoseLevel);\n\t\tm.setDiastolicBloodPressure(60);\n\t\tm.setSystolicBloodPressure(60);\n\t\tvalidator.validate(m);\n\t\tm.setDiastolicBloodPressure(-1);\n\t\tm.setSystolicBloodPressure(-1);\n\t\t//Log transaction\n\t\ttransDAO.logTransaction(TransactionType.TELEMEDICINE_MONITORING, loggedInMID);\n\t\tString role;\n\t\tif (loggedInMID == patientMID){\n\t\t\trole = \"self-reported\";\n\t\t} else if (authDAO.getUserRole(loggedInMID).getUserRolesString().equals(\"uap\")){\n\t\t\trole = \"case-manager\";\n\t\t} else {\n\t\t\trole = \"patient representative\";\n\t\t}\t\t\n\t\t//Store in DB\n\t\trmDAO.storePatientData(patientMID, glucoseLevel, role, loggedInMID);\n\t}\n\t\n\t/**\n\t * Adds a patients remote monitoring data to the database.\n\t * \n\t * @param systolicBloodPressure\n\t * @param diastolicBloodPressure\n\t * @throws DBException\n\t */\n\tpublic void addRemoteMonitoringData(int systolicBloodPressure, int diastolicBloodPressure)\n\t  throws DBException, FormValidationException,iTrustException {\n\t\t//Validation - Only need to validate the three integer parameters\n\t\tRemoteMonitoringDataBean m = new RemoteMonitoringDataBean();\n\t\tm.setSystolicBloodPressure(systolicBloodPressure);\n\t\tm.setDiastolicBloodPressure(diastolicBloodPressure);\n\t\tvalidator.validate(m);\n\t\t\n\t\t//Log transaction\n\t\ttransDAO.logTransaction(TransactionType.TELEMEDICINE_MONITORING, loggedInMID);\n\t\tString role;\n\t\tif (loggedInMID == patientMID){\n\t\t\trole = \"self-reported\";\n\t\t} else if (authDAO.getUserRole(loggedInMID).getUserRolesString().equals(\"uap\")){\n\t\t\trole = \"case-manager\";\n\t\t} else {\n\t\t\trole = \"patient representative\";\n\t\t}\t\t\n\t\t//Store in DB\n\t\trmDAO.storePatientData(patientMID, systolicBloodPressure, diastolicBloodPressure, role, loggedInMID);\n\t}\n\t\n\t/**\n\t * Adds a patients remote monitoring data to the database.\n\t * \n\t * @param systolicBloodPressure\n\t * @param diastolicBloodPressure\n\t * @param glucoseLevel\n\t * @throws DBException\n\t */\n\tpublic void addRemoteMonitoringData(int systolicBloodPressure, int diastolicBloodPressure, int glucoseLevel)\n\t  throws DBException, FormValidationException,iTrustException {\n\t\t//Validation - Only need to validate the three integer parameters\n\t\tRemoteMonitoringDataBean m = new RemoteMonitoringDataBean();\n\t\tm.setSystolicBloodPressure(systolicBloodPressure);\n\t\tm.setDiastolicBloodPressure(diastolicBloodPressure);\n\t\tm.setGlucoseLevel(glucoseLevel);\n\t\tvalidator.validate(m);\n\t\t\n\t\t//Log transaction\n\t\ttransDAO.logTransaction(TransactionType.TELEMEDICINE_MONITORING, loggedInMID);\n\t\tString role;\n\t\tif (loggedInMID == patientMID){\n\t\t\trole = \"self-reported\";\n\t\t} else if (authDAO.getUserRole(loggedInMID).getUserRolesString().equals(\"uap\")){\n\t\t\trole = \"case-manager\";\n\t\t} else {\n\t\t\trole = \"patient representative\";\n\t\t}\t\t\n\t\t//Store in DB\n\t\trmDAO.storePatientData(patientMID, systolicBloodPressure, diastolicBloodPressure, glucoseLevel, role, loggedInMID);\n\t}\n\t\n\t/**\n\t * returns the patient name\n\t * \n\t * @return patient name\n\t * @throws DBException\n\t * @throws iTrustException\n\t */\n\tpublic String getPatientName(long pid) throws DBException, iTrustException {\n\t\treturn authDAO.getUserName(pid);\n\t}\n\t\n}", "AddUAPAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport edu.ncsu.csc.itrust.RandomPassword;\nimport edu.ncsu.csc.itrust.beans.PersonnelBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.AuthDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.Role;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\nimport edu.ncsu.csc.itrust.validate.AddPersonnelValidator;\n\n/**\n * Used for Add Personnel page (addPersonnel.jsp). This just adds an empty HCP/UAP, creates a random password\n * for them.\n * \n * Very similar to {@link AddOfficeVisitAction} and {@link AddPatientAction}\n * \n * @author Andy Meneely\n * \n */\npublic class AddUAPAction {\n\tprivate PersonnelDAO personnelDAO;\n\tprivate AuthDAO authDAO;\n\tprivate TransactionDAO transDAO;\n\tprivate long loggedInMID;\n\n\t/**\n\t * Sets up the defaults for the class\n\t * \n\t * @param factory factory for creating the defaults.\n\t * @param loggedInMID person currently logged in \n\t * @author Andy Meneely\n\t */\t\n\tpublic AddUAPAction(DAOFactory factory, long loggedInMID) {\n\t\tthis.personnelDAO = factory.getPersonnelDAO();\n\t\tthis.authDAO = factory.getAuthDAO();\n\t\tthis.transDAO = factory.getTransactionDAO();\n\t\tthis.loggedInMID = loggedInMID;\n\t}\n\t\n\t\n\t/**\n\t * Adds the new user.  Event is logged.\n\t * \n\t * @param p bean containing the information for the new user\n\t * @return MID of the new user.\n\t * @throws FormValidationException\n\t * @throws iTrustException\n\t */\n\tpublic long add(PersonnelBean p) throws FormValidationException, iTrustException {\n\t\tnew AddPersonnelValidator().validate(p);\n\t\tlong newMID = personnelDAO.addEmptyPersonnel(Role.UAP);\n\t\tp.setMID(newMID);\n\t\tpersonnelDAO.editPersonnel(p);\n\t\tString pwd = authDAO.addUser(newMID, Role.UAP, RandomPassword.getRandomPassword());\n\t\tp.setPassword(pwd);\n\t\ttransDAO.logTransaction(TransactionType.CREATE_DISABLE_PATIENT_HCP, loggedInMID, newMID, \"New UAP Added\");\n\t\treturn newMID;\n\t}\n\n\n}", "ChangeSessionTimeoutAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.AccessDAO;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\n\n/**\n * Used to change the session timeout, sessionTimeout.jsp. Note that a change to this timeout only gets\n * reflected on new sessions.\n * \n * @author Andy Meneely\n * \n */\npublic class ChangeSessionTimeoutAction {\n\tprivate AccessDAO accessDAO;\n\n\t/**\n\t * Sets up defualts.\n\t * \n\t * @param factory\n\t * @author Andy Meneely\n\t */\n\tpublic ChangeSessionTimeoutAction(DAOFactory factory) {\n\t\tthis.accessDAO = factory.getAccessDAO();\n\t}\n\n\t/**\n\t * Changes the session timeout, the complicated logic of this is somewhat regrettably in the DAO,\n\t * {@link AccessDAO}\n\t * \n\t * @param minuteString\n\t *            Pass the number of minutes in the form of a string, greater than 0.\n\t * @throws FormValidationException\n\t * @throws DBException\n\t * @author Andy Meneely\n\t */\n\tpublic void changeSessionTimeout(String minuteString) throws FormValidationException, DBException {\n\t\ttry {\n\t\t\tInteger minutes = Integer.valueOf(minuteString);\n\t\t\tif (minutes < 1)\n\t\t\t\tthrow new FormValidationException(\"Must be a number greater than 0\");\n\t\t\taccessDAO.setSessionTimeoutMins(minutes);\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new FormValidationException(\"That is not a number\");\n\t\t}\n\t}\n\n\t/**\n\t * Returns the current session timeout in minutes, as reflected in the database\n\t * \n\t * @return the number of minutes it would take for an inactive session to timeout\n\t * @throws DBException\n\t * @author Andy Meneely\n\t */\n\tpublic int getSessionTimeout() throws DBException {\n\t\treturn accessDAO.getSessionTimeoutMins();\n\t}\n}", "ChronicDiseaseRiskAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport java.util.List;\nimport edu.ncsu.csc.itrust.action.base.PatientBaseAction;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.AuthDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.NoHealthRecordsException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\nimport edu.ncsu.csc.itrust.risk.ChronicDiseaseMediator;\nimport edu.ncsu.csc.itrust.risk.RiskChecker;\n\n/**\n * \n * Used for chronicDiseaseRisks.jsp. Passes most of the logic off to {@link ChronicDiseaseMediator}, and the\n * various subclasses of {@link RiskChecker}.\n * \n * @author Andy Meneely\n * \n */\npublic class ChronicDiseaseRiskAction extends PatientBaseAction {\n\tprivate AuthDAO authDAO;\n\tprivate long loggedInMID;\n\tprivate ChronicDiseaseMediator diseaseMediator;\n\tprivate TransactionDAO transDAO;\n\n\t/**\n\t * \n\t * @param factory\n\t * @param loggedInMID\n\t * @param pidString\n\t *            The patient ID to be validated and used\n\t * @throws iTrustException\n\t * @throws DBException\n\t * @throws NoHealthRecordsException\n\t *             This is thrown if a patient is added without any health records to be checked. Try to avoid\n\t *             having this exception be thrown in a normal flow of events.\n\t * @author Andy Meneely\n\t */\n\tpublic ChronicDiseaseRiskAction(DAOFactory factory, long loggedInMID, String pidString)\n\t\t\tthrows iTrustException, DBException, NoHealthRecordsException {\n\t\tsuper(factory, pidString);\n\t\tthis.authDAO = factory.getAuthDAO();\n\t\tthis.transDAO = factory.getTransactionDAO();\n\t\tthis.loggedInMID = loggedInMID;\n\t\tthis.diseaseMediator = new ChronicDiseaseMediator(factory, pid);\n\t}\n\n\t/**\n\t * Returns the ID of the patient to be checked.\n\t * \n\t * @return patient ID whose risk we are checking\n\t * @author Andy Meneely\n\t */\n\tpublic long getPatientID() {\n\t\treturn pid;\n\t}\n\n\t/**\n\t * Gives the full name of the patient\n\t * \n\t * @return Full name of the patient who we are checking\n\t * @throws DBException\n\t * @throws iTrustException\n\t * @author Andy Meneely\n\t */\n\tpublic String getUserName() throws DBException, iTrustException {\n\t\treturn authDAO.getUserName(pid);\n\t}\n\n\t/**\n\t * Returns the risks for which this patient is at risk for. All logic has been passed to\n\t * {@link ChronicDiseaseMediator} and the subclasses of {@link RiskChecker}.\n\t * \n\t * @return List of risks\n\t * @throws iTrustException\n\t * @throws DBException\n\t * @author Andy Meneely\n\t */\n\tpublic List<RiskChecker> getDiseasesAtRisk() throws iTrustException, DBException {\n\t\ttransDAO.logTransaction(TransactionType.IDENTIFY_RISK_FACTORS, loggedInMID, pid, \"\");\n\t\treturn diseaseMediator.getDiseaseAtRisk();\n\t}\n}", "DeclareHCPAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.PersonnelBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.AuthDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.PatientDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.Role;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\n\n/**\n * Used by the patient to declare HCPs as \"designated\", in editHCPs.jsp.\n * \n * @author Andy Meneely\n * \n */\npublic class DeclareHCPAction {\n\tprivate TransactionDAO transDAO;\n\tprivate PatientDAO patientDAO;\n\tprivate AuthDAO authDAO;\n\tprivate long loggedInMID;\n\n\t/**\n\t * Sets up defaults\n\t * \n\t * @param factory The DAO factory to be used for generating the DAOs for this action.\n\t * @param loggedInMID\n\t *            This patient\n\t * @author Andy Meneely\n\t */\n\tpublic DeclareHCPAction(DAOFactory factory, long loggedInMID) {\n\t\tthis.loggedInMID = loggedInMID;\n\t\tthis.transDAO = factory.getTransactionDAO();\n\t\tthis.patientDAO = factory.getPatientDAO();\n\t\tthis.authDAO = factory.getAuthDAO();\n\t}\n\n\t/**\n\t * Lists the declared HCPs for this current patient\n\t * \n\t * @return Returns a list of the declared HCPs\n\t * @throws iTrustException\n\t * @author Andy Meneely\n\t */\n\tpublic List<PersonnelBean> getDeclaredHCPS() throws iTrustException {\n\t\treturn patientDAO.getDeclaredHCPs(loggedInMID);\n\t}\n\n\t/**\n\t * Validate an HCP's MID and declare them, if possible\n\t * \n\t * @param hcpStr\n\t *            The MID of an HCP to declare\n\t * @return A status message,\n\t * @throws iTrustException\n\t * @author Andy Meneely\n\t */\n\tpublic String declareHCP(String hcpStr) throws iTrustException {\n\t\ttry {\n\t\t\tlong hcpID = Long.valueOf(hcpStr);\n\t\t\tif (authDAO.getUserRole(hcpID) != Role.HCP)\n\t\t\t\tthrow new iTrustException(\"This user is not a licensed healthcare professional!\");\n\n\t\t\tboolean confirm = patientDAO.declareHCP(loggedInMID, hcpID);\n\n\t\t\tif (confirm) {\n\t\t\t\ttransDAO.logTransaction(TransactionType.DECLARE_HCP, loggedInMID, hcpID,\n\t\t\t\t\t\t\"patient declared hcp\");\n\t\t\t\treturn \"HCP successfully declared\";\n\t\t\t} else\n\t\t\t\treturn \"HCP not declared\";\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new iTrustException(\"HCP's MID not a number\");\n\t\t} \n\t}\n\n\t/**\n\t * Validate an HCP's MID and undeclare them, if possible\n\t * \n\t * @param input\n\t *            The MID of an HCP to undeclare\n\t * @return\n\t * @throws iTrustException\n\t * @author Andy Meneely\n\t */\n\tpublic String undeclareHCP(String input) throws iTrustException {\n\t\ttry {\n\t\t\tlong hcpID = Long.valueOf(input);\n\t\t\tboolean confirm = patientDAO.undeclareHCP(loggedInMID, hcpID);\n\t\t\tif (confirm) {\n\t\t\t\ttransDAO.logTransaction(TransactionType.DECLARE_HCP, loggedInMID, hcpID,\n\t\t\t\t\t\t\"patient undeclared hcp\");\n\t\t\t\treturn \"HCP successfully undeclared\";\n\t\t\t} else\n\t\t\t\treturn \"HCP not undeclared\";\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new iTrustException(\"HCP's MID not a number\");\n\t\t} \n\t}\n}", "DrugInteractionAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.DrugInteractionBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.DrugInteractionDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\nimport edu.ncsu.csc.itrust.validate.DrugInteractionValidator;\n\n/**\n * Used by EditDrugInteraction.jsp to edit and get information about drug interactions.\n * \n */\npublic class DrugInteractionAction {\n\tprivate DrugInteractionDAO drugDAO;\n\tprivate TransactionDAO tranDAO;\n\tprivate DrugInteractionValidator validator;\n\tlong loggedInMID;\n\n\t/**\n\t * Sets up defaults\n\t * \n\t * @param factory The DAO factory to be used for generating the DAOs for this action.\n\t * \n\t */\n\tpublic DrugInteractionAction(DAOFactory factory, long loggedInMID) {\n\t\tthis.drugDAO = factory.getDrugInteractionDAO();\n\t\tthis.tranDAO = factory.getTransactionDAO();\n\t\tthis.validator = new DrugInteractionValidator();\n\t\tthis.loggedInMID = loggedInMID;\n\t}\n\t\n\t/**\n\t * Method to report an interaction\n\t * @param firstDrug\n\t * @param secondDrug\n\t * @param description\n\t * @return\n\t */\n\t\n\tpublic String reportInteraction(String firstDrug, String secondDrug, String description) throws iTrustException,FormValidationException{\n\t\tif (firstDrug.equals(secondDrug)){\n\t\t\treturn \"Interactions can only be recorded between two different drugs\";\n\t\t}\n\t\tDrugInteractionBean drugInt = new DrugInteractionBean();\n\t\tdrugInt.setFirstDrug(firstDrug);\n\t\tdrugInt.setSecondDrug(secondDrug);\n\t\tdrugInt.setDescription(description);\n\t\t\n\t\ttry {\n\t\t\tvalidator.validate(drugInt);\n\t\t\tif (drugDAO.reportInteraction(firstDrug,secondDrug,description)){\n\t\t\t\ttranDAO.logTransaction(TransactionType.DRUG_INTERACTION, loggedInMID);\n\t\t\t\treturn \"Interaction recorded successfully\";\n\t\t\t} else {\n\t\t\t\treturn \"Interaction could not be added\";\n\t\t\t}\n\t\t} catch (DBException e){\n\t\t\te.printStackTrace();\n\t\t\treturn e.getMessage();\n\t\t\t}\n\t\t}\n\n\t/**\n\t * Method to delete an interaction\n\t * @param firstDrug\n\t * @param secondDrug\n\t * @return\n\t */\n\tpublic String deleteInteraction(String firstDrug,String secondDrug) throws iTrustException, FormValidationException{\n\t\tDrugInteractionBean drugInt = new DrugInteractionBean();\n\t\tdrugInt.setFirstDrug(firstDrug);\n\t\tdrugInt.setSecondDrug(secondDrug);\n\t\tdrugInt.setDescription(\"blank\");\n\t\t\n\t\ttry {\n\t\t\tvalidator.validate(drugInt);\n\t\t\tif (drugDAO.deleteInteraction(firstDrug,secondDrug)){\n\t\t\t\ttranDAO.logTransaction(TransactionType.DRUG_INTERACTION, loggedInMID);\n\t\t\t\treturn \"Interaction deleted successfully\";\n\t\t\t} else {\n\t\t\t\treturn \"Interaction could not be deleted\";\n\t\t\t}\n\t\t} catch (DBException e){\n\t\t\te.printStackTrace();\n\t\t\tthrow new iTrustException(e.getMessage());\n\t\t}\n\t}\n\t\n\t/**\n\t * Method to return a list of drug interactions for a given drug\n\t * @param drugCode - The ND Code of the drug\n\t * @return\n\t */\n\tpublic List<DrugInteractionBean> getInteractions(String drugCode) throws iTrustException {\n\t\ttry {\n\t\t\treturn drugDAO.getInteractions(drugCode);\n\t\t} catch (DBException e){\n\t\t\tthrow new iTrustException(e.getMessage());\n\t\t}\n\t}\n}", "EditApptTypeAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport java.sql.SQLException;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.ApptTypeBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.ApptTypeDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\nimport edu.ncsu.csc.itrust.validate.ApptTypeBeanValidator;\n\npublic class EditApptTypeAction {\n\tprivate long loggedInMID;\n\tprivate ApptTypeDAO apptTypeDAO;\n\tprivate TransactionDAO transDAO;\n\tprivate ApptTypeBeanValidator validator = new ApptTypeBeanValidator();\n\t\n\tpublic EditApptTypeAction(DAOFactory factory, long loggedInMID) {\n\t\tthis.loggedInMID = loggedInMID;\n\t\tthis.apptTypeDAO = factory.getApptTypeDAO();\n\t\tthis.transDAO = factory.getTransactionDAO();\n\t}\n\t\n\tpublic List<ApptTypeBean> getApptTypes() throws SQLException {\n\t\treturn apptTypeDAO.getApptTypes();\n\t}\n\t\n\tpublic String addApptType(ApptTypeBean apptType) throws SQLException, FormValidationException {\n\t\tvalidator.validate(apptType);\n\t\t\n\t\tList<ApptTypeBean> list = this.getApptTypes();\n\t\tfor(ApptTypeBean a : list) {\n\t\t\tif(a.getName().equals(apptType.getName()))\n\t\t\t\treturn \"Appointment Type: \"+apptType.getName()+\" already exists.\";\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tif (apptTypeDAO.addApptType(apptType)) {\n\t\t\t\ttransDAO.logTransaction(TransactionType.ADD_APPT_TYPE, loggedInMID, 0L,\n\t\t\t\t\t\t\"Added Appointment Type \" + apptType.getName());\n\t\t\t\treturn \"Success: \" + apptType.getName() + \" - Duration: \" + apptType.getDuration() + \" added\";\n\t\t\t} else\n\t\t\t\treturn \"The database has become corrupt. Please contact the system administrator for assistance.\";\n\t\t} catch (DBException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn e.getMessage();\n\t\t} \n\t}\n\t\n\tpublic String editApptType(ApptTypeBean apptType) throws SQLException, FormValidationException {\n\t\tvalidator.validate(apptType);\n\t\t\n\t\tList<ApptTypeBean> list = this.getApptTypes();\n\t\tint flag = 0;\n\t\tfor(ApptTypeBean a : list) {\n\t\t\tif(a.getName().equals(apptType.getName())) {\n\t\t\t\tflag = 1;\n\t\t\t\tif(a.getDuration() == apptType.getDuration())\n\t\t\t\t\treturn \"Appointment Type: \"+apptType.getName()+\" already has a duration of \"+apptType.getDuration()+\" minutes.\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag == 0) {\n\t\t\treturn \"Appointment Type: \"+apptType.getName()+\" you are trying to update does not exist.\";\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tif (apptTypeDAO.editApptType(apptType)) {\n\t\t\t\ttransDAO.logTransaction(TransactionType.UPDATE_APPT_TYPE, loggedInMID, 0L,\n\t\t\t\t\t\t\"Updated Appointment Type \" + apptType.getName());\n\t\t\t\treturn \"Success: \" + apptType.getName() + \" - Duration: \" + apptType.getDuration() + \" updated\";\n\t\t\t} else\n\t\t\t\treturn \"The database has become corrupt. Please contact the system administrator for assistance.\";\n\t\t} catch (DBException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn e.getMessage();\n\t\t}\n\t}\n\t\n\tpublic int getDurationByType(String at) throws SQLException {\n\t\tList<ApptTypeBean> list = this.getApptTypes();\n\t\tfor(ApptTypeBean a : list) {\n\t\t\tif(a.getName().equals(at))\n\t\t\t\treturn a.getDuration();\n\t\t}\n\t\treturn 0;\n\t}\n}", "EditHealthHistoryAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport java.util.List;\nimport edu.ncsu.csc.itrust.action.base.PatientBaseAction;\nimport edu.ncsu.csc.itrust.beans.HealthRecord;\nimport edu.ncsu.csc.itrust.beans.forms.HealthRecordForm;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.AuthDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.HealthRecordsDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\nimport edu.ncsu.csc.itrust.validate.HealthRecordFormValidator;\n\n/**\n * Edits the health history of a patient, used by editBasicHealth.jsp\n * \n * @author laurenhayward\n * \n */\npublic class EditHealthHistoryAction extends PatientBaseAction {\n\tprivate TransactionDAO transDAO;\n\tprivate HealthRecordsDAO hrDAO;\n\tprivate AuthDAO authDAO;\n\tprivate long loggedInMID;\n\tprivate HealthRecordFormValidator validator = new HealthRecordFormValidator();\n\n\t/**\n\t * The patient ID is validated by the superclass\n\t * \n\t * @param factory The DAOFactory which will be used to generate the DAOs used for this action.\n\t * @param loggedInMID The user authorizing this action.\n\t * @param pidString The patient (or other user) who is being edited.\n\t * @throws iTrustException\n\t */\n\tpublic EditHealthHistoryAction(DAOFactory factory, long loggedInMID, String pidString)\n\t\t\tthrows iTrustException {\n\t\tsuper(factory, pidString);\n\t\tthis.hrDAO = factory.getHealthRecordsDAO();\n\t\tthis.authDAO = factory.getAuthDAO();\n\t\tthis.transDAO = factory.getTransactionDAO();\n\t\tthis.loggedInMID = loggedInMID;\n\t}\n\n\t/**\n\t * returns the patient name\n\t * \n\t * @return patient name\n\t * @throws DBException\n\t * @throws iTrustException\n\t */\n\tpublic String getPatientName() throws DBException, iTrustException {\n\t\treturn authDAO.getUserName(pid);\n\t}\n\n\t/**\n\t * Adds a health record for the given patient\n\t * \n\t * @param pid  The patient record who is being edited.\n\t * @param hr  The filled out health record form to be added.\n\t * @return message - \"Information Recorded\" or exception's message\n\t * @throws FormValidationException\n\t */\n\tpublic String addHealthRecord(long pid, HealthRecordForm hr) throws FormValidationException,\n\t\t\tiTrustException {\n\t\tvalidator.validate(hr);\n\t\tHealthRecord record = transferForm(pid, hr);\n\t\thrDAO.add(record);\n\t\ttransDAO.logTransaction(TransactionType.ENTER_EDIT_PHR, loggedInMID, pid, \"EditHealthHistory - Add Record\");\n\t\treturn \"Information Recorded\";\n\t}\n\n\t\n/**\n * Moves the information from the form to a HealthRecord\n * \n * @param pid Patient of interest\n * @param form Form to be translated\n * @return a HealthRecord containing all the information in the form\n * @throws FormValidationException\n */\n\t\n\tprivate HealthRecord transferForm(long pid, HealthRecordForm form) throws FormValidationException {\n\t\tHealthRecord record = new HealthRecord();\n\t\trecord.setPatientID(pid);\n\t\trecord.setPersonnelID(loggedInMID);\n\t\trecord.setBloodPressureD(Integer.valueOf(form.getBloodPressureD()));\n\t\trecord.setBloodPressureN(Integer.valueOf(form.getBloodPressureN()));\n\t\trecord.setCholesterolHDL(Integer.valueOf(form.getCholesterolHDL()));\n\t\trecord.setCholesterolLDL(Integer.valueOf(form.getCholesterolLDL()));\n\t\trecord.setCholesterolTri(Integer.valueOf(form.getCholesterolTri()));\n\t\tif (record.getTotalCholesterol() < 100 || record.getTotalCholesterol() > 600)\n\t\t\tthrow new FormValidationException(\"Total cholesterol must be in [100,600]\");\n\t\trecord.setHeight(Double.valueOf(form.getHeight()));\n\t\trecord.setWeight(Double.valueOf(form.getWeight()));\n\t\trecord.setSmoker(Boolean.valueOf(form.getIsSmoker()));\n\t\treturn record;\n\t}\n\n\t/**\n\t * Returns a list of all HealthRecords for the given patient\n\t * \n\t * @param pid  The ID of the patient to look up\n\t * @return list of HealthRecords\n\t * @throws iTrustException\n\t */\n\tpublic List<HealthRecord> getAllHealthRecords(long pid) throws iTrustException {\n\t\ttransDAO.logTransaction(TransactionType.VIEW_HEALTH_RECORDS, loggedInMID, pid, \"EditHealthHistory - View Records\");\n\t\treturn hrDAO.getAllHealthRecords(pid);\n\t}\n}", "EditMonitoringListAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.RemoteMonitoringDataBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.AuthDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.RemoteMonitoringDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\n\n/**\n * Handles changes (adds and removes) to the monitoring list for a certain HCP.\n * \n */\npublic class EditMonitoringListAction {\n\tprivate RemoteMonitoringDAO rmDAO;\n\tprivate TransactionDAO transDAO;\n\tprivate AuthDAO authDAO;\n\tprivate long loggedInMID;\n\n\t/**\n\t * Constructor\n\t * \n\t * @param factory The DAOFactory used to create the DAOs used in this action.\n\t * @param loggedInMID The MID of the HCP editing their monitoring list.\n\t */\n\tpublic EditMonitoringListAction(DAOFactory factory, long loggedInMID) {\n\t\tthis.loggedInMID = loggedInMID;\n\t\tthis.rmDAO = factory.getRemoteMonitoringDAO();\n\t\tthis.transDAO = factory.getTransactionDAO();\n\t\tthis.authDAO = factory.getAuthDAO();\n\t}\n\n\t/**\n\t * Adds a patient to the current HCP's remote monitoring list\n\t * \n\t * @param patientMID the patient\n\t * @return true if added successfully. False if already in list.\n\t * @throws DBException\n\t */\n\tpublic boolean addToList(long patientMID) throws DBException {\n\t\ttransDAO.logTransaction(TransactionType.TELEMEDICINE_MONITORING, loggedInMID, patientMID, \"add\");\n\t\treturn rmDAO.addPatientToList(patientMID, loggedInMID);\n\t}\n\t\n\t/**\n\t * Removes a patient from the current HCP's remote monitoring list\n\t * \n\t * @param patientMID the patient\n\t * @return true if removed successfully. False if not in list.\n\t * @throws DBException\n\t */\n\tpublic boolean removeFromList(long patientMID) throws DBException {\n\t\ttransDAO.logTransaction(TransactionType.TELEMEDICINE_MONITORING, loggedInMID, patientMID, \"delete\");\n\t\treturn rmDAO.removePatientFromList(patientMID, loggedInMID);\n\t}\n\t\n\t/**\n\t * Returns whether a patient is in an HCP's list already\n\t * @param patientMID the patient\n\t * @return true if in DB, false otherwise\n\t * @throws DBException\n\t */\n\tpublic boolean isPatientInList(long patientMID) throws DBException {\n\t\tList<RemoteMonitoringDataBean> dataset = rmDAO.getPatientsData(loggedInMID);\n\t\tfor(RemoteMonitoringDataBean d: dataset) {\n\t\t\tif(d.getPatientMID() == patientMID)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * returns the patient name\n\t * \n\t * @return patient name\n\t * @throws DBException\n\t * @throws iTrustException\n\t */\n\tpublic String getPatientName(long pid) throws DBException, iTrustException {\n\t\treturn authDAO.getUserName(pid);\n\t}\n\t\n}", "EditOfficeVisitAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.action.base.OfficeVisitBaseAction;\nimport edu.ncsu.csc.itrust.beans.Email;\nimport edu.ncsu.csc.itrust.beans.HospitalBean;\nimport edu.ncsu.csc.itrust.beans.LabProcedureBean;\nimport edu.ncsu.csc.itrust.beans.MedicationBean;\nimport edu.ncsu.csc.itrust.beans.OfficeVisitBean;\nimport edu.ncsu.csc.itrust.beans.PrescriptionBean;\nimport edu.ncsu.csc.itrust.beans.PatientBean;\nimport edu.ncsu.csc.itrust.beans.DrugInteractionBean;\nimport edu.ncsu.csc.itrust.beans.AllergyBean;\nimport edu.ncsu.csc.itrust.beans.PrescriptionReportBean;\nimport edu.ncsu.csc.itrust.beans.forms.EditOfficeVisitForm;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.AllergyDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.DrugInteractionDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.HospitalsDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.LabProcedureDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.NDCodesDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.OfficeVisitDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.PatientDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\nimport edu.ncsu.csc.itrust.validate.EditOfficeVisitValidator;\n\n/**\n * Edits the office visits of a patient Used by editOfficeVisit.jsp\n * \n * @author laurenhayward\n * \n */\npublic class EditOfficeVisitAction extends OfficeVisitBaseAction {\n\tprivate EditOfficeVisitValidator validator = new EditOfficeVisitValidator();\n\tprivate PersonnelDAO personnelDAO;\n\tprivate HospitalsDAO hospitalDAO;\n\tprivate OfficeVisitDAO ovDAO;\n\tprivate LabProcedureDAO lpDAO;\n\tprivate TransactionDAO transDAO;\n\tprivate DrugInteractionDAO drugDAO;\n\tprivate AllergyDAO allergyDAO;\n\tprivate PatientDAO patDAO;\n\tprivate NDCodesDAO ndcDAO;\n\tprivate long loggedInMID;\n\tprivate long pid;\n\n\t/**\n\t * Used to identify the subactions that can comprise an office visit action.\n\t * Subactions help direct the action's logic because sometimes multiple \n\t * office visit actions can occur within one transaction.\n\t */\n\tprivate enum OVSubAction {\n\t\tADD_DIAGNOSIS,\n\t\tREMOVE_DIAGNOSIS,\n\t\tADD_PROCEDURE,\n\t\tREMOVE_PROCEDURE,\n\t\tADD_MEDICATION,\n\t\tREMOVE_MEDICATION,\n\t\tADD_LAB_PROCEDURE,\n\t\tREMOVE_LAB_PROCEDURE,\n\t\tADD_IMMUNIZATION,\n\t\tREMOVE_IMMUNIZATION\n\t};\n\n\t/**\n\t * Patient id and office visit id validated by super class\n\t * \n\t * @param factory The DAOFactory to be used in creating the DAOs for this action.\n\t * @param loggedInMID The MID of the user who is authorizing this action.\n\t * @param pidString The patient who this action is performed on.\n\t * @param ovIDString The ID of the office visit in play.\n\t * @throws iTrustException\n\t */\n\tpublic EditOfficeVisitAction(DAOFactory factory, long loggedInMID, String pidString, String ovIDString)\n\t\t\tthrows iTrustException {\n\t\tsuper(factory, pidString, ovIDString);\n\t\tpid = Long.parseLong(pidString);\n\t\tovDAO = factory.getOfficeVisitDAO();\n\t\tthis.personnelDAO = factory.getPersonnelDAO();\n\t\tthis.hospitalDAO = factory.getHospitalsDAO();\n\t\tthis.lpDAO = factory.getLabProcedureDAO();\n\t\tthis.transDAO = factory.getTransactionDAO();\n\t\tthis.drugDAO = factory.getDrugInteractionDAO();\n\t\tthis.allergyDAO = factory.getAllergyDAO();\n\t\tthis.ndcDAO = factory.getNDCodesDAO();\n\t\tthis.patDAO = factory.getPatientDAO();\n\t\tthis.loggedInMID = loggedInMID;\n\t}\n\n\t/**\n\t * Returns the office visit bean for the office visit\n\t * \n\t * @return the OfficeVisitBean of the office visit\n\t * @throws iTrustException\n\t */\n\tpublic OfficeVisitBean getOfficeVisit() throws iTrustException {\n\t\tOfficeVisitBean officeVisit = ovDAO.getOfficeVisit(ovID);\n\t\ttransDAO.logTransaction(TransactionType.VIEW_OFFICE_VISIT, loggedInMID, pid, \"EditOffceVisit - View office visits\");\n\t\treturn officeVisit;\n\t}\n\t\n\t/**\n\t * Returns a list of the lab procedures that have been done in an office visit.\n\t * \n\t * @param mid the doctor the visit was with\n\t * @param ovid the office visit's id\n\t * @return a list of the lab procedures that were done in that visit\n\t * @throws DBException\n\t */\n\n\tpublic List<LabProcedureBean> getLabProcedures(long mid, long ovid) throws DBException {\n\t\ttransDAO.logTransaction(TransactionType.VIEW_LAB_PROCEDURE, loggedInMID, pid, \"EditOffceVisit - View lab procedures\");\n\t\treturn lpDAO.getAllLabProceduresForDocOV(mid, ovid);\n\t}\n\n\t/**\n\t * This is a list of all hospitals, ordered by the office visit's hcp FIRST\n\t * \n\t * @param hcpID\n\t * @return\n\t * @throws iTrustException\n\t */\n\tpublic List<HospitalBean> getHospitals(long hcpID) throws iTrustException {\n\t\tList<HospitalBean> hcpsHospitals = personnelDAO.getHospitals(hcpID);\n\t\tList<HospitalBean> allHospitals = hospitalDAO.getAllHospitals();\n\t\treturn combineLists(hcpsHospitals, allHospitals);\n\t}\n\n\t\n\t/**\n\t * Combines two lists of hospitals\n\t * \n\t * @param hcpsHospitals hospitals the HCP is assigned to\n\t * @param allHospitals all hopsitals\n\t * @return the combined list\n\t */\n\tprivate List<HospitalBean> combineLists(List<HospitalBean> hcpsHospitals, List<HospitalBean> allHospitals) {\n\t\tfor (HospitalBean hos : allHospitals) {\n\t\t\tif (!hcpsHospitals.contains(hos))\n\t\t\t\thcpsHospitals.add(hos);\n\t\t}\n\t\treturn hcpsHospitals;\n\t}\n\n\t/**\n\t * Updates the office visit with information from the form passed in\n\t * \n\t * @param form\n\t *            information to update\n\t * @return \"success\" or exception's message\n\t * @throws FormValidationException\n\t */\n\tpublic String updateInformation(EditOfficeVisitForm form) throws FormValidationException {\n\t\tString confirm = \"\";\n\t\ttry {\n\t\t\tcheckAddSubAction(OVSubAction.ADD_DIAGNOSIS, form.getAddDiagID(), ovID, null);\n\t\t\tcheckAddSubAction(OVSubAction.ADD_PROCEDURE, form.getAddProcID(), ovID, null);\n\t\t\tcheckAddSubAction(OVSubAction.ADD_IMMUNIZATION, form.getAddImmunizationID(), ovID, null, form.getHcpID());\n\t\t\tcheckAddSubAction(OVSubAction.ADD_LAB_PROCEDURE, form.getAddLabProcID(), ovID, null);\n\t\t\tcheckAddPrescription(form, ovID);\n\t\t\tcheckRemoveSubAction(OVSubAction.REMOVE_DIAGNOSIS, form.getRemoveDiagID());\n\t\t\tcheckRemoveSubAction(OVSubAction.REMOVE_LAB_PROCEDURE, form.getRemoveLabProcID());\n\t\t\tcheckRemoveSubAction(OVSubAction.REMOVE_PROCEDURE, form.getRemoveProcID());\n\t\t\tcheckRemoveSubAction(OVSubAction.REMOVE_IMMUNIZATION, form.getRemoveImmunizationID());\n\t\t\tcheckRemoveSubAction(OVSubAction.REMOVE_MEDICATION, form.getRemoveMedID());\n\t\t\tupdateOv(form);\n\t\t\ttransDAO.logTransaction(TransactionType.DOCUMENT_OFFICE_VISIT, loggedInMID, getOfficeVisit().getPatientID(), \"EditOfficeVisit - edited office visit \" + ovID);\n\t\t\tconfirm = \"success\";\n\t\t\treturn confirm;\n\t\t} catch (iTrustException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn e.getMessage();\n\t\t}\n\t}\n\t\n\tpublic String hasInteraction(String drug, String pid, String startdate, String enddate) throws iTrustException{\n\t\tString response = \"\";\n\t\ttry {\n\n\t\t\tSimpleDateFormat original = new SimpleDateFormat(\"MM/dd/yyyy\");\n\t\t\tSimpleDateFormat needed = new SimpleDateFormat(\"yyyy/MM/dd\");\n\t\t\t\n\t\t\tDate start = original.parse(startdate);\n\t\t\tstartdate = needed.format(start);\n\t\t\tDate end = original.parse(enddate);\n\t\t\tenddate = needed.format(end);\n\t\t\t\n\t\t\t\n\t\t\tstartdate = startdate.replaceAll(\"/\", \"-\");\n\t\t\tenddate = enddate.replaceAll(\"/\", \"-\");\n\t\t\tList<PrescriptionReportBean> prBeanList = ovDAO.getPrescriptionReportsByDate(Long.parseLong(pid), startdate, enddate);\n\t\t\tList<DrugInteractionBean> dBeanList = drugDAO.getInteractions(drug);\n\t\t\tfor (PrescriptionReportBean prBean : prBeanList){\n\t\t\t\tString presDrug = prBean.getPrescription().getMedication().getNDCode();\n\t\t\t\tfor (DrugInteractionBean dBean : dBeanList){\n\t\t\t\t\tString intDrug1 = dBean.getFirstDrug();\n\t\t\t\t\tString intDrug2 = dBean.getSecondDrug();\n\t\t\t\t\t\n\t\t\t\t\tif (presDrug.equals(intDrug1) && drug.equals(intDrug2)){\n\t\t\t\t\t\tresponse += \"Currently Prescribed: \" + prBean.getPrescription().getMedication().getDescription() + \n\t\t\t\t\t\t\". Start Date: \" + prBean.getPrescription().getStartDateStr() \n\t\t\t\t\t\t+ \", End Date: \" + prBean.getPrescription().getEndDateStr() + \". \";\n\t\t\t\t\t\tresponse += \"Interactions: \" + prBean.getPrescription().getMedication().getDescription() + \" - \" + ndcDAO.getNDCode((dBean.getSecondDrug())).getDescription() + \". \";\n\t\t\t\t\t\tresponse += \"Description: \" + dBean.getDescription() + \"  \";\n\t\t\t\t\t} else if (presDrug.equals(intDrug2) && drug.equals(intDrug1)){\n\t\t\t\t\t\tresponse += \"Currently Prescribed: \" + prBean.getPrescription().getMedication().getDescription() + \". Start Date: \" + prBean.getPrescription().getStartDateStr() \n\t\t\t\t\t\t+ \", End Date: \" + prBean.getPrescription().getEndDateStr() + \". \";\n\t\t\t\t\t\tresponse += \"Interactions: \" + prBean.getPrescription().getMedication().getDescription() + \" - \" + ndcDAO.getNDCode(dBean.getFirstDrug()).getDescription() + \". \";\n\t\t\t\t\t\tresponse += \"Description: \" + dBean.getDescription() + \"  \";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t} catch (DBException e){\n\t\t\te.printStackTrace();\n\t\t\tthrow new iTrustException(e.getMessage());\n\t\t} catch (ParseException e){\n\t\t\te.printStackTrace();\n\t\t\tthrow new iTrustException(e.getMessage());\n\t\t}\n\t\treturn response;\n\t}\n\t\n\tpublic String  isAllergyOnList(String patMID, String ndcode) throws iTrustException{\n\t\tString response = \"\";\n\t\ttry {\n\t\t\tList<AllergyBean> allergyList = allergyDAO.getAllergies(Long.parseLong(patMID));\n\t\t\tif (allergyList.isEmpty()) return response;\n\t\t\tMedicationBean medBean = ndcDAO.getNDCode(ndcode);\n\t\t\tif(medBean == null) return response;\n\t\t\tString newDrug = medBean.getDescription();\n\t\t\tfor (AllergyBean allergyBean : allergyList){\n\t\t\t\tString currentAllerDrug = allergyBean.getDescription();\n\t\t\t\t//Allergy: Aspirin. First Found: 12/20/2008. \n\t\t\t\tif (newDrug.equals(currentAllerDrug)){\n\t\t\t\t\tresponse += \"Allergy: \" + newDrug + \". First Found: \" + allergyBean.getFirstFoundStr();\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (DBException e){\n\t\t\te.printStackTrace();\n\t\t\tthrow new iTrustException(e.getMessage());\n\t\t}\n\t\treturn response;\n\t}\n\t\n\t/**\n\t * \n\t * Sends e-mail regarding the prescribed dangerous drug.\n\t * \n\t * @param hcpID HCP the prescription is made by\n\t * @param patID ID of the patient prescription is for\n\t * @param problem The allergy and/or interaction that is the problem\n\t * @return the sent e-mail\n\t * @throws DBException\n\t */\t\n\tpublic Email makeEmailApp(long hcpID, String patID, String problem) throws DBException, iTrustException {\n\t\tPatientBean p = patDAO.getPatient(Long.parseLong(patID));\n\t\tString hcpName = personnelDAO.getName(hcpID);\n\t\tEmail email = new Email();\n\t\temail.setFrom(\"no-reply@itrust.com\");\n\t\temail.setToList(Arrays.asList(p.getEmail()));\n\t\temail.setSubject(\"HCP has prescribed you a potentially dangerous medication\");\n\t\temail.setBody(String\n\t\t\t\t.format(\n\t\t\t\t\t\"%s has prescribed a medication that you are allergic to or that has a known interaction with a drug you are currently taking. %s\",\n\t\t\t\t\thcpName, problem));\n\t\treturn email;\n\t}\n\t\n/**\n * Adds a prescription to an office visit\n * \n * @param form the information about the prescription\n * @param ovID the id for the office visit\n * @throws DBException\n * @throws FormValidationException\n */\n\t\n\tprivate void checkAddPrescription(EditOfficeVisitForm form, long ovID) throws DBException,\n\t\t\tFormValidationException {\n\t\tif (form.getAddMedID() != null && !\"\".equals(form.getAddMedID())) {\n\t\t\tnew EditOfficeVisitValidator(true).validate(form);\n\t\t\tPrescriptionBean pres = new PrescriptionBean();\n\t\t\tpres.setDosage(Integer.valueOf(form.getDosage()));\n\t\t\tpres.setEndDateStr(form.getEndDate());\n\t\t\tpres.setStartDateStr(form.getStartDate());\n\t\t\tpres.setInstructions(form.getInstructions());\n\t\t\tMedicationBean med = new MedicationBean();\n\t\t\tmed.setNDCode(form.getAddMedID());\n\t\t\tpres.setMedication(med);\n\t\t\tpres.setVisitID(ovID);\n\t\t\ttransDAO.logTransaction(TransactionType.ADD_PRESCRIPTION, loggedInMID, pid, \"EditOffceVisit - Add prescription - \" + pres.getMedication().getNDCode());\n\t\t\tovDAO.addPrescription(pres);\n\t\t}\n\t}\n\n\t/**\n\t * Updates the office visit.\n\t * \n\t * @param form form with all the information\n\t * @throws DBException\n\t * @throws FormValidationException\n\t */\n\tprivate void updateOv(EditOfficeVisitForm form) throws DBException, FormValidationException {\n\t\tvalidator.validate(form);\n\t\tOfficeVisitBean ov = new OfficeVisitBean(ovID);\n\t\tov.setNotes(form.getNotes());\n\t\tov.setVisitDateStr(form.getVisitDate());\n\t\tov.setHcpID(Long.valueOf(form.getHcpID()));\n\t\tov.setPatientID(Long.valueOf(form.getPatientID()));\n\t\tov.setHospitalID(form.getHospitalID());\n\t\ttransDAO.logTransaction(TransactionType.UPDATE_OFFICE_VISIT, loggedInMID, pid, \"EditOffceVisit - Update office visit\");\n\t\tovDAO.update(ov);\n\t}\n\n\t\n\t/**\n\t * Adds a diagnosis or a procedure to an office visit\n\t * \n\t * @param action the type of action to add\n\t * @param code the CPT code of the action\n\t * @param visitID the office visit to add the action to\n\t * @param dateOfDeath the date of death, if needed\n\t * @return true if the operation completed; false if the code was null\n\t * @throws DBException\n\t * @throws iTrustException\n\t */\n\t\n\tprivate boolean checkAddSubAction(OVSubAction action, String code, long visitID, String dateOfDeath)\n\t\t\tthrows DBException, iTrustException {\n\t\tif (code == null || \"\".equals(code)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tswitch (action) {\n\t\t\tcase ADD_DIAGNOSIS:\n\t\t\t\tovDAO.addDiagnosisToOfficeVisit(Double.valueOf(code), visitID);\n\t\t\t\tbreak;\n\t\t\tcase ADD_IMMUNIZATION:\n\t\t\tcase ADD_PROCEDURE:\n\t\t\t\tovDAO.addProcedureToOfficeVisit(code, visitID, \"\");\n\t\t\t\tbreak;\n\t\t\tcase ADD_LAB_PROCEDURE:\n\t\t\t\tovDAO.addLabProcedureToOfficeVisit(code, visitID, pid);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate boolean checkAddSubAction(OVSubAction action, String code, long visitID, String dateOfDeath, String hcpid)\n\tthrows DBException, iTrustException {\n\t\tif (code == null || \"\".equals(code)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tovDAO.addProcedureToOfficeVisit(code, visitID, hcpid);\n\t\t\treturn true;\n\t\t}\n\t }\n\t\n\t/**\n\t * Removes an action from an office visit\n\t * \n\t * @param action type of action to remove\n\t * @param input id for the action to remove\n\t * @return true if the operation completed; false if the code was null\n\t * @throws DBException\n\t */\n\n\tprivate boolean checkRemoveSubAction(OVSubAction action, String input) throws DBException {\n\t\tif (input == null || \"\".equals(input))\n\t\t\treturn false;\n\t\tlong removeID;\n\t\ttry {\n\t\t\tremoveID = Long.valueOf(input);\n\t\t} catch (NumberFormatException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn false;\n\t\t}\n\t\tswitch (action) {\n\t\tcase REMOVE_DIAGNOSIS:\n\t\t\tovDAO.removeDiagnosisFromOfficeVisit(removeID);\n\t\t\tbreak;\n\t\tcase REMOVE_IMMUNIZATION:\n\t\tcase REMOVE_PROCEDURE:\n\t\t\tovDAO.removeProcedureFromOfficeVisit(removeID);\n\t\t\tbreak;\n\t\tcase REMOVE_MEDICATION:\n\t\t\tovDAO.removePrescription(removeID);\n\t\t\tbreak;\n\t\tcase REMOVE_LAB_PROCEDURE:\n\t\t\tovDAO.removeLabProcedureFromOfficeVisit(removeID);\n\t\t\tbreak;\n\t\t}\n\t\treturn true;\n\t}\n\n}", "EditPatientAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.action.base.PatientBaseAction;\nimport edu.ncsu.csc.itrust.beans.Email;\nimport edu.ncsu.csc.itrust.beans.PatientBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.PatientDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\nimport edu.ncsu.csc.itrust.validate.PatientValidator;\nimport edu.ncsu.csc.itrust.EmailUtil;\n\n\n/**\n * Edits a patient Used by editPatient.jsp\n * \n * @author laurenhayward\n * \n */\npublic class EditPatientAction extends PatientBaseAction {\n\tprivate TransactionDAO transDAO;\n\tprivate PatientValidator validator = new PatientValidator();\n\tprivate PatientDAO patientDAO;\n\tprivate long loggedInMID;\n\tprivate EmailUtil emailutil;\n\n\t/**\n\t * The super class validates the patient id\n\t * \n\t * @param factory The DAOFactory used to create the DAOs for this action.\n\t * @param loggedInMID The MID of the user who is authorizing this action.\n\t * @param pidString The MID of the patient being edited.\n\t * @throws iTrustException\n\t */\n\tpublic EditPatientAction(DAOFactory factory, long loggedInMID, String pidString) throws iTrustException {\n\t\tsuper(factory, pidString);\n\t\tthis.patientDAO = factory.getPatientDAO();\n\t\tthis.transDAO = factory.getTransactionDAO();\n\t\tthis.loggedInMID = loggedInMID;\n\t\temailutil = new EmailUtil(factory);\n\t}\n\n\t/**\n\t * Takes the information out of the PatientBean param and updates the patient's information\n\t * \n\t * @param p\n\t *            the new patient information\n\t * @throws iTrustException\n\t * @throws FormValidationException\n\t */\n\tpublic void updateInformation(PatientBean p) throws iTrustException, FormValidationException {\n\t\tp.setMID(pid); // for security reasons\n\t\tvalidator.validate(p);\n\t\tpatientDAO.editPatient(p);\n\t\ttransDAO.logTransaction(TransactionType.ENTER_EDIT_DEMOGRAPHICS, loggedInMID, pid, \"EditPatient - Made Changes\");\n\t\temailutil.sendEmail(makeEmail());\n\t}\n\n\t/**\n\t * Returns a PatientBean for the patient\n\t * \n\t * @return the PatientBean\n\t * @throws DBException\n\t */\n\tpublic PatientBean getPatient() throws DBException {\n\t\ttransDAO.logTransaction(TransactionType.ENTER_EDIT_DEMOGRAPHICS, loggedInMID, pid, \"EditPatient - View Patient\");\n\t\treturn patientDAO.getPatient(this.getPid());\n\t}\n\n\t/**\n\t *  Creates and e-mail to inform the patient that their information has been updated.\n\t *  \n\t * @return the email with the notice\n\t * @throws DBException\n\t */\n\tprivate Email makeEmail() throws DBException{\n\n\t\tEmail email = new Email();\n\t\tList<PatientBean> reps = patientDAO.getRepresenting(pid);\n\t\tPatientBean pb = patientDAO.getPatient(pid);\n\t\t\n\t\tList<String> toAddrs = new ArrayList<String>();\n\t\ttoAddrs.add(pb.getEmail());\n\t\tfor (PatientBean r: reps) {\n\t\t\ttoAddrs.add(r.getEmail());\n\t\t}\n\t\t\n\t\temail.setFrom(\"no-reply@itrust.com\");\n    \temail.setToList(toAddrs); // patient and personal representative\n    \temail.setSubject(String.format(\"Patient Information Updated\"));\n    \temail.setBody(\"Dear \" + pb.getFullName() + \",\\n\\tYour patient record information has been updated. \" + \n    \t\t\t\"Please login to iTrust to see who has viewed your records.\");\n\t\treturn email;\n\t}\n\t\n\tpublic void editMessageFilter(String filter) throws iTrustException, FormValidationException {\n\t\tPatientBean b = this.getPatient();\n\t\tb.setMessageFilter(filter);\n\t\tthis.updateInformation(b);\n\t}\n}", "EditPersonnelAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport edu.ncsu.csc.itrust.action.base.PersonnelBaseAction;\nimport edu.ncsu.csc.itrust.beans.PersonnelBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.AuthDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.Role;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\nimport edu.ncsu.csc.itrust.validate.PersonnelValidator;\n\n/**\n * Edits the designated personnel Used by admin/editPersonnel.jsp, staff/editMyDemographics.jsp,\n * editPersonnel.jsp\n * \n * @author laurenhayward\n * \n */\npublic class EditPersonnelAction extends PersonnelBaseAction {\n\tprivate long loggedInMID;\n\tprivate PersonnelDAO personnelDAO;\n\tprivate TransactionDAO transDAO;\n\tprivate AuthDAO authDAO;\n\tprivate PersonnelValidator validator = new PersonnelValidator();;\n\n\t/**\n\t * Super class validates the patient id\n\t * \n\t * @param factory The DAOFactory used to create the DAOs for this action.\n\t * @param loggedInMID The MID of the user editing this personnel.\n\t * @param pidString The ID of the user being edited.\n\t * @throws iTrustException\n\t */\n\tpublic EditPersonnelAction(DAOFactory factory, long loggedInMID, String pidString) throws iTrustException {\n\t\tsuper(factory, pidString);\n\n\t\tthis.authDAO = factory.getAuthDAO();\n\t\tlong pidlong = Long.parseLong(pidString);\n\t\tRole editor = authDAO.getUserRole(loggedInMID);\n\t\tRole editing = authDAO.getUserRole(pidlong);\n\n\t\tif (editor == editing && pidlong != loggedInMID)\n\t\t\tthrow new iTrustException(\"You can only edit your own demographics!\");\n\t\telse if (editor == Role.HCP && editing == Role.ADMIN || editor == Role.UAP && editing == Role.HCP\n\t\t\t\t|| editor == Role.ADMIN && editing == Role.UAP)\n\t\t\tthrow new iTrustException(\"You are not authorized to edit this record!\");\n\n\t\tthis.personnelDAO = factory.getPersonnelDAO();\n\t\tthis.transDAO = factory.getTransactionDAO();\n\t\tthis.loggedInMID = loggedInMID;\n\t}\n\n\t/**\n\t * Takes information from the personnelForm param and updates the patient\n\t * \n\t * @param personnelForm\n\t *            PersonnelBean with new information\n\t * @throws iTrustException\n\t * @throws FormValidationException\n\t */\n\tpublic void updateInformation(PersonnelBean personnelForm) throws iTrustException,\n\t\t\tFormValidationException {\n\t\tpersonnelForm.setMID(pid);\n\t\tvalidator.validate(personnelForm);\n\t\tpersonnelDAO.editPersonnel(personnelForm);\n\t\ttransDAO.logTransaction(TransactionType.CREATE_DISABLE_PATIENT_HCP, loggedInMID);\n\t}\n\t\n\tpublic void editMessageFilter(String filter) throws iTrustException, FormValidationException {\n\t\tPersonnelBean b = personnelDAO.getPersonnel(this.getPid());\n\t\tb.setMessageFilter(filter);\n\t\tthis.updateInformation(b);\n\t}\n\n}", "EditPHRAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.EmailUtil;\nimport edu.ncsu.csc.itrust.action.base.PatientBaseAction;\nimport edu.ncsu.csc.itrust.beans.PersonnelBean;\nimport edu.ncsu.csc.itrust.beans.AllergyBean;\nimport edu.ncsu.csc.itrust.beans.DiagnosisBean;\nimport edu.ncsu.csc.itrust.beans.Email;\nimport edu.ncsu.csc.itrust.beans.FamilyMemberBean;\nimport edu.ncsu.csc.itrust.beans.HealthRecord;\nimport edu.ncsu.csc.itrust.beans.OfficeVisitBean;\nimport edu.ncsu.csc.itrust.beans.PatientBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.AllergyDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.FamilyDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.HealthRecordsDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.ICDCodesDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.OfficeVisitDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.PatientDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\nimport edu.ncsu.csc.itrust.exception.NoHealthRecordsException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\nimport edu.ncsu.csc.itrust.risk.ChronicDiseaseMediator;\nimport edu.ncsu.csc.itrust.risk.RiskChecker;\nimport edu.ncsu.csc.itrust.validate.AllergyBeanValidator;\n\n\n/**\n * Edits the patient health record for a given patient Used by editPHR.jsp\n * \n * @author laurenhayward\n * \n */\npublic class EditPHRAction extends PatientBaseAction {\n\tprivate DAOFactory factory;\n\tprivate PatientDAO patientDAO;\n\tprivate AllergyDAO allergyDAO;\n\tprivate FamilyDAO familyDAO;\n\tprivate HealthRecordsDAO hrDAO;\n\tprivate OfficeVisitDAO ovDAO;\n\tprivate TransactionDAO transDAO;\n\tprivate ICDCodesDAO icdDAO;\n\tprivate long loggedInMID;\n\tprivate ChronicDiseaseMediator diseaseMediator;\n\tprivate PersonnelDAO personnelDAO;\n\tprivate PersonnelBean HCPUAP;\n\tprivate PatientBean patient;\n\tprivate EmailUtil emailutil;\n\t\n\t/**\n\t * Super class validates the patient id\n\t * \n\t * @param factory The DAOFactory to be used in creating DAOs for this action.\n\t * @param loggedInMID The MID of the currently logged in user who is authorizing this action.\n\t * @param pidString The MID of the patient whose personal health records are being added.\n\t * @throws iTrustException\n\t * @throws DBException\n\t * @throws NoHealthRecordsException\n\t */\n\tpublic EditPHRAction(DAOFactory factory, long loggedInMID, String pidString) throws iTrustException,\n\t\t\tDBException {\n\t\tsuper(factory, pidString);\n\t\tthis.patientDAO = factory.getPatientDAO();\n\t\tthis.allergyDAO = factory.getAllergyDAO();\n\t\tthis.familyDAO = factory.getFamilyDAO();\n\t\tthis.hrDAO = factory.getHealthRecordsDAO();\n\t\tthis.ovDAO = factory.getOfficeVisitDAO();\n\t\tthis.transDAO = factory.getTransactionDAO();\n\t\tthis.icdDAO = factory.getICDCodesDAO();\n\t\tthis.loggedInMID = loggedInMID;\n\t\tthis.personnelDAO = factory.getPersonnelDAO();\n\t\tthis.HCPUAP = personnelDAO.getPersonnel(loggedInMID);\n\t\tthis.patient = patientDAO.getPatient(pid);\n\t\temailutil = new EmailUtil(factory);\n\t\tthis.factory = factory;\n\t}\n\n\t/**\n\t * Adds an allergy to the patient's records\n\t * \n\t * @param pid\n\t * @param description\n\t * @return \"Allergy Added\", exception message, a list of invalid fields, or \"\" (only if description is\n\t *         null)\n\t * @throws iTrustException\n\t */\n\tpublic String updateAllergies(long pid, String description) throws iTrustException {\n\t\t\n\t\temailutil.sendEmail(makeEmail());\n\t\t\n\t\tif (description != null && !description.equals(\"\")) {\n\t\t\ttry {\n\t\t\t\tAllergyBean bean = new AllergyBean();\n\t\t\t\tbean.setDescription(description);\n\t\t\t\tAllergyBeanValidator abv = new AllergyBeanValidator();\n\t\t\t\tabv.validate(bean);\n\t\t\t\tallergyDAO.addAllergy(pid, description);\n\t\t\t\ttransDAO.logTransaction(TransactionType.ENTER_EDIT_PHR, loggedInMID, pid, \"EditPHR - added allergy \" + description);\n\t\t\t\treturn \"Allergy Added\";\n\t\t\t} catch (FormValidationException e2) {\n\t\t\t\treturn \"<span class=error>Error: Invalid Fields--\" + e2.getErrorList() + \"</span><p />\";\n\t\t\t}\n\t\t} else\n\t\t\treturn \"\";\n\t}\n\n\t/**\n\t * Returns a PatientBean for the patient\n\t * \n\t * @return PatientBean\n\t * @throws iTrustException\n\t */\n\tpublic PatientBean getPatient() throws iTrustException {\n\t\ttransDAO.logTransaction(TransactionType.VIEW_RECORDS, loggedInMID, pid, \"EditPHR - view patient record \");\n\t\treturn patientDAO.getPatient(pid);\n\t}\n\n\t/**\n\t * Returns a list of AllergyBeans for the patient\n\t * \n\t * @return list of AllergyBeans\n\t * @throws iTrustException\n\t */\n\tpublic List<AllergyBean> getAllergies() throws iTrustException {\n\t\treturn allergyDAO.getAllergies(pid);\n\t}\n\n\t/**\n\t * Returns a list of FamilyMemberBeans for the patient\n\t * \n\t * @return list of FamilyMemberBeans\n\t * @throws iTrustException\n\t */\n\tpublic List<FamilyMemberBean> getFamily() throws iTrustException {\n\t\tList<FamilyMemberBean> fam = new ArrayList<FamilyMemberBean>();\n\t\tList<FamilyMemberBean> parents = null;\n\t\tparents = familyDAO.getParents(pid);\n\t\tfam.addAll(parents);\n\t\tfam.addAll(familyDAO.getSiblings(pid));\n\t\tfam.addAll(familyDAO.getChildren(pid));\n\n\t\t\n\t\tif(parents != null) {\n\t\t\tList<FamilyMemberBean> grandparents = new ArrayList<FamilyMemberBean>();\n\t\t\tfor(FamilyMemberBean parent : parents) {\n\t\t\t\tgrandparents.addAll(familyDAO.getParents(parent.getMid()));\n\t\t\t}\n\t\t\t\n\t\t\tfam.addAll(grandparents);\n\t\t\t\n\t\t\tfor(FamilyMemberBean gp : grandparents) {\n\t\t\t\tgp.setRelation(\"Grandparent\");\n\t\t\t}\n\t\t}\n\t\ttransDAO.logTransaction(TransactionType.VIEW_RECORDS, loggedInMID, pid, \"EditPHR - view patient family information \");\n\t\treturn fam;\n\t}\n\n\n\t/**\n\t * Returns a list of HealthRecords for the patient\n\t * \n\t * @return\n\t * @throws iTrustException\n\t */\n\tpublic List<HealthRecord> getAllHealthRecords() throws iTrustException {\n\t\tList<HealthRecord> allHealthRecords = hrDAO.getAllHealthRecords(pid);\n\t\ttransDAO.logTransaction(TransactionType.VIEW_HEALTH_RECORDS, loggedInMID, pid, \"EditPHR - Viewed patient records\");\n\t\treturn allHealthRecords;\n\t}\n\n\t/**\n\t * Returns a list of OfficeVisitBeans\n\t * \n\t * @return\n\t * @throws iTrustException\n\t */\n\tpublic List<OfficeVisitBean> getAllOfficeVisits() throws iTrustException {\n\t\ttransDAO.logTransaction(TransactionType.VIEW_OFFICE_VISIT, loggedInMID, pid, \"EditPHR - view patient office visits \");\n\t\treturn ovDAO.getAllOfficeVisits(pid);\n\t}\n\n\t/**\n\t * Returns a complete OfficeVisitBean given a visitID\n\t * \n\t * @return\n\t * @throws iTrustException\n\t */\n\tpublic OfficeVisitBean getCompleteOfficeVisit(long visitID) throws iTrustException {\n\t\treturn ovDAO.getOfficeVisit(visitID);\n\t}\n\t\n\t/**\n\t * Returns a list of diseases for which the patient is at risk\n\t * \n\t * @return list of RiskCheckers\n\t * @throws iTrustException\n\t * @throws DBException\n\t */\n\tpublic List<RiskChecker> getDiseasesAtRisk() throws NoHealthRecordsException,iTrustException,DBException {\n\t\tthis.diseaseMediator = new ChronicDiseaseMediator(factory, pid);\n\t\ttransDAO.logTransaction(TransactionType.IDENTIFY_RISK_FACTORS, loggedInMID, pid, \"Check for risk factors\");\n\t\treturn diseaseMediator.getDiseaseAtRisk();\n\t}\n\t\n\t/**\n\t * Checks to see if a particular family member has high blood pressure\n\t * \n\t * @param member the family member to check\n\t * @return true if the family member has high blood pressure.  False if there are no records or the family member does not have high blood pressure\n\t * @throws iTrustException\n\t */\n\tpublic boolean doesFamilyMemberHaveHighBP(FamilyMemberBean member) throws iTrustException {\n\t\tList<HealthRecord> records = hrDAO.getAllHealthRecords(member.getMid());\n\t\tif(records.size() == 0)\n\t\t\treturn false;\n\t\tfor(HealthRecord record : records) {\n\t\t\tif(record.getBloodPressureSystolic() > 240 || record.getBloodPressureDiastolic() > 120 )\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Checks to see if a particular family member has high cholesterol\n\t * \n\t * @param member the family member to check\n\t * @return true if the family member has high cholesterol.  False if there are no records or the family member does not\n\t * @throws iTrustException\n\t */\t\n\tpublic boolean doesFamilyMemberHaveHighCholesterol(FamilyMemberBean member) throws iTrustException {\n\t\tList<HealthRecord> records = hrDAO.getAllHealthRecords(member.getMid());\n\t\tif(records.size() == 0)\n\t\t\treturn false;\n\t\tfor(HealthRecord record : records) {\n\t\t\tif(record.getCholesterolHDL() < 35 || record.getCholesterolLDL() > 250 )\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Checks to see if a particular family member has diabetes\n\t * \n\t * @param member the family member to check\n\t * @return true if the family member has diabetes.  False if there are no records or the family member does not\n\t * @throws iTrustException\n\t */\t\n\n\tpublic boolean doesFamilyMemberHaveDiabetes(FamilyMemberBean member) throws iTrustException {\n\t\tList<DiagnosisBean> diagnoses = patientDAO.getDiagnoses(member.getMid());\n\t\tif(diagnoses.size() == 0)\n\t\t\treturn false;\n\t\tfor(DiagnosisBean diag : diagnoses) {\n\t\t\tif(diag.getICDCode().startsWith(\"250\"))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Checks to see if a particular family member has cancer\n\t * \n\t * @param member the family member to check\n\t * @return true if the family member has cancer.  False if there are no records or the family member does not\n\t * @throws iTrustException\n\t */\t\n\n\tpublic boolean doesFamilyMemberHaveCancer(FamilyMemberBean member) throws iTrustException {\n\t\tList<DiagnosisBean> diagnoses = patientDAO.getDiagnoses(member.getMid());\n\t\tif(diagnoses.size() == 0)\n\t\t\treturn false;\n\t\tfor(DiagnosisBean diag : diagnoses) {\n\t\t\tif(diag.getICDCode().startsWith(\"199\"))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Checks to see if a particular family member has heart disease\n\t * \n\t * @param member the family member to check\n\t * @return true if the family member has heart disease.  False if there are no records or the family member does not\n\t * @throws iTrustException\n\t */\t\n\tpublic boolean doesFamilyMemberHaveHeartDisease(FamilyMemberBean member) throws iTrustException {\n\t\tList<DiagnosisBean> diagnoses = patientDAO.getDiagnoses(member.getMid());\n\t\tif(diagnoses.size() == 0)\n\t\t\treturn false;\n\t\tfor(DiagnosisBean diag : diagnoses) {\n\t\t\tif(diag.getICDCode().startsWith(\"402\"))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Checks to see if a particular family member smokes\n\t * \n\t * @param member the family member to check\n\t * @return true if the family member smokes.  False if there are no records or the family member does not\n\t * @throws iTrustException\n\t */\t\n\tpublic boolean isFamilyMemberSmoker(FamilyMemberBean member) throws iTrustException {\n\t\tList<HealthRecord> records = hrDAO.getAllHealthRecords(member.getMid());\n\t\tif(records.size() == 0)\n\t\t\treturn false;\n\t\tfor(HealthRecord record : records) {\n\t\t\tif(record.isSmoker())\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\n\t/**\n\t * Checks to see if the family member is dead and returns their cause of death if so\n\t * \n\t * @param member the family member to check\n\t * @return the cause of death if there is one; otherwise null\n\t * @throws iTrustException\n\t */\n\tpublic String getFamilyMemberCOD(FamilyMemberBean member) throws iTrustException {\n\t\tPatientBean patient = patientDAO.getPatient(member.getMid());\n\t\tif(patient.getCauseOfDeath() == null)\n\t\t\treturn \"\";\n\t\tDiagnosisBean diag = icdDAO.getICDCode(patient.getCauseOfDeath());\n\t\tif(diag == null)\n\t\t\treturn \"\";\n\t\treturn diag.getDescription();\n\t}\n\t\n\t/**\n\t * Creates a fake e-mail to notify the user that their records have been altered.\n\t * \n\t * @return the e-mail to be sent\n\t * @throws DBException\n\t */\n\tprivate Email makeEmail() throws DBException{\n\n\t\tEmail email = new Email();\n\t\tList<PatientBean> reps = patientDAO.getRepresenting(patient.getMID());\n\t\t\n\t\tList<String> toAddrs = new ArrayList<String>();\n\t\ttoAddrs.add(patient.getEmail());\n\t\tfor (PatientBean r: reps) {\n\t\t\ttoAddrs.add(r.getEmail());\n\t\t}\n\t\t\n\t\temail.setFrom(\"no-reply@itrust.com\");\n    \temail.setToList(toAddrs); // patient and personal representative\n    \temail.setSubject(String.format(\"Your medical records have been altered\"));\n    \temail.setBody(\"Health care professional \"+ HCPUAP.getFullName() +\" has altered your medical records. \" +\n    \t\t\t\t\"She is not on your list of designated health care professionals.\");\n\t\treturn email;\n\t}\n}", "EditPrescriptionAction.java": "package edu.ncsu.csc.itrust.action;\n\n\nimport edu.ncsu.csc.itrust.beans.PrescriptionBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.OfficeVisitDAO;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\n\n\n/**\n * Edits a patient's prescription information.  Used by hcp-uap/editPrescription.jsp\n * @author Ben Smith\n */\npublic class EditPrescriptionAction {\n\n\tprivate OfficeVisitDAO ovDAO;\n\n\n\t/**\n\t * Creates a new action by initializing the office visit\n\t * database access object.\n\t * \n\t * @param factory\n\t * @throws iTrustException\n\t */\n\tpublic EditPrescriptionAction(DAOFactory factory) throws iTrustException {\n\t\tthis.ovDAO = factory.getOfficeVisitDAO();\n\n\t}\n\n\t/**\n\t * Edits an existing prescription in the database.\n\t * \n\t * @param pres The prescription bean that has been changed.\n\t * @throws DBException\n\t */\n\tpublic void editPrescription(PrescriptionBean pres) throws DBException {\n\t\t\n\t\tovDAO.editPrescription(pres);\n\t}\n}", "EditRepresentativesAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport java.util.List;\nimport edu.ncsu.csc.itrust.action.base.PatientBaseAction;\nimport edu.ncsu.csc.itrust.beans.PatientBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.AuthDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.PatientDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.Role;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\n\n/**\n * Edits a patient's personal representatives. Used by hcp/editRepresentatives.jsp\n * \n * @author laurenhayward\n * \n */\npublic class EditRepresentativesAction extends PatientBaseAction {\n\tprivate PatientDAO patientDAO;\n\tprivate TransactionDAO transDAO;\n\tprivate AuthDAO authDAO;\n\tprivate long loggedInMID;\n\n\t/**\n\t * Super class validates the patient mid\n\t * \n\t * @param factory The DAOFactory used in creating the DAOs for this action.\n\t * @param loggedInMID The MID of the patient editing his/her representatives.\n\t * @param pidString The MID of the representative in question.\n\t * @throws iTrustException\n\t */\n\tpublic EditRepresentativesAction(DAOFactory factory, long loggedInMID, String pidString)\n\t\t\tthrows iTrustException {\n\t\tsuper(factory, pidString);\n\t\tthis.loggedInMID = loggedInMID;\n\t\tthis.transDAO = factory.getTransactionDAO();\n\t\tthis.patientDAO = factory.getPatientDAO();\n\t\tthis.authDAO = factory.getAuthDAO();\n\t}\n\n\t/**\n\t * Return a list of patients that pid represents\n\t * \n\t * @param pid The id of the personnel we are looking up representees for.\n\t * @return a list of PatientBeans\n\t * @throws iTrustException\n\t */\n\tpublic List<PatientBean> getRepresented(long pid) throws iTrustException {\n\t\treturn patientDAO.getRepresented(pid);\n\t}\n\n\t/**\n\t * Makes the patient (pid) represent the input mid parameter\n\t * \n\t * @param pidString\n\t *            the mid of the person who will be represented (the representee)\n\t * @return a message\n\t * @throws iTrustException\n\t */\n\tpublic String addRepresentative(String pidString) throws iTrustException {\n\t\ttry {\n\t\t\tlong representee = Long.valueOf(pidString);\n\t\t\tif (authDAO.getUserRole(representee) != Role.PATIENT)\n\t\t\t\tthrow new iTrustException(\"This user is not a patient!\");\n\t\t\telse if (super.pid == representee)\n\t\t\t\tthrow new iTrustException(\"This user cannot represent themselves.\");\n\n\t\t\tboolean confirm = patientDAO.addRepresentative(pid, representee);\n\t\t\tif (confirm) {\n\t\t\t\ttransDAO.logTransaction(TransactionType.DECLARE_REPRESENTATIVE, loggedInMID, pid, \"patient \"\n\t\t\t\t\t\t+ pid + \" now represents patient \" + representee);\n\t\t\t\treturn \"Patient represented\";\n\t\t\t} else\n\t\t\t\treturn \"No change made\";\n\t\t} catch (NumberFormatException e) {\n\t\t\treturn \"MID not a number\";\n\t\t}\n\t}\n\n\t/**\n\t * Makes the patient (pid) no longer represent the input mid param\n\t * \n\t * @param input\n\t *            the mid of the person be represented (representee)\n\t * @return a message\n\t * @throws iTrustException\n\t */\n\tpublic String removeRepresentative(String input) throws iTrustException {\n\t\ttry {\n\t\t\tlong representee = Long.valueOf(input);\n\t\t\tboolean confirm = patientDAO.removeRepresentative(pid, representee);\n\t\t\tif (confirm) {\n\t\t\t\ttransDAO.logTransaction(TransactionType.DECLARE_REPRESENTATIVE, loggedInMID, pid, \"patient \"\n\t\t\t\t\t\t+ pid + \" no longer represents patient \" + representee);\n\t\t\t\treturn \"Patient represented\";\n\t\t\t} else\n\t\t\t\treturn \"No change made\";\n\t\t} catch (NumberFormatException e) {\n\t\t\treturn \"MID not a number\";\n\t\t}\n\t}\n}", "EmergencyReportAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Calendar;\nimport edu.ncsu.csc.itrust.action.base.PatientBaseAction;\nimport edu.ncsu.csc.itrust.beans.AllergyBean;\nimport edu.ncsu.csc.itrust.beans.DiagnosisBean;\nimport edu.ncsu.csc.itrust.beans.Email;\nimport edu.ncsu.csc.itrust.beans.PatientBean;\nimport edu.ncsu.csc.itrust.beans.PrescriptionBean;\nimport edu.ncsu.csc.itrust.beans.OfficeVisitBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.AllergyDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.PatientDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.OfficeVisitDAO;\nimport edu.ncsu.csc.itrust.enums.PrescriptionAlerts;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\nimport edu.ncsu.csc.itrust.EmailUtil;\nimport edu.ncsu.csc.itrust.beans.ProcedureBean;\n\n/**\n * Creates a new Emergency Report Used by emergencyReport.jsp\n * \n * @author laurenhayward\n * \n */\npublic class EmergencyReportAction extends PatientBaseAction {\n\tprivate TransactionDAO transDAO;\n\tprivate PatientDAO patientDAO;\n\tprivate AllergyDAO allergyDAO;\n\tprivate OfficeVisitDAO ovDAO;\n\tprivate PatientBean pb;\n\tprivate EmailUtil emailutil;\n\tprivate long loggedInMID;\n\n\t/**\n\t * The super class handles validating the pid Logs viewing of the report\n\t * \n\t * @param factory The DAOFactory used in creating the DAOs for this action.\n\t * @param loggedInMID The MID of the user who is looking at the emergency report.\n\t * @param pidString The ID of the patient whose report is being generated.\n\t * @throws iTrustException\n\t */\n\tpublic EmergencyReportAction(DAOFactory factory, long loggedInMID, String pidString) throws iTrustException {\n\t\tsuper(factory, pidString);\n\t\tthis.patientDAO = factory.getPatientDAO();\n\t\tthis.allergyDAO = factory.getAllergyDAO();\n\t\tthis.transDAO = factory.getTransactionDAO();\n\t\tthis.ovDAO = factory.getOfficeVisitDAO();\n\t\tthis.loggedInMID = loggedInMID;\n\t\temailutil = new EmailUtil(factory);\n\t\t\n\t\tpb = patientDAO.getPatient(this.pid);\n\t\ttransDAO.logTransaction(TransactionType.VIEW_EMERGENCY_REPORT, this.loggedInMID, Long.valueOf(pidString), \"viewed emergency report\");\n\t\temailutil.sendEmail(makeEmail());\n\t}\n\n\t/**\n\t * Returns the patient's name\n\t * \n\t * @return patient's full name\n\t */\n\tpublic String getPatientName() {\n\t\treturn (pb.getFirstName() + \" \" + pb.getLastName());\n\t}\n\n\t/**\n\t * Returns the patient's age\n\t * \n\t * @return patient's age\n\t */\n\tpublic String getPatientAge() {\n\t\treturn Integer.toString(pb.getAge());\n\t}\n\t\n\t/**\n\t * Returns the patient's gender\n\t * \n\t * @return patient's gender\n\t */\n\tpublic String getPatientGender() {\n\t\treturn pb.getGender().toString();\n\t}\n\t\n\t/**\n\t * Returns the patient's emergency contact\n\t * \n\t * @return patient's emergency contact\n\t */\n\tpublic String getPatientEmergencyContact() {\n\t\treturn pb.getEmergencyName() + \" \" + pb.getEmergencyPhone();\n\t}\n\t\n\t/**\n\t * Returns the patient's blood type\n\t * \n\t * @return the patient's blood type\n\t */\n\tpublic String getBloodType() {\n\t\treturn pb.getBloodType() + \"\";\n\t}\n\n\t/**\n\t * Returns a list of allergies for the given patient\n\t * \n\t * @return a list of AllergyBeans\n\t * @throws iTrustException\n\t */\n\tpublic List<AllergyBean> getAllergies() throws iTrustException {\n\t\treturn allergyDAO.getAllergies(this.pid);\n\t}\n\n\t/**\n\t * Returns a list of prescriptions the patient is currently taking\n\t * \n\t * @return a list of PrescriptionBeans for which the patient is currently taking\n\t * @throws iTrustException\n\t */\n\tpublic List<PrescriptionBean> getCurrentPrescriptions() throws iTrustException {\n\t\tList<PrescriptionBean> allPrescriptions = patientDAO.getCurrentPrescriptions(this.pid);\n\t\tArrayList<PrescriptionBean> warningList = new ArrayList<PrescriptionBean>();\n\t\tfor (int i = 0; i < allPrescriptions.size(); i++) {\n\t\t\tif (PrescriptionAlerts.isAlert(allPrescriptions.get(i).getMedication().getNDCode()))\n\t\t\t\twarningList.add(allPrescriptions.get(i));\n\t\t}\n\t\treturn warningList;\n\t}\n\n\t/**\n\t * Returns a list of diagnoses that are in the range indicated by the DiagnosisRange enum\n\t * \n\t * @return list of DiagnosisBeans\n\t * @throws iTrustException\n\t */\n\tpublic List<DiagnosisBean> getWarningDiagnoses() throws iTrustException {\n\t\ttry {\n\t\t\tboolean dup = false;\n\t\t\tList<DiagnosisBean> allDiagnoses = patientDAO.getDiagnoses(this.pid);\n\t\t\tArrayList<DiagnosisBean> warningList = new ArrayList<DiagnosisBean>();\n\t\t\tfor (DiagnosisBean bean: allDiagnoses) {\n\t\t\t\tOfficeVisitBean ovb = ovDAO.getOfficeVisit(bean.getVisitID());\n\n\t\t\t\tif(ovb == null){\n\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tif (\"yes\".equals(bean.getClassification()) || (ovb.getVisitDate().getTime() > Calendar.getInstance().getTimeInMillis() - 30 * 24 * 60 * 60 * 1000))  {\n\t\t\t\t\tfor (DiagnosisBean wbean: warningList) {\n\t\t\t\t\t\tif (bean.getDescription().equals(wbean.getDescription())) {\n\t\t\t\t\t\t\tdup = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!dup) {\n\t\t\t\t\t\twarningList.add(bean);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn warningList;\n\t\t} catch (DBException dbe) {\n\t\t\tthrow new iTrustException(dbe.getMessage());\n\t\t}\n\t}\n\n\t/**\n\t * Returns a list of prescriptions the patient is currently taking\n\t * \n\t * @return a list of PrescriptionBeans for which the patient is currently taking\n\t * @throws iTrustException\n\t */\n\tpublic List<ProcedureBean> getImmunizations() throws iTrustException {\n\t\tList<ProcedureBean> allImmunizations = patientDAO.getImmunizationProcedures(this.pid);\n\t\treturn allImmunizations;\n\t}\n\t\n\t/**\n\t * Creates a fake e-mail to notify the user that an emergency report has been created and viewed.\n\t * \n\t * @return the e-mail to be sent\n\t * @throws DBException\n\t */\n\tprivate Email makeEmail() throws DBException{\n\n\t\tEmail email = new Email();\n\t\tList<PatientBean> reps = patientDAO.getRepresenting(pb.getMID());\n\t\t\n\t\tList<String> toAddrs = new ArrayList<String>();\n\t\ttoAddrs.add(pb.getEmail());\n\t\tfor (PatientBean r: reps) {\n\t\t\ttoAddrs.add(r.getEmail());\n\t\t}\n\t\t\n\t\temail.setFrom(\"no-reply@itrust.com\");\n    \temail.setToList(toAddrs); // patient and personal representative\n    \temail.setSubject(String.format(\"Emergency Report Viewed Notification\"));\n    \temail.setBody(\"Dear \" + pb.getFullName() + \",\\n An emergency report has been generated. \" + \n    \t\t\t\"Please login to iTrust to see who has viewed your records.\");\n\t\treturn email;\n\t}\n}", "GenerateCalendarAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\nimport edu.ncsu.csc.itrust.action.EditApptTypeAction;\nimport edu.ncsu.csc.itrust.action.ViewMyApptsAction;\nimport edu.ncsu.csc.itrust.action.ViewMyRecordsAction;\nimport edu.ncsu.csc.itrust.beans.ApptBean;\nimport edu.ncsu.csc.itrust.beans.OfficeVisitBean;\nimport edu.ncsu.csc.itrust.beans.LabProcedureBean;\nimport java.util.List;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Hashtable;\nimport java.util.Calendar;\n\n/**\n * Action class for calendar.jsp\n * @author Software Engineering Team 13, 2010 \"Project Zephyr\"\n *\n */\npublic class GenerateCalendarAction {\n\tprivate ViewMyApptsAction a_action;\n\tprivate EditApptTypeAction types;\n\tprivate ViewMyRecordsAction r_action;\n\tprivate List<ApptBean> send;\n\t\n\t/**\n\t * Set up defaults\n\t * \n\t * @param factory The DAOFactory used to create the DAOs used in this action.\n\t * @param loggedInMID The MID of the user who is viewing the calendar\n\t */\n\tpublic GenerateCalendarAction(DAOFactory factory, long loggedInMID) {\n\t\ta_action = new ViewMyApptsAction(factory, loggedInMID);\n\t\ttypes = new EditApptTypeAction(factory, loggedInMID);\n\t\tr_action = new ViewMyRecordsAction(factory, loggedInMID);\n\t\tsend = new ArrayList<ApptBean>();\n\t}\n\t\n\t/**\n\t * Return the send request for an AppointmentBean\n\t * @return the send request for an AppointmentBean\n\t */\n\tpublic List<ApptBean> getSend() {\n\t\treturn send;\n\t}\n\t\n\t/**\n\t * Check appointments appearing on the calendar for conflicts \n\t * with other appointments on the calendar. \n\t * \n\t * The array from this method is used to determine what appointments\n\t * will appear in bold on the calendar.\n\t * \n\t * @return An array of items that are in conflict with other items.\n\t * @throws SQLException\n\t */\n\tpublic boolean[] getConflicts() throws SQLException {\n\t\tboolean conflicts[] = new boolean[send.size()];\n\t\tfor(int i=0; i<send.size(); i++) {\n\t\t\tApptBean ab = send.get(i);\n\t\t\tlong t = ab.getDate().getTime();\n\t\t\tlong m = types.getDurationByType(ab.getApptType()) * 60L * 1000L;\n\t\t\tTimestamp time = new Timestamp(t+m);\n\t\t\tfor(int j=i+1; j<send.size(); j++) {\n\t\t\t\tif(send.get(j).getDate().before(time)) {\n\t\t\t\t\tconflicts[i] = true;\n\t\t\t\t\tconflicts[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn conflicts;\n\t}\n\t\n\t/**\n\t * Creates a hash table with all of the Appointments to be \n\t * displayed on the calendar for the month and year being viewed.\n\t * \n\t * @param thisMonth The month of the calendar to be rendered\n\t * @param thisYear The year of the calendar to be rendered\n\t * @return A Hashtable containing the AppointmentBeans to be rendered\n\t * @throws SQLException\n\t */\n\tpublic Hashtable<Integer, ArrayList<ApptBean>> getApptsTable(int thisMonth, int thisYear) throws SQLException {\n\t\tList<ApptBean> appts = a_action.getMyAppointments();\n\t\tHashtable<Integer, ArrayList<ApptBean>> atable = new Hashtable<Integer, ArrayList<ApptBean>>();\n\t\tCalendar a = Calendar.getInstance();\n\t\tfor(ApptBean b : appts) {\n\t\t\ta.setTimeInMillis(b.getDate().getTime());\n\t\t\tif(a.get(Calendar.MONTH) == thisMonth && a.get(Calendar.YEAR) == thisYear) {\n\t\t\t\tif(!atable.containsKey(a.get(Calendar.DAY_OF_MONTH)))\n\t\t\t\t\tatable.put(a.get(Calendar.DAY_OF_MONTH), new ArrayList<ApptBean>());\n\t\t\t\tArrayList<ApptBean> l = atable.get(a.get(Calendar.DAY_OF_MONTH));\n\t\t\t\tl.add(b);\n\t\t\t\tsend.add(b);\n\t\t\t\tatable.put(a.get(Calendar.DAY_OF_MONTH), l);\n\t\t\t}\n\t\t}\n\t\treturn atable;\n\t}\n\t\n\t/**\n\t * Creates a hash table with all of the Office Visits to be \n\t * displayed on the calendar for the month and year being viewed.\n\t * \n\t * @param thisMonth The month of the calendar to be rendered\n\t * @param thisYear The year of the calendar to be rendered\n\t * @return A Hashtable containing the OfficeVisitBeans to be rendered\n\t * @throws SQLException\n\t */\n\tpublic Hashtable<Integer, ArrayList<OfficeVisitBean>> getOfficeVisitsTable(int thisMonth, int thisYear) throws iTrustException {\n\t\tList<OfficeVisitBean> officeVisits = r_action.getAllOfficeVisits();\n\t\tHashtable<Integer, ArrayList<OfficeVisitBean>> rtable = new Hashtable<Integer, ArrayList<OfficeVisitBean>>();\n\t\tCalendar a = Calendar.getInstance();\n\t\tfor(OfficeVisitBean b : officeVisits) {\n\t\t\ta.setTimeInMillis(b.getVisitDate().getTime());\n\t\t\tif(a.get(Calendar.MONTH) == thisMonth && a.get(Calendar.YEAR) == thisYear) {\n\t\t\t\tif(!rtable.containsKey(a.get(Calendar.DAY_OF_MONTH)))\n\t\t\t\t\trtable.put(a.get(Calendar.DAY_OF_MONTH), new ArrayList<OfficeVisitBean>());\n\t\t\t\tArrayList<OfficeVisitBean> l = rtable.get(a.get(Calendar.DAY_OF_MONTH));\n\t\t\t\tl.add(b);\n\t\t\t\trtable.put(a.get(Calendar.DAY_OF_MONTH), l);\n\t\t\t}\n\t\t}\n\t\treturn rtable;\n\t}\n\t\n\t/**\n\t * Creates a hash table with all of the lab procedures to be \n\t * displayed on the calendar for the month and year being viewed.\n\t * \n\t * @param thisMonth The month of the calendar to be rendered\n\t * @param thisYear The year of the calendar to be rendered\n\t * @return A Hashtable containing the LabProcedureBeans to be rendered\n\t * @throws SQLException\n\t */\n\tpublic Hashtable<Integer, ArrayList<LabProcedureBean>> getLabProceduresTable(int thisMonth, int thisYear) throws iTrustException {\n\t\tList<LabProcedureBean> procs = r_action.getLabs();\n\t\tHashtable<Integer, ArrayList<LabProcedureBean>> ptable = new Hashtable<Integer, ArrayList<LabProcedureBean>>();\n\t\tCalendar a = Calendar.getInstance();\n\t\tfor(LabProcedureBean b : procs) {\n\t\t\ta.setTimeInMillis(b.getTimestamp().getTime());\n\t\t\tif(a.get(Calendar.MONTH) == thisMonth && a.get(Calendar.YEAR) == thisYear) {\n\t\t\t\tif(!ptable.containsKey(a.get(Calendar.DAY_OF_MONTH)))\n\t\t\t\t\tptable.put(a.get(Calendar.DAY_OF_MONTH), new ArrayList<LabProcedureBean>());\n\t\t\t\tArrayList<LabProcedureBean> l = ptable.get(a.get(Calendar.DAY_OF_MONTH));\n\t\t\t\tl.add(b);\n\t\t\t\tptable.put(a.get(Calendar.DAY_OF_MONTH), l);\n\t\t\t}\n\t\t}\n\t\treturn ptable;\n\t}\n}", "GetUserNameAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\n\n/**\n * Handles Getting the person's name associated with a certain mid Used by getUser.jsp\n * \n * @author laurenhayward\n * \n */\npublic class GetUserNameAction {\n\tprivate DAOFactory factory;\n\n\t/**\n\t * Set up defaults\n\t * \n\t * @param factory The DAOFactory used for creating the DAOs for this action.\n\t */\n\tpublic GetUserNameAction(DAOFactory factory) {\n\t\tthis.factory = factory;\n\t}\n\n\t/**\n\t * Returns the person's name that matches the inputMID param\n\t * \n\t * @param inputMID The MID to look up.\n\t * @return the person's name\n\t * @throws DBException\n\t * @throws iTrustException\n\t */\n\tpublic String getUserName(String inputMID) throws iTrustException {\n\t\ttry {\n\t\t\tlong mid = Long.valueOf(inputMID);\n\t\t\treturn factory.getAuthDAO().getUserName(mid);\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new iTrustException(\"MID not in correct form\");\n\t\t}\n\t}\n}", "GetVisitRemindersAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Calendar;\nimport edu.ncsu.csc.itrust.beans.forms.VisitReminderReturnForm;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.VisitRemindersDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.PatientDAO;\nimport edu.ncsu.csc.itrust.beans.ProcedureBean;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\nimport edu.ncsu.csc.itrust.beans.VisitFlag;\nimport edu.ncsu.csc.itrust.beans.PatientBean;\nimport edu.ncsu.csc.itrust.enums.Gender;\n\n/**\n * Gets the VisitReminders for a given patient Used by visitReminders.jsp\n * \n * @author laurenhayward\n * \n */\npublic class GetVisitRemindersAction {\n\n\t/**\n\t * Reminder Type enumeration.\n\t */\n\tpublic static enum ReminderType {\n\t\tDIAGNOSED_CARE_NEEDERS(\"Diagnosed Care Needers\"),\n\t\tFLU_SHOT_NEEDERS(\"Flu Shot Needers\"),\n\t\tIMMUNIZATION_NEEDERS(\"Immunization Needers\");\n\n\t\tprivate String typeName;\n\n\t\tprivate ReminderType(String typeName) {\n\t\t\tthis.typeName = typeName;\n\t\t}\n\n\t\tprivate static final HashMap<String, ReminderType> map = new HashMap<String, ReminderType>();\n\t\tstatic {\n\t\t\tfor (ReminderType rt : ReminderType.values()) {\n\t\t\t\tmap.put(rt.getTypeName(), rt);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Gets the ReminderType for the name passed as a param\n\t\t * \n\t\t * @param name\n\t\t * @return the ReminderType associated with the name\n\t\t */\n\t\tpublic static ReminderType getReminderType(String name) {\n\t\t\treturn map.get(name);\n\t\t}\n\n\t\t/**\n\t\t * Returns the type name as a string\n\t\t * \n\t\t * @return\n\t\t */\n\t\tpublic String getTypeName() {\n\t\t\treturn typeName;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * Begin GetVisitRemindersAction code\n\t * \n\t */\n\tprivate TransactionDAO transDAO;\n\tprivate VisitRemindersDAO visitReminderDAO;\n\tprivate PatientDAO patientDAO;\n\tprivate long loggedInMID;\n\n\t/**\n\t * Set up defaults\n\t * \n\t * @param factory The DAOFactory used to create the DAOs used in this action.\n\t * @param loggedInMID MID of the person who is logged in\n\t * @throws iTrustException\n\t */\n\tpublic GetVisitRemindersAction(DAOFactory factory, long loggedInMID) throws iTrustException {\n\t\tthis.transDAO = factory.getTransactionDAO();\n\t\tthis.loggedInMID = loggedInMID;\n\t\tvisitReminderDAO = factory.getVisitRemindersDAO();\n\t\tpatientDAO = factory.getPatientDAO();\n\t}\n\n\t/**\n\t * Returns a list of VisitReminderReturnForms for the type passed in as a param\n\t * \n\t * @param type\n\t *            the ReminderType\n\t * @return the list of VisitReminderReturnForms\n\t * @throws iTrustException\n\t * @throws FormValidationException\n\t */\n\tpublic List<VisitReminderReturnForm> getVisitReminders(ReminderType type) throws iTrustException, FormValidationException {\n\t\t\n\t\tif (null == type)\n\t\t\tthrow new iTrustException(\"Reminder Type DNE\");\n\t\t\n\t\ttransDAO.logTransaction(TransactionType.PATIENT_REMINDERS, loggedInMID, 0l, type.getTypeName());\n\t\tswitch (type) {\n\t\t\tcase DIAGNOSED_CARE_NEEDERS:\n\t\t\t\treturn stripDupes(visitReminderDAO.getDiagnosedVisitNeeders(loggedInMID));\n\n\t\t\tcase FLU_SHOT_NEEDERS:\n\t\t\t\treturn visitReminderDAO.getFluShotDelinquents(loggedInMID);\n\t\t\t\t\n\t\t\tcase IMMUNIZATION_NEEDERS:\n\t\t\t\treturn getImmunizationNeeders(loggedInMID);\n\t\t\t\t\n\t\t\tdefault:\n\t\t\t\tthrow new iTrustException(\"Reminder Type DNE\");\n\t\t}\n\t}\n\t\n\t/**\n\t * Gets a list of anyone who need immunizations\n\t * \n\t * @param mid the HCP whose patients are being checked\n\t * @return a list of all the people who need immunizations--done in a visit reminder\n\t * @throws iTrustException\n\t */\n\n\tprivate List<VisitReminderReturnForm> getImmunizationNeeders(long mid) throws iTrustException {\n\t\t\n\t\tList<VisitReminderReturnForm> formList;\n\t\tList<VisitReminderReturnForm> needList = new ArrayList<VisitReminderReturnForm>();\n\t\tString reason = \"\";\n\t\t// Get list of patients that designate this HCP\n\t\tformList = visitReminderDAO.getPatients(mid);\n\t\t\n\t\tfor (VisitReminderReturnForm r : formList) {\n\t\t\treason = checkImmunizations(r.getPatientID());\n\t\t\tif (0 < reason.length()) {\n\t\t\t\tneedList.add(r);\n\t\t\t\tr.addVisitFlag(new VisitFlag(VisitFlag.IMMUNIZATION, reason));\n\t\t\t}\n\t\t}\t\n\t\t\n\t\treturn needList;\n\t}\n\t\n\t\n\n\t/**\n\t * Checks a patient to see what immunizations they need\n\t * \n\t * @param pid patient to be checked\n\t * @return patient list of those lacking immunizations according to the schedule\n\t */\n\tprivate String checkImmunizations(long pid) throws iTrustException {\n\t\t\n\t\tString reason = \"\";\n\t\tList<ProcedureBean> procs = patientDAO.getProcedures(pid);\n\t\tPatientBean patient = patientDAO.getPatient(pid);\n\t\tlong patientAge = patient.getAgeInWeeks();\n\t\tGender gen = patient.getGender();\n\t\t\n\t\tint hepB = 0;\n\t\tlong hepBTime = 0;\n\n\t\tint rota = 0;\n\t\tlong rotaTime = 0;\n\n\t\tint diptet = 0;\n\t\tlong deptetTime = 0;\n\t\t\n\t\tint haemoflu = 0;\n\t\tlong haemofluTime = 0;\n\t\tlong haemofluTimeFirst = 0;\n\t\t\n\t\tint pneumo = 0;\n\t\tlong pneumoTime = 0;\n\t\tlong pneumofluTimeFirst = 0;\n\t\t\n\t\tint polio = 0;\n\t\tlong polioTime = 0;\n\t\t\n\t\tint measles = 0;\n\t\tlong measlesTime = 0;\n\t\t\n\t\tint varicella = 0;\n\t\tlong varicellaTime = 0;\n\t\t\n\t\tint hepA = 0;\n\t\tlong hepATime = 0;\n\t\t\n\t\tint hpv = 0;\n\t\tlong hpvTime = 0;\n\t\t\n\t\tfor (ProcedureBean proc: procs) {\n\t\t\n\t\t\tString cpt = proc.getCPTCode();\n\t\t\t\n\t\t\t// Hep B (90371)\n\t\t\tif (cpt.equals(\"90371\")) {\n\t\t\t\thepB++;\n\t\t\t\thepBTime = proc.getDate().getTime();\n\t\t\t}\n\t\t\t\t\n\t\t\t// Rotavirus (90681)\n\t\t\telse if (cpt.equals(\"90681\")) {\n\t\t\t\trota++;\n\t\t\t\trotaTime = proc.getDate().getTime();\n\t\t\t}\n\t\t\t\n\t\t\t// Diptheria, Tetanus, Pertussis (90696)\n\t\t\telse if (cpt.equals(\"90696\")) {\n\t\t\t\tdiptet++;\n\t\t\t\tdeptetTime = proc.getDate().getTime();\n\t\t\t}\n\t\t\t\n\t\t\t// Haemophilus influenza (90645)\n\t\t\telse if (cpt.equals(\"90645\")) {\n\t\t\t\tif (0 == haemoflu)\n\t\t\t\t\thaemofluTimeFirst = proc.getDate().getTime();\n\t\t\t\t\n\t\t\t\thaemoflu++;\n\t\t\t\thaemofluTime = proc.getDate().getTime();\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// Pneumococcal (90669)\n\t\t\telse if (cpt.equals(\"90669\")) {\n\t\t\t\tif (0 == pneumo)\n\t\t\t\t\tpneumofluTimeFirst = proc.getDate().getTime();\n\t\t\t\tpneumo++;\n\t\t\t\tpneumoTime = proc.getDate().getTime();\n\t\t\t}\n\t\t\t\n\t\t\t// Poliovirus (90712)\n\t\t\telse if (cpt.equals(\"90712\")) {\n\t\t\t\tpolio++;\n\t\t\t\tpolioTime = proc.getDate().getTime();\n\t\t\t}\n\t\t\t\n\t\t\t// Measles, Mumps, Rubella (90707)\n\t\t\telse if (cpt.equals(\"90707\")) {\n\t\t\t\tmeasles++;\n\t\t\t\tmeaslesTime = proc.getDate().getTime();\n\t\t\t}\n\t\t\t\n\t\t\t// Varicella (90396)\n\t\t\telse if (cpt.equals(\"90396\")) {\n\t\t\t\tvaricella++;\n\t\t\t\tvaricellaTime = proc.getDate().getTime();\n\t\t\t}\n\t\t\t\n\t\t\t// Hep A (90633)\n\t\t\telse if (cpt.equals(\"90633\")) {\n\t\t\t\thepA++;\n\t\t\t\thepATime = proc.getDate().getTime();\n\t\t\t}\n\t\t\t\n\t\t\t// Human Papillomaavirus (90649)\n\t\t\telse if (cpt.equals(\"90649\")) {\n\t\t\t\thpv++;\n\t\t\t\thpvTime = proc.getDate().getTime();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (3 > hepB) {\n\t\t\treason += testHepB(hepB, patientAge, hepBTime);\n\t\t}\n\t\t\n\t\tif (3 > rota) {\n\t\t\treason += testRotaVirus(rota, patientAge, rotaTime);\n\t\t}\n\t\t\n\t\tif (6 > diptet) {\n\t\t\treason += testDipTet(diptet, patientAge, deptetTime);\n\t\t}\n\t\t\n\t\tif (3 > haemoflu) {\n\t\t\treason += testHaemoFlu(haemoflu, patientAge, haemofluTime, haemofluTimeFirst);\n\t\t}\n\t\t\n\t\tif (4 > pneumo) {\n\t\t\treason += testPneumo(pneumo, patientAge, pneumoTime, pneumofluTimeFirst);\n\t\t}\n\t\t\n\t\tif (3 > polio) {\n\t\t\treason += testPolio(polio, patientAge, polioTime);\n\t\t}\n\t\t\n\t\tif (2 > measles) {\n\t\t\treason += testMeasles(measles, patientAge, measlesTime);\n\t\t}\n\t\t\n\t\tif (2 > varicella) {\n\t\t\treason += testVaricella(varicella, patientAge, varicellaTime);\n\t\t}\n\t\t\n\t\tif (2 > hepA) {\n\t\t\treason += testHepA(hepA, patientAge, hepATime);\n\t\t}\n\t\t\n\t\tif (3 > hpv && gen.getName().equals(\"Female\")) {\n\t\t\treason += testHPV(hpv, patientAge, hpvTime);\n\t\t}\n\t\n\t\treturn reason;\n\t}\n\t\n\t\n\t/**\n\t * Checks to see if a patient needs the HPV immunization\n\t * \n\t * @param count which immunization they are on\n\t * @param patientAge how old the patient is\n\t * @param time what the date is\n\t * @return when the immunization should be given\n\t */\n\tpublic static String testHPV(int count, long patientAge, long time) {\n\t\n\t\tString reason = \"\";\n\t\tlong weeks = (Calendar.getInstance().getTimeInMillis() - time) / (1000 * 60 * 60 * 24 * 7);\n\t\t\n\t\tif (0 == count) {\n\t\t\tif (468 <= patientAge)\n\t\t\t\treason += \"90649 Human Papillomavirus (9 years) \";\n\t\t}\n\t\telse if (1 == count) {\n\t\t\tif (476 <= patientAge && 8 <= weeks)\n\t\t\t\treason += \"90649 Human Papillomavirus (9 years, 2 months) \";\n\t\t}\n\t\telse if (2 == count) {\n\t\t\tif (494 <= patientAge && 16 <= weeks)\n\t\t\t\treason += \"90649 Human Papillomavirus (9 years, 6 months) \";\n\t\t}\n\t\t\n\t\treturn reason;\n\t}\n\t\n\t/**\n\t * Checks to see if a patient needs the Hepatits A immunization\n\t * \n\t * @param count which immunization they are on\n\t * @param patientAge how old the patient is\n\t * @param time what the current date is\n\t * @return when the immunization should be given\n\t */\n\tpublic static String testHepA(int count, long patientAge, long time) {\n\t\t\n\t\tString reason = \"\";\n\t\tlong weeks = (Calendar.getInstance().getTimeInMillis() - time) / (1000 * 60 * 60 * 24 * 7);\n\t\t\n\t\tif (0 == count) {\n\t\t\tif (52 <= patientAge)\n\t\t\t\treason += \"90633 Hepatits A (12 months) \";\n\t\t}\n\t\telse if (1 == count) {\n\t\t\tif (78 <= patientAge && 26 <= weeks)\n\t\t\t\treason += \"90633 Hepatits A (18 months) \";\n\t\t}\n\t\t\n\t\treturn reason;\t\n\t}\n\t\n\t/**\n\t * Checks to see if a patient needs the Varicella immunization\n\t * \n\t * @param count which immunization they are on\n\t * @param patientAge how old the patient is\n\t * @param time what the current date is\n\t * @return when the immunization should be given\n\t */\n\tpublic static String testVaricella(int count, long patientAge, long time) {\n\t\t\n\t\tString reason = \"\";\n\t\tlong weeks = (Calendar.getInstance().getTimeInMillis() - time) / (1000 * 60 * 60 * 24 * 7);\n\t\t\n\t\tif (0 == count) {\n\t\t\tif (52 <= patientAge)\n\t\t\t\treason += \"90396 Varicella (12 months) \";\n\t\t}\n\t\telse if (1 == count) {\n\t\t\tif (208 <= patientAge && 12 <= weeks)\n\t\t\t\treason += \"90396 Varicella (4 years) \";\n\t\t}\n\t\t\n\t\treturn reason;\n\t}\n\t\n\t/**\n\t * Checks to see if a patient needs the Measles, Mumps, and Rubekka immunization\n\t * \n\t * @param count which immunization they are on\n\t * @param patientAge how old the patient is\n\t * @param time what the current date is\n\t * @return when the immunization should be given\n\t */\n\tpublic static String testMeasles(int count, long patientAge, long time) {\n\t\t\n\t\tString reason = \"\";\n\t\tlong weeks = (Calendar.getInstance().getTimeInMillis() - time) / (1000 * 60 * 60 * 24 * 7);\n\t\t\n\t\tif (0 == count) {\n\t\t\tif (52 <= patientAge)\n\t\t\t\treason += \"90707 Measles, Mumps, Rubekka (12 months) \";\n\t\t}\n\t\telse if (1 == count) {\n\t\t\tif (208 <= patientAge && 12 <= weeks)\n\t\t\t\treason += \"90707 Measles, Mumps, Rubekka (4 years) \";\n\t\t}\n\t\t\n\t\treturn reason;\n\t}\n\t\n\t/**\n\t * Checks to see if a patient needs the Polio immunization\n\t * \n\t * @param count which immunization they are on\n\t * @param patientAge how old the patient is\n\t * @param time what the current date is\n\t * @return when the immunization should be given\n\t */\n\tpublic static String testPolio(int count, long patientAge, long time) {\n\t\t\n\t\tString reason = \"\";\n\t\tlong weeks = (Calendar.getInstance().getTimeInMillis() - time) / (1000 * 60 * 60 * 24 * 7);\n\t\t\n\t\tif (0 == count) {\n\t\t\tif (6 <= patientAge)\n\t\t\t\treason += \"90712 Poliovirus (6 weeks) \";\n\t\t}\n\t\telse if (1 == count) {\n\t\t\tif (16 <= patientAge && 4 <= weeks)\n\t\t\t\treason += \"90712 Poliovirus (4 months) \";\n\t\t}\n\t\telse if (2 == count) {\n\t\t\tif (26 <= patientAge)\n\t\t\t\treason += \"90712 Poliovirus (6 months) \";\t\t\t\t\n\t\t}\n\t\t\n\t\treturn reason;\t\n\t}\n\t\n\t/**\n\t * Checks to see if a patient needs the Pneumococcal immunization\n\t * \n\t * @param count which immunization they are on\n\t * @param patientAge how old the patient is\n\t * @param time what the current date is\n\t * @return when the immunization should be given\n\t */\n\tpublic static String testPneumo(int count, long patientAge, long time, long firstDoseTime) {\n\t\t\n\t\tString reason = \"\";\n\t\tlong weeks = (Calendar.getInstance().getTimeInMillis() - time) / (1000 * 60 * 60 * 24 * 7);\n\t\tlong ageFirst = patientAge - (firstDoseTime / (1000 * 60 * 60 * 24 * 7)); \n\t\t\n\t\tif (0 == count) {\n\t\t\tif (6 <= patientAge)\n\t\t\t\treason += \"90669 Pneumococcal (6 weeks) \";\n\t\t}\n\t\telse if (1 == count) {\n\t\t\tif (16 <= patientAge && 52 > ageFirst && 4 <= weeks)\n\t\t\t\treason += \"90669 Pneumococcal (4 months) \";\n\t\t\telse if (16 <= patientAge && 52 <= ageFirst && 60 >= ageFirst && 8 <= weeks)\n\t\t\t\treason += \"90669 Pneumococcal (4 months) \";\n\t\t}\n\t\telse if (2 == count) {\n\t\t\tif (26 <= patientAge && 4 <= weeks && 52 >= ageFirst)\n\t\t\t\treason += \"90669 Pneumococcal (6 months) \";\t\t\t\t\n\t\t}\n\t\telse if (3 == count) {\n\t\t\tif (52 <= patientAge && 8 <= weeks && 52 >= ageFirst)\n\t\t\t\treason += \"90669 Pneumococcal (12 months) \";\t\t\t\t\n\t\t}\n\t\treturn reason;\n\t}\n\t\n\t/**\n\t * Checks to see if a patient needs the Haemophilus Infulenzae immunization\n\t * \n\t * @param count which immunization they are on\n\t * @param patientAge how old the patient is\n\t * @param time what the current date is\n\t * @return when the immunization should be given\n\t */\n\tpublic static String testHaemoFlu(int count, long patientAge, long time, long firstDoseTime) {\n\t\t\n\t\tString reason = \"\";\n\t\tlong weeks = (Calendar.getInstance().getTimeInMillis() - time) / (1000 * 60 * 60 * 24 * 7);\n\t\tlong ageFirst = patientAge - (firstDoseTime / (1000 * 60 * 60 * 24 * 7)); \n\t\t\t\n\t\tif (0 == count) {\n\t\t\tif (6 <= patientAge)\n\t\t\t\treason += \"90645 Haemophilus influenzae (6 weeks) \";\n\t\t}\n\t\telse if (1 == count) {\n\t\t\tif (16 <= patientAge && 52 > ageFirst && 4 <= weeks)\n\t\t\t\treason += \"90645 Haemophilus influenzae (4 months) \";\n\t\t\telse if (16 <= patientAge && 52 <= ageFirst && 60 >= ageFirst && 8 <= weeks)\n\t\t\t\treason += \"90645 Haemophilus influenzae (4 months) \";\n\t\t}\n\t\telse if (2 == count) {\n\t\t\tif (26 <= patientAge && 4 <= weeks && 52 > ageFirst)\n\t\t\t\treason += \"90645 Haemophilus influenzae (6 months) \";\n\t\t}\n\t\t\n\t\treturn reason;\n\t}\n\t\n\t/**\n\t * Checks to see if a patient needs the Diphtheria, Tetanus, Pertussis immunization\n\t * \n\t * @param count which immunization they are on\n\t * @param patientAge how old the patient is\n\t * @param time what the current date is\n\t * @return when the immunization should be given\n\t */\n\tpublic static String testDipTet(int count, long patientAge, long time) {\n\t\t\n\t\tString reason = \"\";\n\t\tlong weeks = (Calendar.getInstance().getTimeInMillis() - time) / (1000 * 60 * 60 * 24 * 7);\n\t\t\n\t\tif (0 == count) {\n\t\t\tif (6 <= patientAge)\n\t\t\t\treason += \"90696 Diphtheria, Tetanus, Pertussis (6 weeks) \";\n\t\t}\n\t\telse if (1 == count) {\n\t\t\tif (16 <= patientAge && 4 <= weeks )\n\t\t\t\treason += \"90696 Diphtheria, Tetanus, Pertussis (4 months) \";\n\t\t}\n\t\telse if (2 == count) {\n\t\t\tif (26 <= patientAge && 4 <= weeks)\n\t\t\t\treason += \"90696 Diphtheria, Tetanus, Pertussis (6 months) \";\t\t\t\t\n\t\t}\n\t\telse if (3 == count) {\n\t\t\tif (15 <= patientAge && 26 <= weeks)\n\t\t\t\treason += \"90696 Diphtheria, Tetanus, Pertussis (15 weeks) \";\n\t\t}\n\t\telse if (4 == count) {\n\t\t\tif (208 <= patientAge && 26 <= weeks)\n\t\t\t\treason += \"90696 Diphtheria, Tetanus, Pertussis (4 years) \";\n\t\t}\n\t\telse if (5 == count) {\n\t\t\tif (572 <= patientAge && 260 <= weeks)\n\t\t\t\treason += \"90696 Diphtheria, Tetanus, Pertussis (11 years) \";\t\t\t\t\n\t\t}\n\t\t\n\t\treturn reason;\n\t}\n\t\n\t/**\n\t * Checks to see if a patient needs the Rotavirus immunization\n\t * \n\t * @param count which immunization they are on\n\t * @param patientAge how old the patient is\n\t * @param time what the current date is\n\t * @return when the immunization should be given\n\t */\n\t\n\tpublic static String testRotaVirus(int count, long patientAge, long time) {\n\t\n\t\tString reason = \"\";\n\t\tlong weeks = (Calendar.getInstance().getTimeInMillis() - time) / (1000 * 60 * 60 * 24 * 7);\n\t\t\n\t\tif (0 == count) {\n\t\t\tif (6 <= patientAge)\n\t\t\t\treason += \"90681 Rotavirus (6 weeks) \";\n\t\t}\n\t\telse if (1 == count) {\n\t\t\tif (16 <= patientAge && 4 <= weeks)\n\t\t\t\treason += \"90681 Rotavirus (4 months) \";\n\t\t}\n\t\telse if (2 == count) {\n\t\t\tif (26 <= patientAge && 4 <= weeks )\n\t\t\t\treason += \"90681 Rotavirus (6 months) \";\t\t\t\t\n\t\t}\n\t\t\n\t\treturn reason;\n\t}\n\n\t\n\t/**\n\t * Checks to see if a patient needs the Hepatitis B immunization\n\t * \n\t * @param count which immunization they are on\n\t * @param patientAge how old the patient is\n\t * @param time what the current date is\n\t * @return when the immunization should be given\n\t */\n\tpublic static String testHepB(int count, long patientAge, long time) {\n\t\t\n\t\tString reason = \"\";\n\t\tlong weeks = (Calendar.getInstance().getTimeInMillis() - time) / (1000 * 60 * 60 * 24 * 7);\n\t\t\n\t\tif (0 == count) {\n\t\t\tif (0 < patientAge)\n\t\t\t\treason += \"90371 Hepatitis B (birth) \";\n\t\t}\n\t\telse if (1 == count) {\n\t\t\tif (4 <= patientAge && 4 <= weeks)\n\t\t\t\treason += \"90371 Hepatitis B (1 month) \";\n\t\t}\n\t\telse if (2 == count) {\n\t\t\tif (26 <= patientAge && 8 <= weeks)\n\t\t\t\treason += \"90371 Hepatitis B (6 months) \";\t\t\t\t\n\t\t}\n\t\t\n\t\treturn reason;\n\t}\n\t\n\t\n\t/**\n\t * Removes duplicates from a list of VisitReminderReturnForms\n\t * \n\t * @param patients list of visit remindersto be cleaned up\n\t * @return cleaned up list of visit reminders\n\t */\n\tprivate List<VisitReminderReturnForm> stripDupes(List<VisitReminderReturnForm> patients) {\n\t\tif (null == patients)\n\t\t\treturn null;\n\t\tif (0 == patients.size())\n\t\t\treturn patients;\n\t\tList<VisitReminderReturnForm> retPatients = new ArrayList<VisitReminderReturnForm>();\n\t\tVisitReminderReturnForm temp = patients.get(0);\n\t\tretPatients.add(temp);\n\t\tfor (VisitReminderReturnForm vr : patients) {\n\t\t\tif (vr.getPatientID() != temp.getPatientID())\n\t\t\t\tretPatients.add(vr);\n\t\t\ttemp = vr;\n\t\t}\n\t\treturn retPatients;\n\t}\n}", "LabProcHCPAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport java.util.List;\nimport java.util.ArrayList;\nimport edu.ncsu.csc.itrust.beans.LabProcedureBean;\nimport edu.ncsu.csc.itrust.beans.OfficeVisitBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.LabProcedureDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.OfficeVisitDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\nimport edu.ncsu.csc.itrust.validate.LabProcedureValidator;\n\n/**\n * Action class for LabProcHCP.jsp.\n * \n * @extends LabProcUAPAction\n */\npublic class LabProcHCPAction extends LabProcUAPAction {\n\tprivate TransactionDAO transDAO;\n\tprivate LabProcedureDAO lpDAO;\n\tprivate OfficeVisitDAO ovDAO;\n\tlong loggedInMID;\n\tprivate LabProcedureValidator validator;\n\n\t\n\t/**\n\t * Sets up defaults\n\t * \n\t * @param factory The DAOFactory used to create the DAOs used in this action.\n\t * @param loggedInMID  MID for the logged in HCP\n\t */\n\t\n\tpublic LabProcHCPAction(DAOFactory factory, long loggedInMID) {\n\t\tsuper(factory, loggedInMID);\n\t\ttransDAO = factory.getTransactionDAO();\n\t\tlpDAO = factory.getLabProcedureDAO();\n\t\tovDAO = factory.getOfficeVisitDAO();\n\t\tthis.loggedInMID = loggedInMID;\n\t\tvalidator = new LabProcedureValidator();\n\n\t}\n\n\t/**\n\t * This method sorts by LOINC and returns the list\n\t * \n\t * @param id the ID to sort the list by\n\t * @return List sorted by LOINC\n\t */\n\tpublic List<LabProcedureBean> sortByLOINC(long id) throws DBException {\n\t\treturn lpDAO.getAllLabProceduresLOINC(id);\n\t}\n\n\t/**\n\t * Returns a list of all the lab procedures for the next month\n\t * \n\t * @return all the lab procedures for the next month\n\t */\n\tpublic List<LabProcedureBean> getLabProcForNextMonth() throws DBException {\n\t\tList<LabProcedureBean> listLabProc = new ArrayList<LabProcedureBean>(0);\n\t\tList<OfficeVisitBean> listOV = ovDAO.getAllOfficeVisitsForLHCP(loggedInMID);\n\t\tfor (OfficeVisitBean ov : listOV) {\n\t\t\tif (listLabProc.isEmpty() == true) {\n\t\t\t\tlistLabProc = lpDAO.getLabProceduresForLHCPForNextMonth(ov.getID());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (LabProcedureBean lb : lpDAO.getLabProceduresForLHCPForNextMonth(ov.getID())) {\n\t\t\t\t\tlistLabProc.add(lb);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn listLabProc;\n\t}\n\n\t/**\n\t * Changes the privacy settings\n\t * \n\t * @param x the ID of the procedure to change \n\t * \n\t */\n\tpublic void changePrivacy(long x) throws DBException, FormValidationException {\n\t\tLabProcedureBean pb = lpDAO.getLabProcedure(x);\n\t\tif (checkAccess(x)) {\n\t\t\tif (pb.getRights().equals(LabProcedureBean.Restrict)) {\n\t\t\t\tpb.allow();\n\t\t\t} else {\n\t\t\t\tpb.restrict();\n\t\t\t}\n\t\t\tvalidator.validate(pb);\n\t\t\tlpDAO.updateRights(pb);\n\t\t\ttransDAO.logTransaction(TransactionType.ENTER_EDIT_LAB_PROCEDURE, loggedInMID, pb.getPid(),\n\t\t\t\t\t\"Privacy Changed procedure id: \" + pb.getProcedureID());\n\t\t}\n\n\t}\n\t\n\t/**\n\t * Checks to see if the logged in HCP is the one who made the procedure.  Used to generate links for page to edit OfficeVisit\n\t * \n\t * @param x the ID of the HCP to check\n\t * \n\t */\n\tpublic boolean checkAccess(long x) throws DBException, FormValidationException {\n\t\tLabProcedureBean pb = lpDAO.getLabProcedure(x);\n\t\tOfficeVisitBean ovbean = ovDAO.getOfficeVisit(pb.getOvID());\n\t\treturn (loggedInMID == ovbean.getHcpID());\n\n\t}\n}", "LabProcUAPAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.EmailUtil;\nimport edu.ncsu.csc.itrust.beans.Email;\nimport edu.ncsu.csc.itrust.beans.LabProcedureBean;\nimport edu.ncsu.csc.itrust.beans.PatientBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.LabProcedureDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.PatientDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\nimport edu.ncsu.csc.itrust.validate.LabProcedureValidator;\n/**\n * Class for LabProcUAP.jsp.  Handles lab procedures for UAPs\n */\npublic class LabProcUAPAction {\n\tprivate TransactionDAO transDAO;\n\tprivate LabProcedureDAO lpDAO;\n\tlong loggedInMID;\n\tprivate LabProcedureValidator validator;\n\tprivate DAOFactory factory;\n\n/**\n * Setup \n * @param factory The DAOFactory used to create the DAOs used in this action.\n * @param loggedInMID UAP who is logged in\n */\n\tpublic LabProcUAPAction(DAOFactory factory, long loggedInMID) {\n\t\ttransDAO = factory.getTransactionDAO();\n\t\tlpDAO = factory.getLabProcedureDAO();\n\t\tthis.loggedInMID = loggedInMID;\n\t\tvalidator = new LabProcedureValidator();\n\t\tthis.factory = factory;\n\t}\n\t\n\t/**\n\t * Updates a lab procedure\n\t * \n\t * @param b the procedure to update\n\t * @throws DBException\n\t * @throws FormValidationException\n\t */\n\tpublic void updateProcedure(LabProcedureBean b) throws DBException, FormValidationException{\n\t\tvalidator.validate(b);\n\t\t//need to check if status is what's being changed - if new status!=old status send email\n\t\tif(!b.getStatus().equals(lpDAO.getLabProcedure(b.getProcedureID()).getStatus())){\n\t\t\tnew EmailUtil(factory).sendEmail(makeEmail(b));\n\t\t}\n\t\tlpDAO.updateLabProcedure(b);\n\t\ttransDAO.logTransaction(TransactionType.ENTER_EDIT_LAB_PROCEDURE, loggedInMID, \n\t\t\t\tb.getPid(), \"UAP updated procedure id: \"\n\t\t\t\t+ b.getProcedureID());\n\t}\n\t\n\t/**\n\t * Sends an e-mail informing the patient that their procedure has been updated\n\t * \n\t * @param b the procedure that was updated\n\t * @return an e-mail to the patient with the notice\n\t * @throws DBException\n\t */\n\tprivate Email makeEmail(LabProcedureBean b) throws DBException{\n\t\t\n\t\tPatientBean p = new PatientDAO(factory).getPatient(b.getPid());\n\t\t\n\t\tEmail email = new Email();\n\t\temail.setFrom(\"no-reply@itrust.com\");\n\t\temail.setToList(Arrays.asList(p.getEmail()));\n\t\temail.setSubject(\"A Lab Procedure Was Updated\");\n\t\temail.setBody(String.format(\"Dear %s, \\n Your Lab Procedure (%s) has a new updated status of %s. Log on to iTrust to view.\",  p.getFullName(),b.getLoinc(),b.getStatus()));\n\t\treturn email;\n\t}\n\t\n\t/**\n\t * Returns a list of all the lab procedures\n\t * \n\t * @param id MID of the UAP viewing the procedures \n\t * @return a list of all the lab procedures for that UAP\n\t * @throws DBException\n\t */\n\tpublic List<LabProcedureBean> viewProcedures(long id) throws DBException {\n\t\ttransDAO.logTransaction(TransactionType.VIEW_LAB_PROCEDURE, loggedInMID,\n\t\t\t\tid, \"UAP viewed procedures\");\n\t\treturn lpDAO.getAllLabProceduresDate(id);\n\t}\n}", "LoginFailureAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.AuthDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.DBException;\n\n/**\n * Please note that this is not the best mitigation for Denial of Service attacks. The better way would be to\n * keep track of password failure attempts per user account, NOT with easily spoofable ip addresses. The\n * reason this feature is implemented with ip addresses is a limitation in Tomcat authentication (actually,\n * it's technically JSP's fault for not specifying a form of account lockout). <br />\n * <br />\n * All authentication in this application is done by the container (Tomcat), which doesn't support account\n * lockout. So our options would be (a) to implement our own authentication (yuck!), or (2) to extend the\n * JDBCRealm class in the Tomcat source code and add the logic. I've looked into this and it's actually pretty\n * easy. The ONLY reason it's not implemented here is that the code would be buried in a jar in your Tomcat\n * installation - not very educational for those who want to learn about authentication in webapps. Feel free\n * to change this; extending this would be perfectly acceptable.\n * \n * @author Andy\n * \n */\npublic class LoginFailureAction {\n\tpublic static final int MAX_LOGIN_ATTEMPTS = 3;\n\tprivate AuthDAO authDAO;\n\tprivate String ipAddr;\n\tprivate TransactionDAO transactionDAO;\n\n\t/**\n\t * Set up defaults\n\t * @param factory The DAOFactory used to create the DAOs used in this action.\n\t * @param ipAddr The IP address of the user making the login attempt.\n\t */\n\tpublic LoginFailureAction(DAOFactory factory, String ipAddr) {\n\t\tthis.authDAO = factory.getAuthDAO();\n\t\tthis.ipAddr = ipAddr;\n\t\tthis.transactionDAO = factory.getTransactionDAO();\n\t}\n\n\t/**\n\t * Calls authDAO to record the login failure in the database\n\t * \n\t * @return How many login failure attempts or a DBException message\n\t */\n\tpublic String recordLoginFailure() {\n\t\ttry {\n\t\t\tauthDAO.recordLoginFailure(ipAddr);\n\t\t\tint loginFailures = authDAO.getLoginFailures(ipAddr);\n\t\t\ttransactionDAO.logTransaction(TransactionType.LOGIN_FAILURE, 0L, 0L, \"IP: \" + ipAddr);\n\t\t\treturn \"Login failed, attempt \" + loginFailures;\n\t\t} catch (DBException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn e.getMessage();\n\t\t}\n\t}\n\n\t/**\n\t * Checks to see if the current user can login (#failures<3)\n\t * \n\t * @return true if the user is valid to login\n\t */\n\tpublic boolean isValidForLogin() {\n\t\ttry {\n\t\t\treturn authDAO.getLoginFailures(ipAddr) < 3;\n\t\t} catch (DBException e) {\n\t\t\tSystem.err.println(\"Denying access due to DBException\");\n\t\t\treturn false;\n\t\t}\n\t}\n}", "ManageHospitalAssignmentsAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.HospitalBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.HospitalsDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\n\n/**\n * Manages the assignment of HCPs to hospitals Used by hospitalAssignments.jsp\n * \n * @author laurenhayward\n * \n */\npublic class ManageHospitalAssignmentsAction {\n\tprivate TransactionDAO transDAO;\n\tprivate PersonnelDAO personnelDAO;\n\tprivate HospitalsDAO hospitalsDAO;\n\tprivate long loggedInMID;\n\n\t/**\n\t * Set up defaults\n\t * \n\t * @param factory The DAOFactory used to create the DAOs used in this action.\n\t * @param loggedInMID The MID of the user managing hospitals.\n\t */\n\tpublic ManageHospitalAssignmentsAction(DAOFactory factory, long loggedInMID) {\n\t\tthis.loggedInMID = loggedInMID;\n\t\tthis.transDAO = factory.getTransactionDAO();\n\t\tthis.personnelDAO = factory.getPersonnelDAO();\n\t\tthis.hospitalsDAO = factory.getHospitalsDAO();\n\t}\n\n\t/**\n\t * Returns a list of hospitals to which the given mid is not currently assigned\n\t * \n\t * @param midString\n\t * @return list of HospitalBeans\n\t * @throws iTrustException\n\t */\n\tpublic List<HospitalBean> getAvailableHospitals(String midString) throws iTrustException {\n\t\ttry {\n\t\t\tlong mid = Long.valueOf(midString);\n\t\t\tList<HospitalBean> allHospitals = hospitalsDAO.getAllHospitals();\n\t\t\tList<HospitalBean> ourHospitals = personnelDAO.getHospitals(mid);\n\t\t\twhile (!ourHospitals.isEmpty()) {\n\t\t\t\tallHospitals.remove(ourHospitals.remove(0));\n\t\t\t}\n\n\t\t\treturn allHospitals;\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new iTrustException(\"HCP's MID not a number\");\n\t\t}\n\t}\n\n\t/**\n\t * Returns a list of hospitals to which the given mid is currently assigned\n\t * \n\t * @param midString\n\t * @return list of HosptialBeans\n\t * @throws iTrustException\n\t */\n\tpublic List<HospitalBean> getAssignedHospitals(String midString) throws iTrustException {\n\t\ttry {\n\t\t\tlong mid = Long.valueOf(midString);\n\t\t\treturn personnelDAO.getHospitals(mid);\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new iTrustException(\"HCP's MID not a number\");\n\t\t}\n\t}\n\n\t/**\n\t * Assigns the mid to the hospital\n\t * \n\t * @param midString The MID of the person assigned to the hospital as a String.\n\t * @param hospitalID The ID of the hospital.\n\t * @return message indicating the status of the assignment\n\t * @throws iTrustException\n\t */\n\tpublic String assignHCPToHospital(String midString, String hospitalID) throws iTrustException {\n\t\ttry {\n\t\t\tlong hcpID = Long.valueOf(midString);\n\t\t\tboolean confirm = hospitalsDAO.assignHospital(hcpID, hospitalID);\n\t\t\tif (confirm) {/*\n\t\t\t\t\t\t\t * only patient is mentioned for transaction type 0, but spec looks like personnel\n\t\t\t\t\t\t\t * should be included too...\n\t\t\t\t\t\t\t */\n\t\t\t\ttransDAO.logTransaction(TransactionType.ENTER_EDIT_DEMOGRAPHICS, loggedInMID, hcpID,\n\t\t\t\t\t\t\"HCP Assigned to Hospital\");\n\t\t\t\treturn \"HCP successfully assigned.\";\n\t\t\t} else\n\t\t\t\treturn \"Assignment did not occur\";\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new iTrustException(\"HCP's MID not a number\");\n\t\t}\n\t}\n\n\t/**\n\t * Removes HCPs assignment to the designated hospital\n\t * \n\t * @param midString\n\t *            the HCP's mid\n\t * @param hospitalID\n\t *            the hospital id to be removed\n\t * @return Status message\n\t * @throws iTrustException\n\t */\n\tpublic String removeHCPAssignmentToHospital(String midString, String hospitalID) throws iTrustException {\n\t\ttry {\n\t\t\tlong hcpID = Long.valueOf(midString);\n\t\t\tboolean confirm = hospitalsDAO.removeHospitalAssignment(hcpID, hospitalID);\n\t\t\tif (confirm) {\n\t\t\t\ttransDAO.logTransaction(TransactionType.ENTER_EDIT_DEMOGRAPHICS, loggedInMID, hcpID,\n\t\t\t\t\t\t\"HCP unassigned from hospital\");\n\t\t\t\treturn \"HCP successfully unassigned\";\n\t\t\t} else\n\t\t\t\treturn \"HCP not unassigned\";\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new iTrustException(\"HCP's MID not a number\");\n\t\t}\n\t}\n\n\t/**\n\t * Removes all hospital assignments for the given hcp mid\n\t * \n\t * @param midString\n\t *            HCP's mid\n\t * @return status message\n\t * @throws iTrustException\n\t */\n\tpublic int removeAllAssignmentsFromHCP(String midString) throws iTrustException {\n\t\ttry {\n\t\t\tlong hcpID = Long.valueOf(midString);\n\t\t\tint numAssignments = hospitalsDAO.removeAllHospitalAssignmentsFrom(hcpID);\n\t\t\tif (0 < numAssignments) {\n\t\t\t\ttransDAO.logTransaction(TransactionType.ENTER_EDIT_DEMOGRAPHICS, loggedInMID, hcpID,\n\t\t\t\t\t\t\"HCP unassigned from all hospital\");\n\t\t\t}\n\t\t\treturn numAssignments;\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new iTrustException(\"HCP's MID not a number\");\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the hcpID param is a HCP\n\t * \n\t * @param hcpID\n\t *            the String to be checked\n\t * @return the mid as a long if the hcpID is a HCP's mid\n\t * @throws iTrustException\n\t */\n\tpublic long checkHCPID(String hcpID) throws iTrustException {\n\t\ttry {\n\t\t\tlong pid = Long.valueOf(hcpID);\n\t\t\tif (personnelDAO.checkPersonnelExists(pid))\n\t\t\t\treturn pid;\n\t\t\telse\n\t\t\t\tthrow new iTrustException(\"HCP does not exist\");\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new iTrustException(\"HCP ID is not a number: \" + e.getMessage());\n\t\t}\n\t}\n\n}", "MonitorAdverseEventAction.java": "package edu.ncsu.csc.itrust.action;\n\n/**\n * Used by PHAs to view the reported adverse events\n */\nimport java.sql.SQLException;\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.EmailUtil;\nimport edu.ncsu.csc.itrust.beans.AdverseEventBean;\nimport edu.ncsu.csc.itrust.beans.Email;\nimport edu.ncsu.csc.itrust.beans.MessageBean;\nimport edu.ncsu.csc.itrust.beans.PatientBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.AdverseEventDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.PatientDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\n\npublic class MonitorAdverseEventAction {\n\t \n\tprivate long loggedInMID;\n\tprivate EmailUtil emailer;\n\tprivate PatientDAO patientDAO;\n\tprivate AdverseEventDAO adverseEventDAO;\n\tprivate TransactionDAO transactionDAO;\n\tprivate SendMessageAction messenger;\n\t\n\t/**\n\t * Constructor \n\t * @param factory\n\t * @param loggedInMID\n\t */\n\tpublic MonitorAdverseEventAction(DAOFactory factory, long loggedInMID){\n\t\tthis.loggedInMID = loggedInMID;\n\t\tthis.transactionDAO = factory.getTransactionDAO();\n\t\tthis.patientDAO = factory.getPatientDAO();\n\t\tthis.emailer = new EmailUtil(factory);\n\t\tthis.adverseEventDAO = factory.getAdverseEventDAO();\n\t\tthis.messenger = new SendMessageAction(factory, loggedInMID);\n\t\t\n\t}\n\t/**\n\t * Returns a list of reports between specified dates\n\t * @param isPrescription Boolean to return prescriptions or immunizations\n\t * @param start The starting date\n\t * @param end The ending date\n\t * @return the list of events\n\t * @throws iTrustException\n\t * @throws FormValidationException\n\t * @throws SQLException\n\t * @throws ParseException\n\t */\n\tpublic List<AdverseEventBean> getReports(boolean isPrescription, String start, String end)throws iTrustException, FormValidationException, SQLException, ParseException {\n\t\tif(isPrescription) {\n\t\t\ttransactionDAO.logTransaction(TransactionType.ADVERSE_EVENT, loggedInMID, 0L, \"Adverse Prescription Reports Requested.\");\n\t\t\treturn adverseEventDAO.getPerscriptions(start, end);\n\t\t} else { //is Immunization\n\t\t\ttransactionDAO.logTransaction(TransactionType.ADVERSE_EVENT, loggedInMID, 0L, \"Adverse Immunization Report Requested.\");\n\t\t\treturn adverseEventDAO.getImmunizations(start, end);\n\t\t}\n\t\t\n\t}\n\t\n\t/**\n\t * Returns the patient's name\n\t * @param MID the MID of the patient to return the name for.\n\t * @return\n\t */\n\tpublic String getName(long MID) {\n\t\ttry {\n\t\t\treturn patientDAO.getName(MID);\n\t\t} catch(DBException e) {\n\t\t\treturn \"\";\n\t\t} catch(iTrustException e) {\n\t\t\treturn \"Patient no longer exists\";\n\t\t}\n\t}\n\t\n\t/**\n\t * Sends an e-mail to a patient requesting more information\n\t * @param patientMID The patient to receive the message\n\t * @param message The message\n\t * @return string for testing purposes\n\t * @throws DBException\n\t */\n\tpublic String sendEmail(long patientMID, String message) throws DBException{\n\t\tString rValue;\n\t\tList<String> toList = new ArrayList<String>();\n\t\tPatientBean receiver = patientDAO.getPatient(patientMID);\n\t\ttoList.add(receiver.getEmail());\n\t\tEmail mail = new Email();\n\t\tmail.setBody(message);\n\t\tmail.setFrom(loggedInMID + \"\");\n\t\tmail.setToList(toList);\n\t\temailer.sendEmail(mail);\n\t\ttransactionDAO.logTransaction(TransactionType.ADVERSE_EVENT, loggedInMID, 0L, \"Requested more information\");\n\t\trValue = \"\" + mail.getFrom() + \" \" + mail.getBody();\n\t\treturn rValue;\n\t}\n\t\n\t/**\n\t * Method used to remove an adverse event report\n\t * \n\t * @param id the id of the report to be removed\n\t * @throws DBException\n\t * @throws iTrustException\n\t */\n\tpublic void remove(int id) throws DBException, iTrustException, FormValidationException{\n\t\tlong HCPMID;\n\t\ttry{\n\t\tAdverseEventBean aeBean = adverseEventDAO.getReport(id);\n\t\tadverseEventDAO.removeReport(id);\n\t\tHCPMID = adverseEventDAO.getHCPMID(id);\n\t\tMessageBean mBeanTwo = new MessageBean();\n\t\tMessageBean mBeanOne = new MessageBean();\n\t\tString body = \"An adverse event for \" + aeBean.getDrug() + \" perscribed to \" + patientDAO.getName(Long.parseLong(aeBean.getMID())) +\" with description: (\" + aeBean.getDescription()+ \") was removed.\";\n\t\tmBeanOne.setTo(Long.parseLong(aeBean.getMID()));\n\t\tmBeanTwo.setTo(HCPMID);\n\t\tmBeanOne.setSubject(\"Subject\");\n\t\tmBeanTwo.setSubject(\"Subject\");\n\t\tmBeanOne.setBody(body);\n\t\tmBeanTwo.setBody(body);\n\t\tmBeanOne.setFrom(loggedInMID);\n\t\tmBeanTwo.setFrom(loggedInMID);\n\t\tmessenger.sendMessage(mBeanOne);\n\t\tmessenger.sendMessage(mBeanTwo);\n\t\ttransactionDAO.logTransaction(TransactionType.ADVERSE_EVENT, loggedInMID, 0L, \"Adverse Event Report Removed\");\n\t\t}catch(SQLException e){\n\t\t\tthrow new DBException(e);\n\t\t} \n\t}\n}", "MyDiagnosisAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport java.io.Serializable;\nimport java.util.*;\nimport edu.ncsu.csc.itrust.beans.DiagnosisBean;\nimport edu.ncsu.csc.itrust.beans.HCPDiagnosisBean;\nimport edu.ncsu.csc.itrust.beans.OfficeVisitBean;\nimport edu.ncsu.csc.itrust.beans.PrescriptionBean;\nimport edu.ncsu.csc.itrust.beans.MedicationBean;\nimport edu.ncsu.csc.itrust.beans.SurveyBean;\nimport edu.ncsu.csc.itrust.beans.LabProcedureBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.PatientDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.OfficeVisitDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.SurveyDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.LabProcedureDAO;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\n\n/**\n * Edits the privacy levels of diagnoses, used by myDiagnoses.jsp\n * \n * @author laurenhayward\n * \n */\npublic class MyDiagnosisAction {\n\t\n\tprivate OfficeVisitDAO officeVisitDAO;\n\tprivate PatientDAO patientDAO;\n\tprivate PersonnelDAO personnelDAO;\n\tprivate SurveyDAO surveyDAO;\n\tprivate TransactionDAO transactionDAO;\n\tprivate LabProcedureDAO labprocDAO;\n\tprivate long loggedInMID;\n\n\t/**\n\t * Set up for defaults\n\t * \n\t * @param factory The DAOFactory used to create the DAOs used in this action.\n\t * @param loggedInMID The MID of the user who is looking at their diagnoses.\n\t * @throws iTrustException\n\t */\n\tpublic MyDiagnosisAction(DAOFactory factory, long loggedInMID) throws iTrustException {\n\t\tthis.loggedInMID = loggedInMID;\n\t\tthis.patientDAO = factory.getPatientDAO();\n\t\tthis.officeVisitDAO = factory.getOfficeVisitDAO();\n\t\tthis.personnelDAO = factory.getPersonnelDAO();\n\t\tthis.surveyDAO = factory.getSurveyDAO();\n\t\tthis.transactionDAO = factory.getTransactionDAO();\n\t\tthis.labprocDAO = factory.getLabProcedureDAO();\n\t}\n\t\n\t/**\n\t * Returns a list of DiagnosisBeans for the patient\n\t * \n\t * @return the list of DiagnosisBeans\n\t * @throws DBException\n\t */\n\tpublic List<DiagnosisBean> getDiagnoses() throws DBException {\n\t\treturn patientDAO.getDiagnoses(loggedInMID);\n\t}\n\t\n\t/**\n\t * Returns a list of all the HCPs who have a particular diagnosis\n\t * \n\t * @param icdcode the diagnosis of interest\n\t * @return the list of HCPs\n\t * @throws DBException\n\t */\n\tpublic List<HCPDiagnosisBean> getHCPByDiagnosis(String icdcode) throws DBException {\n\t\t\n\t\tint medMatch = 0;\n\t\tHashMap<Long, HCPDiagnosisBean> hcpHash = new HashMap<Long, HCPDiagnosisBean>();\n\t\tHashMap<Long, Long> patientHash = new HashMap<Long, Long>();\n\t\n\t\ttransactionDAO.logTransaction(TransactionType.FIND_HCPS_WITH_EXP, loggedInMID);\n\t\t\n\t\tHCPDiagnosisBean diag = null;\n\t\tList<OfficeVisitBean> beans = officeVisitDAO.getAllOfficeVisitsForDiagnosis(icdcode);\n\t\t\n\t\tfor (OfficeVisitBean bean: beans) {\n\t\t\t\n\t\t\t// check for HCP-Patient locality based on first 3 digits in ZIP\n\t\t\tif (!patientDAO.getPatient(loggedInMID).getZip1().substring(0, 2).\n\t\t\t\t\tequals(personnelDAO.getPersonnel(bean.getHcpID()).getZip1().substring(0, 2)))\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\t// Check to see if we already have a bean for the HCP associated with this visit\n\t\t\tif (hcpHash.containsKey(bean.getHcpID())) {\n\t\t\t\tdiag = (HCPDiagnosisBean)hcpHash.get(bean.getHcpID());\n\t\t\t\t\n\t\t\t\tfor (PrescriptionBean p: bean.getPrescriptions()) {\n\t\t\t\t\tList<MedicationBean> mlist = diag.getMedList();\n\t\t\t\t\t\n\t\t\t\t\tfor (MedicationBean b: mlist) {\n\t\t\t\t\t\tif (p.getMedication().getDescription().equals(b.getDescription()))\n\t\t\t\t\t\t\tmedMatch++;\n\t\t\t\t\t}\n\t\t\t\t\tif (medMatch == 0) {\n\t\t\t\t\t\tmlist.add(p.getMedication());\n\t\t\t\t\t\tdiag.setMedList(mlist);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmedMatch = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Get Lab Procedures\n\t\t\t\tList<LabProcedureBean> labprocs = diag.getLabList(); \n\t\t\t\tList<LabProcedureBean> lpbeans = labprocDAO.getAllLabProceduresForDocOV(bean.getVisitID());\n\t\t\t\tfor (LabProcedureBean p: lpbeans) {\n\t\t\t\t\tlabprocs.add(p);\n\t\t\t\t}\n\t\t\t\tdiag.setLabList(labprocs);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif (surveyDAO.isSurveyCompleted(bean.getVisitID())) {\n\t\t\t\t\tSurveyBean survey = surveyDAO.getSurveyData(bean.getVisitID());\n\t\t\t\t\tdiag.setVisitSat(survey.getVisitSatisfaction());\n\t\t\t\t\tdiag.setTreatmentSat(survey.getTreatmentSatisfaction());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Check if this patient has been seen multiple times for this diagnosis\n\t\t\t\tif (!patientHash.containsKey(bean.getPatientID())) {\n\t\t\t\t\tpatientHash.put(bean.getPatientID(), bean.getHcpID());\n\t\t\t\t\tdiag.incNumPatients();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdiag = new HCPDiagnosisBean();\n\t\t\t\tList<MedicationBean> mlist = new ArrayList<MedicationBean>();\n\t\t\t\tdiag.setHCP(bean.getHcpID());\n\t\t\t\ttry {\n\t\t\t\t\tdiag.setHCPName(personnelDAO.getName(bean.getHcpID()));\n\t\t\t\t} catch (iTrustException e) {\n\t\t\t\t\tdiag.setHCPName(\"null\");\n\t\t\t\t}\n\t\t\t\tdiag.incNumPatients();\n\t\t\t\tfor (PrescriptionBean p: bean.getPrescriptions()) {\n\t\t\t\t\tmlist.add(p.getMedication());\n\t\t\t\t}\n\t\t\t\tdiag.setMedList(mlist);\n\t\t\t\tdiag.setLabList(labprocDAO.getAllLabProceduresForDocOV(bean.getVisitID()));\n\t\t\t\t\n\t\t\t\tif (surveyDAO.isSurveyCompleted(bean.getVisitID())) {\n\t\t\t\t\tSurveyBean survey = surveyDAO.getSurveyData(bean.getVisitID());\n\t\t\t\t\tdiag.setVisitSat(survey.getVisitSatisfaction());\n\t\t\t\t\tdiag.setTreatmentSat(survey.getTreatmentSatisfaction());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpatientHash.put(bean.getPatientID(), bean.getHcpID());\n\t\t\t\thcpHash.put(bean.getHcpID(), diag);\n\t\t\t}\n\t\t}\n\t\tList<HCPDiagnosisBean> list = new ArrayList<HCPDiagnosisBean>(hcpHash.values());\n\t\tCollections.sort(list, new HCPDiagnosisBeanComparator() );\n\t\treturn list;\n\t}\n\t\n\t/**\n\t * Looks up all the prescriptions given by a certain HCP with the same ICD code.\n\t * @param hcpid The MID of the HCP\n\t * @param icdcode The ICD code of the prescription we are looking up.\n\t * @return A java.util.List of PrescriptionBeans made by this HCP of this ICD code.\n\t * @throws DBException\n\t */\n\tpublic List<PrescriptionBean> getPrescriptionsByHCPAndICD(long hcpid, String icdcode) throws DBException {\n\t\tList<PrescriptionBean> list = new ArrayList<PrescriptionBean>();\n\t\t\n\t\tList<OfficeVisitBean> ovs = officeVisitDAO.getAllOfficeVisitsForDiagnosis(icdcode);\n\t\tfor (int i = 0; i < ovs.size(); i++) {\n\t\t\tif (ovs.get(i).getHcpID() == hcpid) {\n\t\t\t\tlist.addAll(ovs.get(i).getPrescriptions());\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn list;\n\t\t\n\t\t\n\t}\n\t\n\t\n\t/**\n\t * Checks to see what HCP has had the most experience with a diagnosis\n\t *\n\t */\n\tstatic class HCPDiagnosisBeanComparator implements Comparator<HCPDiagnosisBean>, Serializable {\n\t\t\n\t\tprivate static final long serialVersionUID = -6328390386684022934L;\n\n\t\t/**\n\t\t * Compares one HCP with another\n\t\t * \n\t\t * @param a the first HCP\n\t\t * @param b the second HCP\n\t\t * @return -1 if a has had more patients, 1 if b has had more patients; otherwise 0\n\t\t */\n\t\tpublic int compare(HCPDiagnosisBean a, HCPDiagnosisBean b) {\n\t\t\tint ret = 0;\n\t\t\t\n\t\t\tif (a.getNumPatients() > b.getNumPatients())\n\t\t\t\tret = -1;\n\t\t\telse if (a.getNumPatients() < b.getNumPatients())\n\t\t\t\tret = 1;\n\t\t\t\n\t\t\treturn ret;\n\t\t}\n\t}\n\t\n}", "PrescriptionReportAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport edu.ncsu.csc.itrust.ParameterUtil;\nimport edu.ncsu.csc.itrust.action.base.PatientBaseAction;\nimport edu.ncsu.csc.itrust.beans.OfficeVisitBean;\nimport edu.ncsu.csc.itrust.beans.PatientBean;\nimport edu.ncsu.csc.itrust.beans.PrescriptionReportBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.OfficeVisitDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.PatientDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\nimport edu.ncsu.csc.itrust.exception.NoHealthRecordsException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\n\n/**\n * Handles Prescription Reports for the given pid Used by hcp-uap/getPrescriptionReport.jsp,\n * hcp-uap/viewPrescriptionRecord.jsp, patient/getMyPrescriptionReport.jsp, &\n * patient/viewMyPrescriptionRecord.jsp\n * \n * @author laurenhayward\n * \n */\npublic class PrescriptionReportAction extends PatientBaseAction {\n\tprivate boolean isRepresenting = false;\n\tprivate OfficeVisitDAO ovDAO;\n\tprivate TransactionDAO transDAO;\n\tprivate PatientDAO patientDAO;\n\tprivate long loggedInMID;\n\n\t/**\n\t * Super class validates pidString\n\t * \n\t * @param factory The DAOFactory used to create the DAOs used in this action.\n\t * @param loggedInMID The MID of the user who is making a prescription report.\n\t * @param pidString The MID of the patient in question.\n\t * @throws iTrustException\n\t * @throws DBException\n\t * @throws NoHealthRecordsException\n\t */\n\tpublic PrescriptionReportAction(DAOFactory factory, long loggedInMID, String pidString)\n\t\t\tthrows iTrustException, DBException, NoHealthRecordsException {\n\t\tsuper(factory, pidString);\n\t\tthis.transDAO = factory.getTransactionDAO();\n\t\tthis.ovDAO = factory.getOfficeVisitDAO();\n\t\tthis.patientDAO = factory.getPatientDAO();\n\t\tthis.loggedInMID = loggedInMID;\n\t}\n\n\t/**\n\t * Takes the patient's representee as a param and returns it as a long if the patient represents the input\n\t * param\n\t * \n\t * @param input\n\t *            the patient's representee mid\n\t * @return representee's mid as a long\n\t * @throws iTrustException\n\t */\n\tpublic long representPatient(String input) throws iTrustException {\n\t\ttry {\n\t\t\tlong reppeeMID = Long.valueOf(input);\n\t\t\tif (patientDAO.represents(loggedInMID, reppeeMID)) {\n\t\t\t\tloggedInMID = reppeeMID;\n\t\t\t\tpid = reppeeMID;\n\t\t\t\tisRepresenting = true;\n\t\t\t\treturn reppeeMID;\n\t\t\t} else\n\t\t\t\tthrow new iTrustException(\"You do not represent patient \" + reppeeMID);\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new iTrustException(\"MID is not a number\");\n\t\t}\n\t}\n\n\t/**\n\t * Returns a list of all office visits for the pid\n\t * \n\t * @return list of OfficeVisitBeans for the pid\n\t * @throws DBException\n\t */\n\tpublic List<OfficeVisitBean> getAllOfficeVisits() throws DBException {\n\t\treturn ovDAO.getAllOfficeVisits(pid);\n\t}\n\n\t/**\n\t * Used by the JSP, passes a Map from the html form and a list of OfficeVisitBeans Returns a list of\n\t * PrescriptionReportBeans\n\t * \n\t * @param params A java.util.HashMap containing the parameter map.\n\t * @param officeVisits A java.util.List of OfficeVisitBeans for the visits.\n\t * @return list of PrescriptionReportBeans\n\t * @throws DBException\n\t */\n\t// suppressing warnings because JSP doesn't have a generic for request.getParameterMap()\n\t@SuppressWarnings(\"unchecked\")\n\tpublic List<PrescriptionReportBean> getPrescriptionReports(Map params, List<OfficeVisitBean> officeVisits)\n\t\t\tthrows DBException {\n\t\tHashMap<String, String> myParams = ParameterUtil.convertMap(params);\n\t\tList<Long> ovIDs = new ArrayList<Long>();\n\t\tfor (int i = 0; i < officeVisits.size(); i++) {\n\t\t\ttry {\n\t\t\t\tif (params.get(\"ovOff\" + i) != null) {\n\t\t\t\t\tint offset = Integer.valueOf(myParams.get(\"ovOff\" + i));\n\t\t\t\t\tovIDs.add(officeVisits.get(offset).getVisitID());\n\t\t\t\t}\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t// just skip it\n\t\t\t}\n\t\t}\n\t\ttransDAO.logTransaction(TransactionType.VIEW_PRESCRIPTION_REPORT, loggedInMID, pid,\n\t\t\t\t\"Getting reports for office visits \" + ovIDs.toString());\n\t\tif (ovIDs.size() == 0)\n\t\t\treturn new ArrayList<PrescriptionReportBean>();\n\n\t\treturn ovDAO.getPrescriptionReports(ovIDs, pid);\n\t}\n\n\t/**\n\t * Returns a PatientBean for the pid\n\t * \n\t * @return PatientBean\n\t * @throws DBException\n\t */\n\tpublic PatientBean getPatient() throws DBException {\n\t\treturn patientDAO.getPatient(pid);\n\t}\n\n\t/**\n\t * Used by the JSP, which passes the param map from the html form and a list of OfficeVisitBeans Returns a\n\t * string that will be used to create a new url. The JSP will pull params from this url to create the\n\t * prescription report.\n\t * \n\t * @param paramMap A java.util.HashMap of the parameters.\n\t * @param officeVisits A java.util.List of OfficeVisitBeans.\n\t * @return the string that will be used in the new url\n\t * @throws FormValidationException\n\t * @throws DBException\n\t */\n\t// suppressing warnings because JSP doesn't have a generic for request.getParameterMap()\n\t@SuppressWarnings(\"unchecked\")\n\tpublic String getQueryString(Map paramMap, List<OfficeVisitBean> officeVisits)\n\t\t\tthrows FormValidationException, DBException {\n\t\tHashMap<String, String> myParams = ParameterUtil.convertMap(paramMap);\n\t\tList<Integer> ovOffsets = checkOfficeVisits(myParams, officeVisits);\n\t\tString queryString = buildQueryString(ovOffsets);\n\t\tif (isRepresenting)\n\t\t\tqueryString += \"&rep=\" + pid;\n\t\treturn queryString;\n\t}\n\n\t/**\n\t * Checks office visits\n\t * \n\t * @param myParams list of parameters\n\t * @param officeVisits list of office visits\n\t * @return Returns a java.util.ArrayList of Integers for the given office visits.\n\t */\n\tprivate ArrayList<Integer> checkOfficeVisits(HashMap<String, String> myParams,\n\t\t\tList<OfficeVisitBean> officeVisits) {\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < officeVisits.size(); i++) {\n\t\t\tif (\"on\".equals(myParams.get(\"ov\" + i)))\n\t\t\t\tlist.add(i);\n\t\t}\n\t\treturn list;\n\t}\n\n\t/**\n\t * Builds a query string for office visits\n\t * \n\t * @param ovOffsets offsets for the office visits\n\t * @return A SQL query in a Java String.\n\t */\n\tprivate String buildQueryString(List<Integer> ovOffsets) {\n\t\tint n = ovOffsets.size();\n\t\tif (n == 0)\n\t\t\treturn \"\";\n\t\tString str = \"&n=\" + n;\n\t\tfor (int i = 0; i < ovOffsets.size(); i++) {\n\t\t\tstr += \"&ovOff\" + i + \"=\" + ovOffsets.get(i);\n\t\t}\n\t\treturn str;\n\t}\n}", "ReferralManagementAction.java": "package edu.ncsu.csc.itrust.action;\n\n\nimport edu.ncsu.csc.itrust.beans.ReferralBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.ReferralDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport java.util.List;\n\n/**\n * Used for referring patients to other HCPs.  The call is made in /auth/hcp/hcpConsultation.jsp \n */\npublic class ReferralManagementAction {\n\tprivate long loggedInMID;\n\tprivate TransactionDAO transDAO;\n\tprivate ReferralDAO referralDAO;\n\n\t/**\n\t * Super class validates the patient id\n\t * \n\t * @param factory The DAOFactory used to create the DAOs used in this action.\n\t * @param loggedInMID The MID of the user managing this referral.\n\t * @param pidString The MID of the patient being referred.\n\t * @throws iTrustException\n\t */\n\tpublic ReferralManagementAction(DAOFactory factory, long loggedInMID) throws iTrustException {\n\t\t\n\t\tthis.referralDAO = factory.getReferralDAO();\n\t\tthis.loggedInMID = loggedInMID;\n\t\tthis.transDAO = factory.getTransactionDAO();\n\t}\n\n\t/**\n\t * Adds a referral bean to the database.\n\t * @param r The referral bean to be added.\n\t * @throws DBException\n\t */\n\tpublic void sendReferral(ReferralBean r) throws DBException {\n\t\treferralDAO.addReferral(r);\n\t\ttransDAO.logTransaction(TransactionType.SEND_REFERRAL, loggedInMID);\n\t}\n\t\n\t/**\n\t * Updates an existing referral bean.\n\t * @param r The current referral bean.\n\t * @throws DBException\n\t */\n\tpublic void updateReferral(ReferralBean r) throws DBException {\n\t\treferralDAO.editReferral(r);\n\t}\n\t\n\t/**\n\t * Gets the referrals the currently logged in MID has sent.\n\t * @return A java.util.List of ReferralBeans this MID has sent.\n\t * @throws DBException\n\t */\n\tpublic List<ReferralBean> getReferralsSentFromMe() throws DBException {\n\t\treturn referralDAO.getReferralsSentFrom(loggedInMID);\n\t}\n\t\n\t/**\n\t * Gets the referrals this MID has received.\n\t * @return A java.util.List of the ReferralBeans this MID has received.\n\t * @throws DBException\n\t */\n\tpublic List<ReferralBean> getReferralsSentToMe() throws DBException {\n\t\treturn referralDAO.getReferralsSentTo(loggedInMID);\n\t}\n\n}", "ReportAdverseEventAction.java": "package edu.ncsu.csc.itrust.action;\n/**\n * Used for the patient to report adverse events.\n */\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.EmailUtil;\nimport edu.ncsu.csc.itrust.beans.Email;\nimport edu.ncsu.csc.itrust.beans.AdverseEventBean;\nimport edu.ncsu.csc.itrust.beans.PatientBean;\nimport edu.ncsu.csc.itrust.beans.PersonnelBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.AdverseEventDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.PatientDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\nimport edu.ncsu.csc.itrust.validate.AdverseEventValidator;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\n\npublic class ReportAdverseEventAction {\n\t\n\tprivate long loggedInMID;\n\tprivate EmailUtil emailer;\n\tprivate PatientDAO patientDAO;\n\tprivate PersonnelDAO personnelDAO;\n\tprivate AdverseEventDAO adverseEventDAO;\n\tprivate TransactionDAO transactionDAO;\n\tprivate long hcpID;\n\tprivate AdverseEventValidator validator;\n\t\n\tpublic ReportAdverseEventAction(String hcpID, DAOFactory factory, long loggedInMID){\n\t\tthis.loggedInMID = loggedInMID;\n\t\tthis.patientDAO = factory.getPatientDAO();\n\t\tthis.personnelDAO = factory.getPersonnelDAO();\n\t\tthis.emailer = new EmailUtil(factory);\n\t\tthis.adverseEventDAO = factory.getAdverseEventDAO();\n\t\tthis.transactionDAO = factory.getTransactionDAO();\n\t\tthis.hcpID = Long.parseLong(hcpID);\n\t\tthis.validator = new AdverseEventValidator();\n\t\t\n\t\t\n\t}\n\t\n\t/**\n\t * Constructor used to send e-mails only\n\t */\n\tpublic ReportAdverseEventAction(DAOFactory factory, long loggedInMID){\n\t\tthis.loggedInMID = loggedInMID;\n\t\tthis.patientDAO = factory.getPatientDAO();\n\t\tthis.personnelDAO = factory.getPersonnelDAO();\n\t\tthis.emailer = new EmailUtil(factory);\n\t\tthis.adverseEventDAO = factory.getAdverseEventDAO();\n\t\tthis.transactionDAO = factory.getTransactionDAO();\n\t\tthis.validator = new AdverseEventValidator();\n\t}\n\t/**\n\t * Method that sends exactly one e-mail to each MID in the list of Adverse Events\n\t * @param aeList The list of adverse Event Beans that need to be acted upon\n\t * @return EList The list of e-mails sent for testing purposes\n\t */\n\tpublic Email sendMails(List<AdverseEventBean> aeList) throws iTrustException, FormValidationException, DBException {\n\t\tList<String> MIDlist = new ArrayList<String>();\n\t\tString patientID = \"\";\n\t\t\n\t\tfor(AdverseEventBean beaner : aeList){\n\t\t\tpatientID = beaner.getMID();\n\t\t\tString newDesc = \" Drug: \" + beaner.getDrug() + \" (\" + beaner.getCode() + \") Description: \" + beaner.getDescription();\n\t\t\tbeaner.setDescription(newDesc);\n\t\t}\n\t\tfor(AdverseEventBean beano : aeList){\n\t\t\tif(!MIDlist.contains(beano.getPrescriber())){\n\t\t\t\tMIDlist.add(beano.getPrescriber());\n\t\t\t}\n\t\t}\n\t\tEmail email = new Email();\n\t\t\n\t\tfor(String num : MIDlist){\n\t\t\tString message = \" Patient: \" + patientDAO.getName(Long.parseLong(patientID)) \n\t\t\t\t+ \" (MID \" + patientID + \") Has Reported the following adverse event(s)\";\n\t\t\tfor(AdverseEventBean beano : aeList){\n\t\t\t\tif(beano.getPrescriber().equals(num)){\n\t\t\t\t\tmessage = message + beano.getDescription();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tString fromEmail;\n\t\t\temail.setFrom(\"noreply@itrust.com\");\n\t\t\tPatientBean sender = patientDAO.getPatient(loggedInMID);\n\t\t\tPersonnelBean receiver = personnelDAO.getPersonnel(Long.parseLong(num));\n\t\t\tList<String> toList = new ArrayList<String>();\n\t\t\ttoList.add(receiver.getEmail());\n\t\t\tfromEmail = sender.getEmail();\n\t\t\t\n\t\t\temail.setToList(toList);\n\t\t\temail.setFrom(fromEmail);\n\t\t\temail.setSubject(String.format(\"Adverse Event Report(Prescription)\"));\n\t\t\temail.setBody(message);\n\t\t\temailer.sendEmail(email);\n\t\t\ttransactionDAO.logTransaction(TransactionType.SEND_MESSAGE, loggedInMID);\n\t\t\t\n\t\t}\n\t\treturn email;\n\t}\n\t/**\n\t * A method used to send a single e-mail. Used in immunizations.\n\t * @param aeBean\n\t * @return Email returns the Email for testing purposes.\n\t */\n\tpublic Email sendMail (AdverseEventBean aeBean)throws iTrustException, FormValidationException, DBException{\n\t\tEmail email = new Email();\n\t\tString fromEmail;\n\t\temail.setFrom(\"noreply@itrust.com\");\n\t\tList<String> toList = new ArrayList<String>();\n\t\t\n\t\tPatientBean sender = patientDAO.getPatient(loggedInMID);\n\t\tPersonnelBean receiver = personnelDAO.getPersonnel(hcpID);\n\t\t\n\t\ttoList.add(receiver.getEmail());\n\t\tfromEmail = sender.getEmail();\n\t\t\n\t\temail.setToList(toList);\n\t\temail.setFrom(fromEmail);\n\t\temail.setSubject(String.format(\"Adverse Event Report (Immunization)\"));\n\t\temail.setBody(String.format(\n\t\t\t\t\" Patient: \" + patientDAO.getName(Long.parseLong(aeBean.getMID())) \n\t\t\t\t+ \" (MID \" + aeBean.getMID() + \") Has Reported the following adverse event\" +\n\t\t\t\t\" Drug: \" + aeBean.getDrug() + \"(\" + aeBean.getCode() + \") Description: \" + aeBean.getDescription()\n\t\t\t\t));\n\t\temailer.sendEmail(email);\n\t\t\n\t\ttransactionDAO.logTransaction(TransactionType.SEND_MESSAGE, loggedInMID);\n\t\t\n\t\treturn email;\n\t}\n\t\n\t/**\n\t * Method used to add a report to the data base\n\t * @param aeBean The adverse event to add\n\t * @return a string for testing purposes only\n\t * @throws iTrustException\n\t * @throws FormValidationException\n\t * @throws DBException\n\t */\n\tpublic String addReport(AdverseEventBean aeBean)throws iTrustException, FormValidationException, DBException {\n\t\t\n\t\ttry{\n\t\t\tvalidator.validate(aeBean);\n\t\t}catch (FormValidationException e){\n\t\t\te.printStackTrace();\n\t\t\treturn e.getMessage();\n\t\t\t}\n\t\ttry{\n\t\t\tadverseEventDAO.addReport(aeBean, hcpID);\n\t\t}\n\t\tcatch( DBException e ){\n\t\t\tthrow new iTrustException(e.getMessage());\n\t\t}\n\t\t/**\n\t\t * Old code used to send a single e-mail. Keep for reference\n\t\tEmail email = new Email();\n\t\tString senderName;\n\t\tString fromEmail;\n\t\temail.setFrom(\"noreply@itrust.com\");\n\t\tList<String> toList = new ArrayList<String>();\n\t\t\n\t\tPatientBean sender = patientDAO.getPatient(loggedInMID);\n\t\tPersonnelBean receiver = personnelDAO.getPersonnel(hcpID);\n\t\t\n\t\ttoList.add(receiver.getEmail());\n\t\tsenderName = sender.getFullName();\n\t\tfromEmail = sender.getEmail();\n\t\t\n\t\temail.setToList(toList);\n\t\temail.setFrom(fromEmail);\n\t\temail.setSubject(String.format(\"Adverse Event Report\"));\n\t\temail.setBody(String.format(\n\t\t\t\t\" Patient: \" + patientDAO.getName(Long.parseLong(aeBean.getMID())) \n\t\t\t\t+ \" (MID \" + aeBean.getMID() + \") Has Reported the following adverse event(s)\" +\n\t\t\t\t\" Drug: \" + aeBean.getDrug() + \"(\" + aeBean.getCode() + \") Description: \" + aeBean.getDescription()\n\t\t\t\t));\n\t\temailer.sendEmail(email);\n\t\t\n\t\ttransactionDAO.logTransaction(TransactionType.SEND_MESSAGE, loggedInMID);*/\n\t\ttransactionDAO.logTransaction(TransactionType.ADVERSE_EVENT, loggedInMID);\n\t\treturn \"\";\n\t}\n}", "ResetPasswordAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport java.util.Arrays;\nimport edu.ncsu.csc.itrust.EmailUtil;\nimport edu.ncsu.csc.itrust.beans.Email;\nimport edu.ncsu.csc.itrust.beans.PatientBean;\nimport edu.ncsu.csc.itrust.beans.PersonnelBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.AuthDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.PatientDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;\nimport edu.ncsu.csc.itrust.enums.Role;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.ErrorList;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\nimport edu.ncsu.csc.itrust.validate.ValidationFormat;\n\n/**\n * Manages resetting the password Used by resetPassword.jsp\n * \n * @author laurenhayward\n * \n */\npublic class ResetPasswordAction {\n\tpublic static final int MAX_RESET_ATTEMPTS = 3;\n\n\tprivate AuthDAO authDAO;\n\tprivate PatientDAO patientDAO;\n\tprivate DAOFactory factory;\n\n\t/**\n\t * Set up defaults\n\t * @param factory The DAOFactory used to create the DAOs used in this action.\n\t */\n\tpublic ResetPasswordAction(DAOFactory factory) {\n\t\tthis.authDAO = factory.getAuthDAO();\n\t\tthis.patientDAO = factory.getPatientDAO();\n\t\tthis.factory = factory;\n\t}\n\n\t/**\n\t * Checks to see if a user exists with the given mid\n\t * \n\t * @param midString The user's MID to check for.\n\t * @return 0 if the user does not exist, else the mid of the user as a long\n\t */\n\tpublic long checkMID(String midString) {\n\t\ttry {\n\t\t\tlong mid = Long.valueOf(midString);\n\t\t\tif (!authDAO.checkUserExists(mid))\n\t\t\t\treturn 0;\n\t\t\treturn mid;\n\t\t} catch (NumberFormatException e) {\n\t\t\treturn 0L;\n\t\t} catch (DBException e) {\n\t\t\treturn 0L;\n\t\t}\n\t}\n\n\t/**\n\t * Checks to see if the number of reset password attempts has been exceeded for the given ipAddress\n\t * \n\t * @param ipAddress The IPv4 or IPv6 IP address as a String.\n\t * @return true if the the number of reset attempts is greater than or equal to MAX_RESET_ATTEMPTS\n\t * @throws DBException\n\t */\n\tpublic boolean isMaxedOut(String ipAddress) throws DBException {\n\t\treturn authDAO.getResetPasswordFailures(ipAddress) >= MAX_RESET_ATTEMPTS;\n\t}\n\n\t/**\n\t * Checks if the given mid matches the given role\n\t * \n\t * @param mid\n\t *            the mid to be checked\n\t * @param role\n\t *            the role to be checked\n\t * @return true if the mid and role match\n\t * @throws iTrustException\n\t */\n\tpublic String checkRole(long mid, String role) throws iTrustException {\n\t\ttry {\n\t\t\tif ((\"patient\".equals(role) && patientDAO.getRole(mid, role).equals(\"patient\"))\n\t\t\t\t\t|| (\"hcp\".equals(role) && patientDAO.getRole(mid, role).equals(\"hcp\"))\n\t\t\t\t\t|| (\"uap\".equals(role) && patientDAO.getRole(mid, role).equals(\"uap\"))\n\t\t\t\t\t|| (\"pha\".equals(role) && patientDAO.getRole(mid, role).equals(\"pha\"))\n\t\t\t\t\t|| (\"er\".equals(role) && patientDAO.getRole(mid, role).equals(\"er\")))\n\t\t\t\treturn role;\n\t\t\telse\n\t\t\t\treturn null;\n\t\t} catch (DBException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (iTrustException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow e;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Checks if the answer param is null\n\t * \n\t * @param answer the user's security answer\n\t * @return answer if not null, else return null\n\t */\n\tpublic String checkAnswerNull(String answer) {\n\t\tif (answer == null || \"\".equals(answer))\n\t\t\treturn null;\n\t\telse\n\t\t\treturn answer;\n\t}\n\n\t/**\n\t * Returns the security question for the mid param\n\t * \n\t * @param mid MID of the user\n\t * @return the security question or \"\" if DBException thrown\n\t * @throws iTrustException\n\t */\n\tpublic String getSecurityQuestion(long mid) throws iTrustException {\n\t\ttry {\n\t\t\tif (null == authDAO.getSecurityQuestion(mid) || authDAO.getSecurityQuestion(mid).equals(\"\"))\n\t\t\t\tthrow new iTrustException(\"No security question or answer for this user has been set.\");\n\t\t\telse\n\t\t\t\treturn authDAO.getSecurityQuestion(mid);\n\t\t} catch (DBException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn \"\";\n\t\t}\n\t}\n\n\t/**\n\t * Resets the password for the given mid\n\t * \n\t * @param mid of the user to have their password reset\n\t * @param role what role the user has in iTrust\n\t * @param answer answers to their security question\n\t * @param password their password\n\t * @param confirmPassword their password again\n\t * @param ipAddr the ip address the request is coming from\n\t * @return status message\n\t * @throws FormValidationException\n\t * @throws DBException\n\t * @throws iTrustException\n\t */\n\tpublic String resetPassword(long mid, String role, String answer, String password,\n\t\t\tString confirmPassword, String ipAddr) throws FormValidationException, DBException,\n\t\t\tiTrustException {\n\n\t\tRole r = authDAO.getUserRole(mid);\n\t\ttry {\n\t\t\tRole.parse(role);\n\t\t} catch (IllegalArgumentException e) {\n\t\t\treturn \"Invalid role\";\n\t\t}\n\n\t\tif (r.equals(Role.ADMIN))\n\t\t\treturn \"This role cannot be changed here\";\n\t\tif (!r.equals(Role.parse(role)))\n\t\t\treturn \"Role mismatch\";\n\n\t\tif (authDAO.getResetPasswordFailures(ipAddr) >= MAX_RESET_ATTEMPTS) {\n\t\t\treturn \"Too many retries\";\n\t\t}\n\n\t\ttry {\n\t\t\tvalidatePassword(password, confirmPassword);\n\n\t\t\tif (answer.equals(authDAO.getSecurityAnswer(mid))) {\n\t\t\t\tauthDAO.resetPassword(mid, password);\n\t\t\t\tnew EmailUtil(factory).sendEmail(makeEmailApp(mid, role));\n\t\t\t\treturn \"Password changed\";\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tauthDAO.recordResetPasswordFailure(ipAddr);\n\t\t\t\treturn \"Answer did not match\";\n\t\t\t}\n\n\t\t} catch (DBException e) {\n\t\t\treturn \"Error in validation of security answer\";\n\t\t}\n\t}\n\t\n\t/**\n\t * Creates and sends an e-mail about the change\n\t * \n\t * @param mid the user who's password was changed\n\t * @param role what role they have in iTrust\n\t * @return the e-mial that is sent\n\t * @throws DBException\n\t */\n\tprivate Email makeEmailApp(long mid, String role) throws DBException{\n\t\t\n\t\tif(Role.parse(role) == Role.PATIENT){\n\t\t\tPatientBean p = new PatientDAO(factory).getPatient(mid);\n\t\t\tEmail email = new Email();\n\t\t\temail.setFrom(\"no-reply@itrust.com\");\n\t\t\temail.setToList(Arrays.asList(p.getEmail()));\n\t\t\temail.setSubject(\"Your password has been changed in iTrust\");\n\t\t\temail.setBody(String.format(\"Dear %s, \\n You have chosen to change your iTrust password for user %s\", p.getFullName(), mid));\n\n\t\t\treturn email;\n\t\t}\n\t\telse{ //UAP or HCP - admin taken out in \"resetPassword\"\n\t\t\tPersonnelBean p = new PersonnelDAO(factory).getPersonnel(mid);\n\t\t\tEmail email = new Email();\n\t\t\temail.setFrom(\"no-reply@itrust.com\");\n\t\t\temail.setToList(Arrays.asList(p.getEmail()));\n\t\t\temail.setSubject(\"Your password has been changed in iTrust\");\n\t\t\temail.setBody(String.format(\"Dear %s, \\n You have chosen to change your iTrust password for user %s\", p.getFullName(), mid));\n\n\t\t\treturn email;\n\t\t}\n\t}\n\t\n\t/**\n\t * Checks to make sure the password is correctly entered twice.\n\t * \n\t * @param password the password\n\t * @param confirmPassword the password again for confirmation\n\t * @throws FormValidationException\n\t */\n\n\tprivate void validatePassword(String password, String confirmPassword) throws FormValidationException {\n\t\tErrorList errorList = new ErrorList();\n\t\tif (password == null || \"\".equals(password)) {\n\t\t\terrorList.addIfNotNull(\"Password cannot be empty\");\n\t\t} else {\n\t\t\tif (!password.equals(confirmPassword))\n\t\t\t\terrorList.addIfNotNull(\"Passwords don't match\");\n\t\t\tif (!ValidationFormat.PASSWORD.getRegex().matcher(password).matches()) {\n\t\t\t\terrorList.addIfNotNull(\"Password must be in the following format: \"\n\t\t\t\t\t\t+ ValidationFormat.PASSWORD.getDescription());\n\t\t\t}\n\t\t}\n\t\tif (errorList.hasErrors())\n\t\t\tthrow new FormValidationException(errorList);\n\t}\n}", "SearchUsersAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.PatientBean;\nimport edu.ncsu.csc.itrust.beans.PersonnelBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.PatientDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;\nimport edu.ncsu.csc.itrust.exception.DBException;\n\n\npublic class SearchUsersAction {\n\tprivate PatientDAO patientDAO;\n\tprivate PersonnelDAO personnelDAO;\n\n\n\t/**\n\t * Set up defaults\n\t * \n\t * @param factory The DAOFactory used to create the DAOs used in this action.\n\t * @param loggedInMID The MID of the user who is performing the search.\n\t */\n\tpublic SearchUsersAction(DAOFactory factory, long loggedInMID) {\n\t\tthis.patientDAO = factory.getPatientDAO();\n\t\tthis.personnelDAO = factory.getPersonnelDAO();\n\t}\n\t\n\n\t/**\n\t * Searches for all personnel with the first name and last name specified in the parameter list.\n\t * @param firstName The first name to be searched.\n\t * @param lastName The last name to be searched.\n\t * @return A java.util.List of PersonnelBeans for the users who matched.\n\t */\n\tpublic List<PersonnelBean> searchForPersonnelWithName(String firstName, String lastName) {\n\t\t\n\t\ttry {\t\n\t\t\tif(\"\".equals(firstName))\n\t\t\t\tfirstName = \"%\";\n\t\t\tif(\"\".equals(lastName))\n\t\t\t\tlastName = \"%\";\n\t\t\treturn personnelDAO.searchForPersonnelWithName(firstName, lastName);\n\t\t}\n\t\tcatch (DBException e) {\n\t\t\tSystem.out.println(\"DB Exception from SearchUsersAction\");\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\t/**\n\t * Search for all patients with first name and last name given in parameters.\n\t * @param firstName The first name of the patient being searched.\n\t * @param lastName The last name of the patient being searched.\n\t * @return A java.util.List of PatientBeans\n\t */\n\tpublic List<PatientBean> searchForPatientsWithName(String firstName, String lastName) {\n\t\n\t\ttry {\t\n\t\t\tif(\"\".equals(firstName))\n\t\t\t\tfirstName = \"%\";\n\t\t\tif(\"\".equals(lastName))\n\t\t\t\tlastName = \"%\";\n\t\t\treturn patientDAO.searchForPatientsWithName(firstName, lastName);\n\t\t}\n\t\tcatch (DBException e) {\n\t\t\tSystem.out.println(\"DB Exception from SearchUsersAction\");\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}\n}", "SendMessageAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.EmailUtil;\nimport edu.ncsu.csc.itrust.beans.Email;\nimport edu.ncsu.csc.itrust.beans.MessageBean;\nimport edu.ncsu.csc.itrust.beans.PatientBean;\nimport edu.ncsu.csc.itrust.beans.PersonnelBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.MessageDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.PatientDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\nimport edu.ncsu.csc.itrust.validate.EMailValidator;\nimport edu.ncsu.csc.itrust.validate.MessageValidator;\n\n\n/**\n * Class for SendMessage.jsp.  \n *\n */\n\npublic class SendMessageAction {\n\tprivate long loggedInMID;\n\tprivate EmailUtil emailer;\n\tprivate PatientDAO patientDAO;\n\tprivate PersonnelDAO personnelDAO;\n\tprivate MessageDAO messageDAO;\n\tprivate TransactionDAO transactionDAO;\n\tprivate EMailValidator emailVal;\n\tprivate MessageValidator messVal;\n\n\n\t/**\n\t * Sets up defaults\n\t * @param factory The DAOFactory used to create the DAOs used in this action.\n\t * @param loggedInMID The MID of the user sending the message.\n\t */\n\tpublic SendMessageAction(DAOFactory factory, long loggedInMID) {\n\t\tthis.loggedInMID = loggedInMID;\n\t\tthis.patientDAO = factory.getPatientDAO();\n\t\tthis.personnelDAO = factory.getPersonnelDAO();\n\t\tthis.emailer = new EmailUtil(factory);\n\t\tthis.messageDAO = factory.getMessageDAO();\n\t\tthis.transactionDAO = factory.getTransactionDAO();\n\t\tthis.emailVal = new EMailValidator();\n\t\tthis.messVal = new MessageValidator();\n\t}\n\t\n\t/**\n\t * Sends a message\n\t * \n\t * @param mBean message to be sent\n\t * @throws iTrustException\n\t * @throws SQLException\n\t */\n\tpublic void sendMessage(MessageBean mBean) throws iTrustException, SQLException, FormValidationException {\n\t\tmessVal.validate(mBean);\n\t\temailVal.validate(mBean);\n\t\tmessageDAO.addMessage(mBean);\n\t\t\n\t\tEmail email = new Email();\n\t\tString senderName;\n\t\tString fromEmail;\n\t\temail.setFrom(\"noreply@itrust.com\");\n\t\tList<String> toList = new ArrayList<String>();\n\t\tif (8999999999L < mBean.getFrom() && 8999999999L < mBean.getTo()){\n\t\t\tPersonnelBean sender = personnelDAO.getPersonnel(loggedInMID);\n\t\t\tPersonnelBean receiver = personnelDAO.getPersonnel(mBean.getTo());\n\t\t\t\n\t\t\ttoList.add(receiver.getEmail());\n\t\t\tsenderName = sender.getFullName();\n\t\t\tfromEmail = sender.getEmail();\n\t\t}else{\n\t\t\tif (6999999999L < mBean.getFrom()) {\n\t\t\t\tPersonnelBean sender = personnelDAO.getPersonnel(loggedInMID);\n\t\t\t\t\n\t\t\t\tif (6999999999L < mBean.getTo()) {\n\t\t\t\t\tPersonnelBean receiver = personnelDAO.getPersonnel(mBean.getTo());\n\t\t\t\t\ttoList.add(receiver.getEmail());\n\t\t\t\t} else {\n\t\t\t\t\tPatientBean receiver = patientDAO.getPatient(mBean.getTo());\n\t\t\t\t\ttoList.add(receiver.getEmail());\n\t\t\t\t}\n\t\t\t\tsenderName = sender.getFullName();\n\t\t\t\tfromEmail = sender.getEmail();\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tPatientBean sender = patientDAO.getPatient(loggedInMID);\n\t\t\t\t\n\t\t\t\tif (6999999999L < mBean.getTo()) {\n\t\t\t\t\tPersonnelBean receiver = personnelDAO.getPersonnel(mBean.getTo());\n\t\t\t\t\ttoList.add(receiver.getEmail());\n\t\t\t\t} else {\n\t\t\t\t\tPatientBean receiver = patientDAO.getPatient(mBean.getTo());\n\t\t\t\t\ttoList.add(receiver.getEmail());\n\t\t\t\t}\n\t\t\t\tsenderName = sender.getFullName();\n\t\t\t\tfromEmail = sender.getEmail();\n\t\t\t}\n\t\t}\n\t\temail.setToList(toList);\n\t\temail.setFrom(fromEmail);\n\t\temail.setSubject(String.format(\"A new message from %s\", senderName));\n\t\temail.setBody(String.format(\"You have received a new message from %s in iTrust. To view it, log in to iTrust and go to \\\"View My Messages\\\"\", senderName));\n\t\temailer.sendEmail(email);\n\t\t\n\t\ttransactionDAO.logTransaction(TransactionType.SEND_MESSAGE, loggedInMID);\n\t}\n\t\n\t/**\n\t * Returns the patient's name\n\t * \n\t * @param mid MId of the patient\n\t * @return the name of the patient\n\t * @throws iTrustException\n\t */\n\tpublic String getPatientName(long mid) throws iTrustException {\n\t\treturn patientDAO.getName(mid);\n\t}\n\t\n\t/**\n\t * Returns the personnel's name\n\t * \n\t * @param mid MId of the personnel\n\t * @return the name of the personnel\n\t * @throws iTrustException\n\t */\n\tpublic String getPersonnelName(long mid) throws iTrustException {\n\t\treturn personnelDAO.getName(mid);\n\t}\n\t\n\t/**\n\t * Returns a list of the patients that the logged in HCP represents\n\t * \n\t * @return list of the patients that the logged in HCP represents\n\t * @throws iTrustException\n\t */\n\tpublic List<PatientBean> getMyRepresentees() throws iTrustException {\n\t\tList<PatientBean> representees = new ArrayList<PatientBean>();\n\t\ttry {\n\t\t\trepresentees = patientDAO.getRepresented(loggedInMID);\n\t\t} catch (DBException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn representees;\n\t}\n\t\n\t/**\n\t * Returns the designated HCPs for the logged in patient.\n\t * \n\t * @return designated HCPs for the logged in patient.\n\t * @throws iTrustException\n\t */\n\tpublic List<PersonnelBean> getMyDLHCPs() throws iTrustException {\n\t\treturn getDLHCPsFor(loggedInMID);\n\t}\n\t\n\t/**\n\t * Returns the designated HCPs for the given patient.\n\t * \n\t * @return designated HCPs for the given patient.\n\t * @throws iTrustException\n\t */\n\tpublic List<PersonnelBean> getDLHCPsFor(long pid) throws iTrustException {\n\t\tList<PersonnelBean> dlhcps = new ArrayList<PersonnelBean>();\n\t\ttry {\n\t\t\tdlhcps = patientDAO.getDeclaredHCPs(pid);\n\t\t} catch (DBException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn dlhcps;\t\t\n\t}\n}", "SetSecurityQuestionAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport edu.ncsu.csc.itrust.beans.SecurityQA;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.AuthDAO;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\nimport edu.ncsu.csc.itrust.validate.SecurityQAValidator;\n\n/**\n * Handles setting and retrieving the security questions/answers for users Used by\n * patient/editMyDemographics.jsp, staff/editMyDemographics.jsp, staff/editPersonnell.jsp\n * \n * @author laurenhayward\n * \n */\npublic class SetSecurityQuestionAction {\n\n\tprivate AuthDAO authDAO;\n\tprivate long loggedInMID;\n\n\t/**\n\t * Sets up defaults\n\t * \n\t * @param factory The DAOFactory used to create the DAOs used in this action.\n\t * @param rLoggedInMID The MID of the user who is setting their security question.\n\t * @throws iTrustException\n\t */\n\tpublic SetSecurityQuestionAction(DAOFactory factory, long rLoggedInMID) throws iTrustException {\n\t\tthis.authDAO = factory.getAuthDAO();\n\t\tloggedInMID = checkMID(rLoggedInMID);\n\t}\n\n\t/**\n\t * Updates information in the database from the information held in the SecurityQA bean passed as a param\n\t * \n\t * @param a\n\t *            SecurityQuestionBean that holds new information\n\t * @throws Exception\n\t */\n\tpublic void updateInformation(SecurityQA a) throws Exception {\n\t\tSecurityQAValidator sqav = new SecurityQAValidator();\n\t\tsqav.validate(a);\n\t\tauthDAO.setSecurityQuestionAnswer(a.getQuestion(), a.getAnswer(), loggedInMID);\n\t}\n\n\t/**\n\t * Returns a SecurityQA bean holding the security info for the currently logged in user\n\t * \n\t * @return SecurityQA for loggedInMid\n\t * @throws iTrustException\n\t */\n\tpublic SecurityQA retrieveInformation() throws iTrustException {\n\t\tSecurityQA toRet = new SecurityQA();\n\t\ttoRet.setAnswer(authDAO.getSecurityAnswer(loggedInMID));\n\t\ttoRet.setQuestion(authDAO.getSecurityQuestion(loggedInMID));\n\t\treturn toRet;\n\t}\n\t/**\n\t * Checks to make sure the MID exists in iTrust\n\t * \n\t * @param mid MID to check\n\t * @return returns the MID if the user is valid, otherwise, throws an exception\n\t * @throws iTrustException\n\t */\n\n\tprivate long checkMID(long mid) throws iTrustException {\n\t\tif (!authDAO.checkUserExists(mid))\n\t\t\tthrow new iTrustException(\"MID \" + mid + \" is not a user!\");\n\t\treturn mid;\n\t}\n\n}", "SurveyAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport java.util.Calendar;\nimport edu.ncsu.csc.itrust.beans.SurveyBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.SurveyDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.DBException;\n\n/**\n * This class is used to add patient survey data to the database.  The office visit ID is linked with the survey ID.  Once the\n * survey is added, the transaction is logged\n *\n */\npublic class SurveyAction {\n\tprivate TransactionDAO transDAO;\n\tprivate SurveyDAO surveyDAO;\n\tlong loggedInMID;\n\t\n\t/**\n\t * Sets up defaults\n\t * @param factory The DAOFactory used to create the DAOs used in this action.\n\t * @param loggedInMID The MID of the user taking the survey.\n\t */\n\tpublic SurveyAction(DAOFactory factory, long loggedInMID) {\n\t\ttransDAO = factory.getTransactionDAO();\n\t\tsurveyDAO = factory.getSurveyDAO();\n\t\tthis.loggedInMID = loggedInMID;\n\t}\n\n\n\t/**\n\t * Pass the OfficeVistBean along with SurveyBean\n\t * @param surveyBean contains data to be added to database\n\t * @param visitID The Office Visit ID corresponding to this Survey.\n\t * @throws DBException\n\t */\n\tpublic void addSurvey(SurveyBean surveyBean, long visitID) throws DBException {\n\t\t\n\t\tsurveyBean.setVisitID(visitID); //now set visit ID in the survey bean\n\t\tsurveyDAO.addCompletedSurvey(surveyBean, Calendar.getInstance().getTime());\n\t\t//add to transaction log\n\t\ttransDAO.logTransaction(TransactionType.ADD_PATIENT_SURVEY, loggedInMID, 0L, \"office visit ID for completed survey is: \" + visitID);\n\t\t\n\t}\n}", "UpdateCPTCodeListAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport edu.ncsu.csc.itrust.beans.ProcedureBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.CPTCodesDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\nimport edu.ncsu.csc.itrust.validate.ProcedureBeanValidator;\n\n/**\n * Updates the CPT Code (Medical Procedures) List Used by editCPTProcedureCodes.jsp\n * \n * The CPT code set accurately describes medical, surgical, and diagnostic services \n * and is designed to communicate uniform information about medical services and procedures \n * among physicians, coders, patients, accreditation organizations, and payers for administrative, \n * financial, and analytical purposes.\n *\n * @see http://www.ama-assn.org/ama/pub/physician-resources/solutions-managing-your-practice/coding-billing-insurance/cpt/about-cpt.shtml\n * @author laurenhayward\n */\npublic class UpdateCPTCodeListAction {\n\tprivate long loggedInMID;\n\tprivate TransactionDAO transDAO;\n\tprivate CPTCodesDAO cptDAO;\n\tprivate ProcedureBeanValidator validator = new ProcedureBeanValidator();\n\n\t/**\n\t * \n\t * @param factory The DAOFactory used to create the DAOs used in this action.\n\t * @param loggedInMID The MID of the administrator who is updating the CPTs.\n\t */\n\tpublic UpdateCPTCodeListAction(DAOFactory factory, long loggedInMID) {\n\t\tthis.loggedInMID = loggedInMID;\n\t\tthis.transDAO = factory.getTransactionDAO();\n\t\tthis.cptDAO = factory.getCPTCodesDAO();\n\t}\n\n\t/**\n\t * Adds a new cpt code (med procedure)\n\t * \n\t * @param proc\n\t *            ProcedureBean that holds the new cpt code\n\t * @return status message\n\t * @throws FormValidationException\n\t */\n\tpublic String addCPTCode(ProcedureBean proc) throws FormValidationException {\n\t\tvalidator.validate(proc);\n\t\ttry {\n\t\t\tif (cptDAO.addCPTCode(proc)) {\n\t\t\t\ttransDAO.logTransaction(TransactionType.MANAGE_PROCEDURE_CODE, loggedInMID, 0L,\n\t\t\t\t\t\t\"added CPT code \" + proc.getCPTCode());\n\t\t\t\treturn \"Success: \" + proc.getCPTCode() + \" - \" + proc.getDescription() + \" added\";\n\t\t\t} else\n\t\t\t\treturn \"The database has become corrupt. Please contact the system administrator for assistance.\";\n\t\t} catch (DBException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn e.getMessage();\n\t\t} catch (iTrustException e) {\n\t\t\treturn e.getMessage();\n\t\t}\n\t}\n\n\t/**\n\t * Updates a procedure with new information from the ProcedureBean\n\t * \n\t * @param proc\n\t *            ProcedureBean with new information (but same CPT code)\n\t * @return Status message\n\t * @throws FormValidationException\n\t */\n\tpublic String updateInformation(ProcedureBean proc) throws FormValidationException {\n\t\tvalidator.validate(proc);\n\t\ttry {\n\t\t\tint rows = updateCode(proc);\n\t\t\tif (0 == rows) {\n\t\t\t\treturn \"Error: Code not found. To edit an actual code, \"\n\t\t\t\t\t\t+ \"change the description and add a new code with the old description\";\n\t\t\t} else {\n\t\t\t\ttransDAO.logTransaction(TransactionType.MANAGE_PROCEDURE_CODE, loggedInMID, 0L,\n\t\t\t\t\t\t\"updated CPT code \" + proc.getCPTCode());\n\t\t\t\treturn \"Success: \" + rows + \" row(s) updated\";\n\t\t\t}\n\t\t} catch (DBException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn e.getMessage();\n\t\t}\n\t}\n\n\t/**\n\t * Updates the cpt code\n\t * \n\t * @param proc the code to be updated\n\t * @return updated code\n\t * @throws DBException\n\t */\n\tprivate int updateCode(ProcedureBean proc) throws DBException {\n\t\treturn cptDAO.updateCode(proc);\n\t}\n}", "UpdateHospitalListAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport edu.ncsu.csc.itrust.beans.HospitalBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.HospitalsDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\nimport edu.ncsu.csc.itrust.validate.HospitalBeanValidator;\n\n/**\n * Handles updating the list of hospitals Used by hospitalListing.jsp\n * \n * @author laurenhayward\n * \n */\npublic class UpdateHospitalListAction {\n\tprivate long performerID;\n\tprivate HospitalsDAO hospDAO;\n\tprivate TransactionDAO transDAO;\n\n\t/**\n\t * Set up\n\t * \n\t * @param factory The DAOFactory used to create the DAOs used in this action.\n\t * @param performerID The MID of the person updating the hospitals.\n\t */\n\tpublic UpdateHospitalListAction(DAOFactory factory, long performerID) {\n\t\tthis.hospDAO = factory.getHospitalsDAO();\n\t\tthis.transDAO = factory.getTransactionDAO();\n\t\tthis.performerID = performerID;\n\t}\n\n\t/**\n\t * Adds a hosptial using the HospitalBean passed as a param\n\t * \n\t * @param hosp\n\t *            the new hospital listing\n\t * @return Status message\n\t * @throws FormValidationException\n\t */\n\tpublic String addHospital(HospitalBean hosp) throws FormValidationException {\n\t\tnew HospitalBeanValidator().validate(hosp);\n\t\ttry {\n\t\t\tif (hospDAO.addHospital(hosp)) {\n\t\t\t\ttransDAO.logTransaction(TransactionType.MAINTAIN_HOSPITALS, performerID, 0L,\n\t\t\t\t\t\t\"added hospital \" + hosp.getHospitalName());\n\t\t\t\treturn \"Success: \" + hosp.getHospitalID() + \" - \" + hosp.getHospitalName() + \" added\";\n\t\t\t} else\n\t\t\t\treturn \"The database has become corrupt. Please contact the system administrator for assistance.\";\n\t\t} catch (DBException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn e.getMessage();\n\t\t} catch (iTrustException e) {\n\t\t\treturn e.getMessage();\n\t\t}\n\t}\n\n\t/**\n\t * Updates a hospital (based on the hospital id) using new information from the HospitalBean passed as a\n\t * param\n\t * \n\t * @param hosp\n\t *            the new hospital information with the same hospital id\n\t * @return Status message\n\t * @throws FormValidationException\n\t */\n\tpublic String updateInformation(HospitalBean hosp) throws FormValidationException {\n\t\tnew HospitalBeanValidator().validate(hosp);\n\t\ttry {\n\t\t\tint rows = 0;\n\t\t\treturn ((0 == (rows = updateHospital(hosp))) ? \"Error: Hospital not found.\" : \"Success: \" + rows\n\t\t\t\t\t+ \" row(s) updated\");\n\t\t} catch (DBException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn e.getMessage();\n\t\t}\n\t}\n\n\t/**\n\t * Updates hospital\n\t * \n\t * @param hosp new information\n\t * @return id for the updated hospital\n\t * @throws DBException\n\t */\n\tprivate int updateHospital(HospitalBean hosp) throws DBException {\n\t\treturn hospDAO.updateHospital(hosp);\n\t}\n}", "UpdateICDCodeListAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport edu.ncsu.csc.itrust.beans.DiagnosisBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.ICDCodesDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\nimport edu.ncsu.csc.itrust.validate.DiagnosisBeanValidator;\n\n/**\n * Handles updating the ICD Code (Diagnosis) List Used by editICDCodes.jsp\n * \n * The International Statistical Classification of Diseases and Related Health Problems \n * (most commonly known by the abbreviation ICD) provides codes to classify diseases and a \n * wide variety of signs, symptoms, abnormal findings, complaints, social circumstances and \n * external causes of injury or disease. \n * \n * @see http://www.cdc.gov/nchs/icd9.htm\n * @author laurenhayward\n * \n */\npublic class UpdateICDCodeListAction {\n\tprivate long performerID = 0;\n\tprivate ICDCodesDAO icdDAO;\n\tprivate TransactionDAO transDAO;\n\tprivate DiagnosisBeanValidator validator = new DiagnosisBeanValidator();\n\n\t/**\n\t * Set up\n\t * \n\t * @param factory The DAOFactory used to create the DAOs used in this action.\n\t * @param performerID The MID of the person udpating the ICDs.\n\t */\n\tpublic UpdateICDCodeListAction(DAOFactory factory, long performerID) {\n\t\tthis.performerID = performerID;\n\t\ttransDAO = factory.getTransactionDAO();\n\t\ticdDAO = factory.getICDCodesDAO();\n\t}\n\n\t/**\n\t * Adds a new ICD code (diagnosis) based on the DiagnosisBean passed as a param\n\t * \n\t * @param diagn\n\t *            The new diagnosis (ICD code)\n\t * @return Status message\n\t * @throws FormValidationException\n\t */\n\tpublic String addICDCode(DiagnosisBean diagn) throws FormValidationException {\n\t\tvalidator.validate(diagn);\n\t\ttry {\n\t\t\tif (icdDAO.addICDCode(diagn)) {\n\t\t\t\ttransDAO.logTransaction(TransactionType.MANAGE_DIAGNOSIS_CODE, performerID, 0L,\n\t\t\t\t\t\t\"added ICD code \" + diagn.getICDCode());\n\t\t\t\treturn \"Success: \" + diagn.getICDCode() + \" - \" + diagn.getDescription() + \" added\";\n\t\t\t} else\n\t\t\t\treturn \"The database has become corrupt. Please contact the system administrator for assistance.\";\n\t\t} catch (DBException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn e.getMessage();\n\t\t} catch (iTrustException e) {\n\t\t\treturn e.getMessage();\n\t\t}\n\t}\n\n\t/**\n\t * Updates a diagnosis with new information from the DiagnosisBean passed as a param\n\t * \n\t * @param diagn\n\t *            new information to update (but same code)\n\t * @return Status message\n\t * @throws FormValidationException\n\t */\n\tpublic String updateInformation(DiagnosisBean diagn) throws FormValidationException {\n\t\tvalidator.validate(diagn);\n\t\ttry {\n\t\t\tint rows = icdDAO.updateCode(diagn);\n\t\t\tif (0 == rows) {\n\t\t\t\treturn \"Error: Code not found.\";\n\t\t\t} else {\n\t\t\t\ttransDAO.logTransaction(TransactionType.MANAGE_DIAGNOSIS_CODE, performerID, 0L,\n\t\t\t\t\t\t\"updated ICD code \" + diagn.getICDCode());\n\t\t\t\treturn \"Success: \" + rows + \" row(s) updated\";\n\t\t\t}\n\t\t} catch (DBException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn e.getMessage();\n\t\t}\n\t}\n\n}", "UpdateLOINCListAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.LOINCbean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.LOINCDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\nimport edu.ncsu.csc.itrust.validate.LOINCBeanValidator;\n\n/**\n * Handles updating the LOINC Used.\n * \n * Logical Observation Identifiers Names and Codes (LOINC) is a database and universal\n *  standard for identifying medical laboratory observations. \n *  \n * @see http://loinc.org/\n */\npublic class UpdateLOINCListAction {\n\tprivate long performerID = 0;\n\tprivate LOINCDAO lDAO;\n\tprivate TransactionDAO transDAO;\n\tprivate LOINCBeanValidator validator = new LOINCBeanValidator();\n\n\t/**\n\t * Sets up defaults\n\t * \n\t * @param factory The DAOFactory used to create the DAOs used in this action.\n\t * @param performerID The MID of the person updating the LOINCs.\n\t */\n\tpublic UpdateLOINCListAction(DAOFactory factory, long performerID) {\n\t\tthis.performerID = performerID;\n\t\ttransDAO = factory.getTransactionDAO();\n\t\tlDAO = factory.getLOINCDAO();\n\t}\n\n\t/**\n\t * Adds a new LOINC\n\t * \n\t * @param diagn\n\t *            New LOINC\n\t * @return Status message\n\t * @throws FormValidationException\n\t */\n\tpublic String add(LOINCbean diagn) throws FormValidationException, iTrustException {\n\t\tvalidator.validate(diagn);\n\n\t\tList<LOINCbean> lblist = lDAO.getAllLOINC();\n\n\t\tboolean correctID = false;\n\t\tfor (int i = 0; i < lblist.size(); i++) {\n\t\t\tif (lblist.get(i).getLabProcedureCode().equals(diagn.getLabProcedureCode())) {\n\t\t\t\tcorrectID = true;\n\t\t\t\ti = lblist.size();\n\t\t\t}\n\t\t}\n\t\tif (correctID) {\n\t\t\tthrow new FormValidationException(\"Error: Code already exists.\");\n\t\t}\n\t\tlDAO.addLOINC(diagn);\n\t\ttransDAO.logTransaction(TransactionType.MANAGE_LOINC, performerID, 0L, \"added LOINC code \"\n\t\t\t\t+ diagn.getLabProcedureCode());\n\t\treturn \"Success: \" + diagn.getLabProcedureCode() + \" added\";\n\t}\n\n\t/**\n\t * Updates a LOINC\n\t * \n\t * @param diagn\n\t *            new information to update (but same code)\n\t * @return Status message\n\t * @throws FormValidationException\n\t */\n\tpublic String updateInformation(LOINCbean diagn) throws FormValidationException {\n\t\tvalidator.validate(diagn);\n\t\ttry {\n\t\t\tint rows = lDAO.update(diagn);\n\t\t\tif (0 == rows) {\n\t\t\t\treturn \"Error: Code not found.\";\n\t\t\t} else {\n\t\t\t\ttransDAO.logTransaction(TransactionType.MANAGE_LOINC, performerID, 0L, \"updated LOINC code \"\n\t\t\t\t\t\t+ diagn.getLabProcedureCode());\n\t\t\t\treturn \"Success: \" + diagn.getLabProcedureCode() + \" updated\";\n\t\t\t}\n\t\t} catch (DBException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn e.getMessage();\n\t\t}\n\t}\n\n}", "UpdateNDCodeListAction.java": "package edu.ncsu.csc.itrust.action;\n\nimport edu.ncsu.csc.itrust.beans.MedicationBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.NDCodesDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\nimport edu.ncsu.csc.itrust.validate.MedicationBeanValidator;\n\n/**\n * Handles updating the ND Code (Prescription) List Used by editNDCodes.jsp\n * \n * The National Drug Code (NDC) is a universal product identifier used in the\n * United States for drugs intended for human use.\n * \n * @see http://www.fda.gov/Drugs/InformationOnDrugs/ucm142438.htm\n * @author laurenhayward\n */\npublic class UpdateNDCodeListAction {\n\tprivate long performerID = 0;\n\tprivate TransactionDAO transDAO;\n\tprivate NDCodesDAO ndDAO;\n\tprivate MedicationBeanValidator validator = new MedicationBeanValidator();\n\n\t/**\n\t * Set up defaults.\n\t * \n\t * @param factory The DAOFactory used to create the DAOs used in this action.\n\t * @param performerID The MID of the user updating the ND lists.\n\t */\n\tpublic UpdateNDCodeListAction(DAOFactory factory, long performerID) {\n\t\tthis.performerID = performerID;\n\t\tndDAO = factory.getNDCodesDAO();\n\t\ttransDAO = factory.getTransactionDAO();\n\t}\n\n\t/**\n\t * Adds a new ND Code (prescription) to the list\n\t * \n\t * @param med\n\t *            The new ND Code to be added\n\t * @return Status message\n\t * @throws FormValidationException\n\t */\n\tpublic String addNDCode(MedicationBean med) throws FormValidationException {\n\t\tvalidator.validate(med);\n\t\ttry {\n\t\t\tif (ndDAO.addNDCode(med)) {\n\t\t\t\ttransDAO.logTransaction(TransactionType.MANAGE_DRUG_CODE, performerID, 0L, \"added ND code \"\n\t\t\t\t\t\t+ med.getNDCode());\n\t\t\t\treturn \"Success: \" + med.getNDCode() + \" - \" + med.getDescription() + \" added\";\n\t\t\t} else\n\t\t\t\treturn \"The database has become corrupt. Please contact the system administrator for assistance.\";\n\t\t} catch (DBException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn e.getMessage();\n\t\t} catch (iTrustException e) {\n\t\t\treturn e.getMessage();\n\t\t}\n\t}\n\n\t/**\n\t * Updates the ND Code with new information from the MedicationBean\n\t * \n\t * @param med\n\t *            the MedicationBean that holds new information but the same code\n\t * @return status message\n\t * @throws FormValidationException\n\t */\n\tpublic String updateInformation(MedicationBean med) throws FormValidationException {\n\t\tvalidator.validate(med);\n\t\ttry {\n\t\t\tint rows = updateCode(med);\n\t\t\tif (0 == rows) {\n\t\t\t\treturn \"Error: Code not found.\";\n\t\t\t} else {\n\t\t\t\ttransDAO.logTransaction(TransactionType.MANAGE_DRUG_CODE, performerID, 0L, \"updated ND code \"\n\t\t\t\t\t\t+ med.getNDCode());\n\t\t\t\treturn \"Success: \" + rows + \" row(s) updated\";\n\t\t\t}\n\t\t} catch (DBException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn e.getMessage();\n\t\t}\n\t}\n\n\t/**\n\t * Medication information should already be validated\n\t * \n\t * @param med\n\t * @return\n\t * @throws DBException\n\t */\n\tprivate int updateCode(MedicationBean med) throws DBException {\n\t\treturn ndDAO.updateCode(med);\n\t}\n\n}", "OfficeVisitBaseAction.java": "package edu.ncsu.csc.itrust.action.base;\n\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.OfficeVisitDAO;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\n\n/**\n * An abstract class which contains functionalities common among all actions relating to inserting and editing\n * office visits. Because all office visits are with a certain patient, OfficeVisitBaseAction extends\n * PatientBaseAction.\n * \n * Use this class whenever you have a page which not only requires a patient MID, but an office visit ID. Pass\n * those IDs to the constructor, and an exception will be thrown if they are not valid IDs (which should kick\n * the user out to the home page).\n * \n * The concrete methods created by this class allow for its association with the unique identifier of a given\n * office visit. These identifiers can also be verified for their correctness and existence.\n * \n * Very similar to {@link PatientBaseAction} and {@link PersonnelBaseAction}\n */\nabstract public class OfficeVisitBaseAction extends PatientBaseAction {\n\n\t/**\n\t * A database access object for dealing with office visits.\n\t */\n\tprivate OfficeVisitDAO ovDAO;\n\n\t/**\n\t * The unique identifier of the office visit this action is associated with.\n\t */\n\tprotected long ovID;\n\n\t/**\n\t * The default constructor.\n\t * \n\t * @param factory\n\t *            A database access object factory for supplying a runtime context.\n\t * @param pidString\n\t *            The patient's MID as a String, to be passed to the super constructor (for PatientBaseAction)\n\t * @param ovIDString\n\t *            The unique identifier of the office visit as a String.\n\t * @throws iTrustException\n\t *             If any of the supplied parameters is incorrect or there is a DB problem.\n\t */\n\tpublic OfficeVisitBaseAction(DAOFactory factory, String pidString, String ovIDString)\n\t\t\tthrows iTrustException {\n\t\tsuper(factory, pidString);\n\t\tthis.ovDAO = factory.getOfficeVisitDAO();\n\t\tthis.ovID = checkOfficeVisitID(ovIDString);\n\t}\n\n\t/**\n\t * Asserts whether this unique office visit identifier both exists and is associated with the patient in\n\t * the database.\n\t * \n\t * @param input\n\t *            The presumed identifier as a String.\n\t * @return The same identifier as a long of the existing office visit.\n\t * @throws iTrustException\n\t *             If the visit does not exist or if there is a DB problem.\n\t */\n\tprivate long checkOfficeVisitID(String input) throws iTrustException {\n\t\ttry {\n\t\t\tencode(input);\n\t\t\tlong ovID = Long.valueOf(input);\n\n\t\t\tif (ovDAO.checkOfficeVisitExists(ovID, pid))\n\t\t\t\treturn ovID;\n\t\t\telse\n\t\t\t\tthrow new iTrustException(\"Office Visit \" + ovID + \" with Patient MID \" + pid\n\t\t\t\t\t\t+ \" does not exist\");\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new iTrustException(\"Office Visit ID is not a number: \" + e.getMessage());\n\t\t}\n\t}\n\n\t/**\n\t * For obtaining the unique identifier of the office visit this action is associated with.\n\t * \n\t * @return A long of the identifier.\n\t */\n\tpublic long getOvID() {\n\t\treturn ovID;\n\t}\n\n\t/**\n\t * Converts all characters of the input string to their HTML special characters equivalent representation.\n\t * Explicitly, the less than symbol becomes lt, the greater than symbol becomes gt and a newline feed\n\t * becomes br.\n\t * \n\t * @param input\n\t *            The string to encode.\n\t * @return The encoded string.\n\t */\n\tpublic String encode(String input) {\n\t\tString str = input.replaceAll(\"<\", \"&lt;\");\n\t\tstr = str.replaceAll(\">\", \"&gt;\");\n\t\tstr = str.replaceAll(\"\\n\", \"<br />\");\n\t\treturn str;\n\t}\n}", "PatientBaseAction.java": "package edu.ncsu.csc.itrust.action.base;\n\nimport edu.ncsu.csc.itrust.HtmlEncoder;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\n\n/**\n * An abstract class for dealing with actions that require an associated patient. The concrete functionality\n * provided by this class allows for asserting the correctness and existence of patients' MIDs.\n * \n * Use this class whenever your JSP requires a patient ID when it loads (e.g. editPatient.jsp). The patient\n * string is passed to the constructor of this class and is checked for both format and existence. If the\n * patient ID is wrong in any way, an exception is thrown, resulting in the user getting kicked out to the\n * home page.\n * \n * Very similar to {@link PersonnelBaseAction} and {@link OfficeVisitBaseAction}\n * \n * Subclasses need not rewrite this functionality, and they are not held to any strict contract to extend this\n * class.\n */\npublic class PatientBaseAction {\n\n\t/**\n\t * The database access object factory to associate this with a runtime context.\n\t */\n\tprivate DAOFactory factory;\n\n\t/**\n\t * Stores the MID of the patient associated with this action.\n\t */\n\tprotected long pid;\n\n\t/**\n\t * The default constructor.\n\t * \n\t * @param factory\n\t *            A factory to create a database access object.\n\t * @param pidString\n\t *            The patient's ID to associate with this action.\n\t * @throws iTrustException\n\t *             If the patient's ID is incorrect or there is a DB problem.\n\t */\n\tpublic PatientBaseAction(DAOFactory factory, String pidString) throws iTrustException {\n\t\tthis.factory = factory;\n\t\tthis.pid = checkPatientID(pidString);\n\t}\n\n\t/**\n\t * Asserts whether the input is a valid, existing patient's MID.\n\t * \n\t * @param input\n\t *            The presumed MID\n\t * @return The existing patient's ID as a long.\n\t * @throws iTrustException\n\t *             If the patient does not exist or there is a DB Problem.\n\t */\n\tprivate long checkPatientID(String input) throws iTrustException {\n\t\ttry {\n\t\t\tlong pid = Long.valueOf(input);\n\t\t\tif (factory.getPatientDAO().checkPatientExists(pid))\n\t\t\t\treturn pid;\n\t\t\telse\n\t\t\t\tthrow new iTrustException(\"Patient does not exist\");\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new iTrustException(\"Patient ID is not a number: \" + HtmlEncoder.encode(input));\n\t\t}\n\t}\n\n\t/**\n\t * Retrieves the identifier of the patient as a long.\n\t * \n\t * @return The patient's MID.\n\t */\n\tpublic long getPid() {\n\t\treturn pid;\n\t}\n}", "PersonnelBaseAction.java": "package edu.ncsu.csc.itrust.action.base;\n\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\n\n/**\n * An abstract class for dealing with actions that require an associated personnel. The concrete functionality\n * provided by this class allows for asserting the correctness and existence of personnel' MIDs.\n * \n * Use this class whenever your JSP requires a personnel ID when it loads (e.g. editPatient.jsp). The patient\n * string is passed to the constructor of this class and is checked for both format and existence. If the\n * patient ID is wrong in any way, an exception is thrown, resulting in the user getting kicked out to the\n * home page.\n * \n * Subclasses need not rewrite this functionality, and they are not held to any strict contract to extend this\n * class.\n * \n * Very similar to {@link PatientBaseAction}\n */\npublic class PersonnelBaseAction {\n\n\t/**\n\t * The database access object factory to associate this with a runtime context.\n\t */\n\tprivate DAOFactory factory;\n\n\t/**\n\t * Stores the MID of the personnel associated with this action.\n\t */\n\tprotected long pid;\n\n\t/**\n\t * The default constructor.\n\t * \n\t * @param factory\n\t *            A factory to create a database access object.\n\t * @param pidString\n\t *            The personnel's ID to associate with this action.\n\t * @throws iTrustException\n\t *             If the personnel's ID is incorrect or there is a DB problem.\n\t */\n\tpublic PersonnelBaseAction(DAOFactory factory, String pidString) throws iTrustException {\n\t\tthis.factory = factory;\n\t\tthis.pid = checkPersonnelID(pidString);\n\t}\n\n\t/**\n\t * Asserts whether the input is a valid, existing personnel's MID.\n\t * \n\t * @param input\n\t *            The presumed MID\n\t * @return The existing personnel's ID as a long.\n\t * @throws iTrustException\n\t *             If the personnel does not exist or there is a DB Problem.\n\t */\n\tprivate long checkPersonnelID(String input) throws iTrustException {\n\t\ttry {\n\t\t\tlong pid = Long.valueOf(input);\n\t\t\tif (factory.getPersonnelDAO().checkPersonnelExists(pid))\n\t\t\t\treturn pid;\n\t\t\telse\n\t\t\t\tthrow new iTrustException(\"Personnel does not exist\");\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new iTrustException(\"Personnel ID is not a number: \" + e.getMessage());\n\t\t}\n\t}\n\n\t/**\n\t * Retrieves the identifier of the patient as a long.\n\t * \n\t * @return The patient's MID.\n\t */\n\tpublic long getPid() {\n\t\treturn pid;\n\t}\n}", "AdverseEventBean.java": "package edu.ncsu.csc.itrust.beans;\n\n/**\n * A bean for storing data about a adverse event based on a drug.\n * \n * A bean's purpose is to store data. Period. Little or no functionality is to be added to a bean \n * (with the exception of minor formatting such as concatenating phone numbers together). \n * A bean must only have Getters and Setters (Eclipse Hint: Use Source > Generate Getters and Setters \n * to create these easily)\n */\npublic class AdverseEventBean {\n\tString MID;\n\tString drug;\n\tString description;\n\tString code;\n\tString date;\n\tString status;\n\tString Prescriber;\n\t\n\tpublic String getPrescriber() {\n\t\treturn Prescriber;\n\t}\n\n\tpublic void setPrescriber(String prescriber) {\n\t\tPrescriber = prescriber;\n\t}\n\n\tpublic String getStatus() {\n\t\treturn status;\n\t}\n\n\tpublic void setStatus(String status) {\n\t\tthis.status = status;\n\t}\n\tint id;\n\t\n\t/**\n\t * @return the id\n\t */\n\tpublic int getId() {\n\t\treturn id;\n\t}\n\n\t/**\n\t * @param id the id to set\n\t */\n\tpublic void setId(int id) {\n\t\tthis.id = id;\n\t}\n\n\t/**\n\t * @return the date\n\t */\n\tpublic String getDate() {\n\t\treturn date;\n\t}\n\n\t/**\n\t * @param date the date to set\n\t */\n\tpublic void setDate(String date) {\n\t\tthis.date = date;\n\t}\n\n\tpublic String getCode() {\n\t\treturn code;\n\t}\n\n\tpublic void setCode(String code) {\n\t\tthis.code = code;\n\t}\n\n\t/**\n\t * @return the patient MID\n\t */\n\tpublic String getMID() {\n\t\treturn MID;\n\t}\n\t\n\t/**\n\t * \n\t * @param mID the patients MID\n\t */\n\tpublic void setMID(String mID) {\n\t\tMID = mID;\n\t}\n\t\n\t/**\n\t * \n\t * @return the drug the event is being reported for\n\t */\n\tpublic String getDrug() {\n\t\treturn drug;\n\t}\n\t\n\t/**\n\t * \n\t * @param drug sets the drug the event is being reported for\n\t */\n\tpublic void setDrug(String drug) {\n\t\tthis.drug = drug;\n\t}\n\t/**\n\t * @return the description\n\t */\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\t/**\n\t * @param description the description to set\n\t */\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\t}\n\t\n\t\n\t\n\t\n\n}", "AllergyBean.java": "package edu.ncsu.csc.itrust.beans;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * A bean for storing data about Allergies.\n * \n * A bean's purpose is to store data. Period. Little or no functionality is to be added to a bean \n * (with the exception of minor formatting such as concatenating phone numbers together). \n * A bean must only have Getters and Setters (Eclipse Hint: Use Source > Generate Getters and Setters \n * to create these easily)\n */\npublic class AllergyBean {\n\tprivate long id;\n\tprivate long patientID;\n\tprivate String description;\n\tprivate Date firstFound;\n\n\tpublic AllergyBean() {\n\t}\n\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\t}\n\n\tpublic Date getFirstFound() {\n\t\treturn (Date) firstFound.clone();\n\t}\n\n\tpublic void setFirstFound(Date firstFound) {\n\t\tif (null != firstFound)\n\t\t\tthis.firstFound = (Date) firstFound.clone();\n\t\telse\n\t\t\tthis.firstFound = null;\n\t}\n\n\tpublic long getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(long id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic String toString() {\n\t\treturn this.description;\n\t}\n\n\tpublic long getPatientID() {\n\t\treturn patientID;\n\t}\n\n\tpublic void setPatientID(long patientID) {\n\t\tthis.patientID = patientID;\n\t}\n\n\tpublic String getFirstFoundStr() {\n\t\ttry {\n\t\t\treturn new SimpleDateFormat(\"MM/dd/yyyy\").format(getFirstFound());\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn \"\";\n\t\t}\n\t}\n}", "ApptBean.java": "package edu.ncsu.csc.itrust.beans;\n\nimport java.sql.Timestamp;\n\n\npublic class ApptBean {\n\tprivate String apptType;\n\tprivate long patient;\n\tprivate long hcp;\n\tprivate Timestamp date;\n\tprivate String comment;\n\t\n\t/**\n\t * @return the apptType\n\t */\n\tpublic String getApptType() {\n\t\treturn apptType;\n\t}\n\t/**\n\t * @param apptType the apptType to set\n\t */\n\tpublic void setApptType(String apptType) {\n\t\tthis.apptType = apptType;\n\t}\n\t/**\n\t * @return the patient\n\t */\n\tpublic long getPatient() {\n\t\treturn patient;\n\t}\n\t/**\n\t * @param patient the patient to set\n\t */\n\tpublic void setPatient(long patient) {\n\t\tthis.patient = patient;\n\t}\n\t/**\n\t * @return the hcp\n\t */\n\tpublic long getHcp() {\n\t\treturn hcp;\n\t}\n\t/**\n\t * @param hcp the hcp to set\n\t */\n\tpublic void setHcp(long hcp) {\n\t\tthis.hcp = hcp;\n\t}\n\t/**\n\t * @return the date\n\t */\n\tpublic Timestamp getDate() {\n\t\treturn date;\n\t}\n\t/**\n\t * @param date the date to set\n\t */\n\tpublic void setDate(Timestamp date) {\n\t\tthis.date = date;\n\t}\n\t/**\n\t * @return the comment\n\t */\n\tpublic String getComment() {\n\t\treturn comment;\n\t}\n\t/**\n\t * @param comment the comment to set\n\t */\n\tpublic void setComment(String comment) {\n\t\tthis.comment = comment;\n\t}\n}", "ApptTypeBean.java": "package edu.ncsu.csc.itrust.beans;\n\npublic class ApptTypeBean {\n\t\n\tprivate String name;\n\tprivate int duration;\n\t\n\tpublic ApptTypeBean() {\n\t\tthis.name = null;\n\t\tthis.duration = 0;\n\t}\n\t\n\tpublic ApptTypeBean(String name, int duration) {\n\t\tthis.name = name;\n\t\tthis.duration = duration;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic int getDuration() {\n\t\treturn duration;\n\t}\n\t\n\tpublic void setDuration(int duration) {\n\t\tthis.duration = duration;\n\t}\n}", "DiagnosisBean.java": "package edu.ncsu.csc.itrust.beans;\n\n/**\n * A bean for storing data about Diagnosis.\n * \n * A bean's purpose is to store data. Period. Little or no functionality is to be added to a bean \n * (with the exception of minor formatting such as concatenating phone numbers together). \n * A bean must only have Getters and Setters (Eclipse Hint: Use Source > Generate Getters and Setters \n * to create these easily)\n */\npublic class DiagnosisBean {\n\tprivate long ovDiagnosisID = 0L; // optional\n\tprivate String icdCode;\n\tprivate String description;\n\tprivate String classification;\n\tprivate long visitID;\n\n\tpublic DiagnosisBean() {\n\t}\n\n\t/**\n\t * This functionality will be moved elsewhere.\n\t * \n\t */\n\tpublic DiagnosisBean(String code, String description, String classification) {\n\t\tthis.icdCode = code;\n\t\tthis.description = description;\n\t\t\n\t\tif (null != classification && classification.equals(\"yes\")) {\n\t\t\tthis.classification = classification;\n\t\t}\n\t\telse {\n\t\t\tthis.classification = \"no\";\n\t\t}\n\t}\n\n\t/**\n\t * Gets the ICD Code for this procedure\n\t * \n\t * @return The ICD Code for this procedure\n\t */\n\tpublic String getICDCode() {\n\t\treturn icdCode;\n\t}\n\n\tpublic void setICDCode(String code) {\n\t\ticdCode = code;\n\t}\n\t\n\tpublic String getClassification() {\n\t\treturn classification;\n\t}\n\n\t/**\n\t * Gets the ICD Description for this procedure\n\t * \n\t * @return The ICD Description for this procedure\n\t */\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\t}\n\n\tpublic String getFormattedDescription() {\n\t\treturn description + \"(\" + icdCode + \")\";\n\t}\n\n\t/**\n\t * Optional - for use with editing an office visit\n\t * \n\t * @return\n\t */\n\tpublic long getOvDiagnosisID() {\n\t\treturn ovDiagnosisID;\n\t}\n\n\tpublic void setOvDiagnosisID(long ovDiagnosisID) {\n\t\tthis.ovDiagnosisID = ovDiagnosisID;\n\t}\n\n\tpublic void setVisitID(long vid) {\n\t\tvisitID = vid;\n\t}\n\t\n\tpublic long getVisitID() {\n\t\treturn visitID;\n\t}\n}", "DrugInteractionBean.java": "package edu.ncsu.csc.itrust.beans;\n\n/**\n * A bean for storing data about a message from one user to another.\n * \n * A bean's purpose is to store data. Period. Little or no functionality is to be added to a bean \n * (with the exception of minor formatting such as concatenating phone numbers together). \n * A bean must only have Getters and Setters (Eclipse Hint: Use Source > Generate Getters and Setters \n * to create these easily)\n */\npublic class DrugInteractionBean {\n\tString firstDrug;\n\tString secondDrug;\n\tString description;\n\t/**\n\t * @return the firstDrug\n\t */\n\tpublic String getFirstDrug() {\n\t\treturn firstDrug;\n\t}\n\t/**\n\t * @param firstDrug the firstDrug to set\n\t */\n\tpublic void setFirstDrug(String firstDrug) {\n\t\tthis.firstDrug = firstDrug;\n\t}\n\t/**\n\t * @return the secondDrug\n\t */\n\tpublic String getSecondDrug() {\n\t\treturn secondDrug;\n\t}\n\t/**\n\t * @param secondDrug the secondDrug to set\n\t */\n\tpublic void setSecondDrug(String secondDrug) {\n\t\tthis.secondDrug = secondDrug;\n\t}\n\t/**\n\t * @return the description\n\t */\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\t/**\n\t * @param description the description to set\n\t */\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\t}\n\t\n\t\n\t\n\t\n\n}", "Email.java": "package edu.ncsu.csc.itrust.beans;\n\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * A bean for storing data about Fake Emails.\n * \n * A bean's purpose is to store data. Period. Little or no functionality is to be added to a bean \n * (with the exception of minor formatting such as concatenating phone numbers together). \n * A bean must only have Getters and Setters (Eclipse Hint: Use Source > Generate Getters and Setters \n * to create these easily)\n */\npublic class Email {\n\tprivate List<String> toList = new ArrayList<String>();\n\tprivate String from = \"\";\n\tprivate String subject = \"\";\n\tprivate String body = \"\";\n\tprivate Timestamp timeAdded;\n\n\tpublic List<String> getToList() {\n\t\treturn toList;\n\t}\n\n\tpublic void setToList(List<String> toList) {\n\t\tthis.toList = toList;\n\t}\n\n\tpublic String getToListStr() {\n\t\tString str = \"\";\n\t\tfor (String addr : toList) {\n\t\t\tstr += addr + \",\";\n\t\t}\n\t\treturn str.substring(0, str.length() - 1);\n\t}\n\n\tpublic String getFrom() {\n\t\treturn from;\n\t}\n\n\tpublic void setFrom(String from) {\n\t\tthis.from = from;\n\t}\n\n\tpublic String getSubject() {\n\t\treturn subject;\n\t}\n\n\tpublic void setSubject(String subject) {\n\t\tthis.subject = subject;\n\t}\n\n\tpublic String getBody() {\n\t\treturn body;\n\t}\n\n\tpublic void setBody(String body) {\n\t\tthis.body = body;\n\t}\n\n\tpublic Timestamp getTimeAdded() {\n\t\treturn timeAdded;\n\t}\n\n\tpublic void setTimeAdded(Timestamp timeAdded) {\n\t\tthis.timeAdded = timeAdded;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\treturn obj != null && obj.getClass().equals(this.getClass()) && this.equals((Email) obj);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tassert false : \"hashCode not designed\";\n\t\treturn 42; // any arbitrary constant will do\n\t}\n\n\tprivate boolean equals(Email other) {\n\t\treturn from.equals(other.from) && subject.equals(other.subject) && body.equals(other.body)\n\t\t\t\t&& listEquals(toList, other.toList);\n\t}\n\n\tprivate boolean listEquals(List<String> toList, List<String> otherToList) {\n\t\tif (toList.size() != otherToList.size())\n\t\t\treturn false;\n\t\tfor (int i = 0; i < toList.size(); i++) {\n\t\t\tif (!toList.get(i).equals(otherToList.get(i)))\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"FROM: \" + from + \" TO: \" + toList.toString() + \" SUBJECT: \" + subject + \" BODY: \" + body;\n\t}\n\n}", "FamilyMemberBean.java": "package edu.ncsu.csc.itrust.beans;\n\n/**\n * A bean for storing data about Family Members.\n * \n * A bean's purpose is to store data. Period. Little or no functionality is to be added to a bean \n * (with the exception of minor formatting such as concatenating phone numbers together). \n * A bean must only have Getters and Setters (Eclipse Hint: Use Source > Generate Getters and Setters \n * to create these easily)\n */\npublic class FamilyMemberBean {\n\tprivate long mid = 0;\n\tprivate String relation = \"\";\n\tprivate String firstName = \"\";\n\tprivate String lastName = \"\";\n\n\tpublic FamilyMemberBean() {\n\t}\n\n\tpublic String getFirstName() {\n\t\treturn firstName;\n\t}\n\n\tpublic void setFirstName(String firstName) {\n\t\tthis.firstName = firstName;\n\t}\n\n\tpublic String getLastName() {\n\t\treturn lastName;\n\t}\n\n\tpublic void setLastName(String lastName) {\n\t\tthis.lastName = lastName;\n\t}\n\n\tpublic String getFullName() {\n\t\treturn getFirstName() + \" \" + getLastName();\n\t}\n\n\tpublic long getMid() {\n\t\treturn mid;\n\t}\n\n\tpublic void setMid(long mid) {\n\t\tthis.mid = mid;\n\t}\n\n\tpublic String getRelation() {\n\t\treturn relation;\n\t}\n\n\tpublic void setRelation(String relation) {\n\t\tthis.relation = relation;\n\t}\n}", "HCPDiagnosisBean.java": "package edu.ncsu.csc.itrust.beans;\n\nimport java.util.List;\n\n/**\n * A bean for storing data about the diagnosis given by an HCP.\n * \n * A bean's purpose is to store data. Period. Little or no functionality is to be added to a bean \n * (with the exception of minor formatting such as concatenating phone numbers together). \n * A bean must only have Getters and Setters (Eclipse Hint: Use Source > Generate Getters and Setters \n * to create these easily)\n */\npublic class HCPDiagnosisBean {\n\n\tprivate long HCPID;\n\tprivate String HCPname;\n\tprivate long numPatients;\n\tprivate List<MedicationBean> medList;\n\tprivate List<LabProcedureBean> labList;\n\tprivate int visitSat;\n\tprivate int treatmentSat;\n\tprivate int surveyCount;\n\t\n\tpublic HCPDiagnosisBean() {\n\t\tnumPatients = 0;\n\t\tvisitSat = 0;\n\t\ttreatmentSat = 0;\n\t\tsurveyCount = 0;\n\t}\n\n\tpublic long getHCP() {\n\t\treturn HCPID;\n\t}\n\t\n\tpublic void setHCP(long hcp) {\n\t\tHCPID = hcp;\n\t}\n\t\n\tpublic String getHCPName() {\n\t\treturn HCPname;\n\t}\n\t\n\tpublic void setHCPName(String name) {\n\t\tHCPname = name;\n\t}\n\t\n\tpublic long getNumPatients() {\n\t\treturn numPatients;\n\t}\n\t\n\tpublic void incNumPatients() {\n\t\tnumPatients++;\n\t}\n\t\n\tpublic List<MedicationBean> getMedList() {\n\t\treturn medList;\n\t}\n\t\n\tpublic void setMedList(List<MedicationBean> medlist) {\n\t\tmedList = medlist;\n\t}\n\t\n\tpublic List<LabProcedureBean> getLabList() {\n\t\treturn labList;\n\t}\n\t\n\tpublic void setLabList(List<LabProcedureBean> lablist) {\n\t\tlabList = lablist;\n\t}\n\t\n\tpublic String getVisitSatisfaction() {\n\t\treturn (visitSat != 0 && surveyCount != 0)?Double.toString(((double)visitSat/(double)surveyCount)):\"no results available\";\n\t}\n\t\n\tpublic void setVisitSat(int sat) {\n\t\tvisitSat += sat;\n\t\tsurveyCount++;\n\t}\n\n\tpublic String getTreatmentSatisfaction() {\n\t\treturn (treatmentSat != 0 && surveyCount != 0)?Double.toString((double)treatmentSat/(double)surveyCount):\"no results available\";\n\t}\t\n\t\n\tpublic void setTreatmentSat(int sat) {\n\t\ttreatmentSat += sat;\n\t}\n\n}", "HCPLinkBean.java": "package edu.ncsu.csc.itrust.beans;\n\n/**\n * A mini-bean to pass data between viewPrescriptionRecords.jsp and reportAdverseEvent.jsp\n * \n * A bean's purpose is to store data. Period. Little or no functionality is to be added to a bean \n * (with the exception of minor formatting such as concatenating phone numbers together). \n * A bean must only have Getters and Setters (Eclipse Hint: Use Source > Generate Getters and Setters \n * to create these easily)\n */\npublic class HCPLinkBean {\n\tlong prescriberMID;\n\tString drug;\n\tboolean checked;\n\tString code;\n\t\n\tpublic boolean isChecked() {\n\t\treturn checked;\n\t}\n\n\tpublic void setChecked(boolean checked) {\n\t\tthis.checked = checked;\n\t}\n\n\tpublic String getCode() {\n\t\treturn code;\n\t}\n\n\tpublic void setCode(String code) {\n\t\tthis.code = code;\n\t}\n\n\t/**\n\t * @return the patient MID\n\t */\n\tpublic long getPrescriberMID() {\n\t\treturn prescriberMID;\n\t}\n\t\n\t/**\n\t * \n\t * @param mID the patients MID\n\t */\n\tpublic void setPrescriberMID(long mID) {\n\t\tprescriberMID = mID;\n\t}\n\t\n\t/**\n\t * \n\t * @return the drug the event is being reported for\n\t */\n\tpublic String getDrug() {\n\t\treturn drug;\n\t}\n\t\n\t/**\n\t * \n\t * @param drug sets the drug the event is being reported for\n\t */\n\tpublic void setDrug(String drug) {\n\t\tthis.drug = drug;\n\t}\n}", "HCPVisitBean.java": "package edu.ncsu.csc.itrust.beans;\n\n/**\n * A bean for storing data about a visit with an HCP.\n * \n * A bean's purpose is to store data. Period. Little or no functionality is to be added to a bean \n * (with the exception of minor formatting such as concatenating phone numbers together). \n * A bean must only have Getters and Setters (Eclipse Hint: Use Source > Generate Getters and Setters \n * to create these easily)\n */\npublic class HCPVisitBean {\n\tprivate String HCPName;\n\tprivate String HCPSpecialty;\n\tprivate String HCPAddr;\n\tprivate String OVDate;\n\tprivate boolean designated;\n\tprivate long hcpMID;\n\t\n\tpublic HCPVisitBean() {\n\t\tHCPName = \"\";\n\t\tHCPSpecialty = \"\";\n\t\tHCPAddr = \"\";\n\t\tOVDate = \"\";\n\t\t\n\t}\n\t\n\tpublic void setHCPMID(long mid) {\n\t\thcpMID = mid;\n\t}\n\t\n\tpublic long getHCPMID() {\n\t\treturn hcpMID;\n\t}\n\t\n\tpublic String getHCPName() {\n\t\treturn HCPName;\n\t}\n\t\n\tpublic void setHCPName(String name) {\n\t\tif (null != name) {\n\t\t\tHCPName = name;\n\t\t}\n\t}\n\t\n\tpublic String getHCPSpecialty() {\n\t\treturn HCPSpecialty;\n\t}\n\t\n\tpublic void setHCPSpecialty(String specialty) {\n\t\tif (null != specialty) {\n\t\t\tHCPSpecialty = specialty;\n\t\t}\n\t\telse {\n\t\t\tHCPSpecialty = \"none\";\n\t\t}\n\t}\n\t\n\tpublic String getHCPAddr() {\n\t\treturn HCPAddr;\n\t}\n\t\n\tpublic void setHCPAddr(String addr) {\n\t\tif (null != addr) {\n\t\t\tHCPAddr = addr;\n\t\t}\n\t}\n\t\n\tpublic String getOVDate() {\n\t\treturn OVDate;\n\t}\n\t\n\tpublic void setOVDate(String date) {\n\t\tif (null != date) {\n\t\t\tOVDate = date;\n\t\t}\n\t}\n\t\n\tpublic boolean isDesignated() {\n\t\treturn designated;\n\t}\n\t\n\tpublic void setDesignated(boolean val) {\n\t\tdesignated = val;\n\t}\n}", "HealthRecord.java": "package edu.ncsu.csc.itrust.beans;\n\nimport java.sql.Timestamp;\nimport java.util.Date;\n\n/**\n * A bean for storing health record data.\n * \n * A bean's purpose is to store data. Period. Little or no functionality is to be added to a bean \n * (with the exception of minor formatting such as concatenating phone numbers together). \n * A bean must only have Getters and Setters (Eclipse Hint: Use Source > Generate Getters and Setters \n * to create these easily)\n */\npublic class HealthRecord {\n\tprivate long patientID = 0;\n\tprivate double height = 0;\n\tprivate double weight = 0;\n\tprivate boolean isSmoker = false;\n\tprivate int bloodPressureN = 0;\n\tprivate int bloodPressureD = 0;\n\tprivate int cholesterolHDL = 1;\n\tprivate int cholesterolLDL = 100;\n\tprivate int cholesterolTri = 100;\n\tprivate long personnelID = 0;\n\tprivate Timestamp dateRecorded = new Timestamp(new Date().getTime());\n\n\tpublic HealthRecord() {\n\t}\n\n\tpublic int getBloodPressureD() {\n\t\treturn bloodPressureD;\n\t}\n\n\tpublic void setBloodPressureD(int bloodPressureD) {\n\t\tthis.bloodPressureD = bloodPressureD;\n\t}\n\n\tpublic void setBloodPressureSystolic(int bloodPressure) {\n\t\tthis.bloodPressureN = bloodPressure;\n\t}\n\n\tpublic void setBloodPressureDiastolic(int bloodPressure) {\n\t\tthis.bloodPressureD = bloodPressure;\n\t}\n\n\tpublic int getBloodPressureN() {\n\t\treturn bloodPressureN;\n\t}\n\n\tpublic int getBloodPressureSystolic() {\n\t\treturn bloodPressureN;\n\t}\n\n\tpublic int getBloodPressureDiastolic() {\n\t\treturn bloodPressureD;\n\t}\n\n\tpublic void setBloodPressureN(int bloodPressureN) {\n\t\tthis.bloodPressureN = bloodPressureN;\n\t}\n\n\tpublic String getBloodPressure() {\n\t\treturn getBloodPressureN() + \"/\" + getBloodPressureD();\n\t}\n\n\tpublic int getCholesterolHDL() {\n\t\treturn cholesterolHDL;\n\t}\n\n\tpublic void setCholesterolHDL(int cholesterolHDL) {\n\t\tthis.cholesterolHDL = cholesterolHDL;\n\t}\n\n\tpublic int getCholesterolLDL() {\n\t\treturn cholesterolLDL;\n\t}\n\n\tpublic void setCholesterolLDL(int cholesterolLDL) {\n\t\tthis.cholesterolLDL = cholesterolLDL;\n\t}\n\n\tpublic int getCholesterolTri() {\n\t\treturn cholesterolTri;\n\t}\n\n\tpublic void setCholesterolTri(int cholesterolTri) {\n\t\tthis.cholesterolTri = cholesterolTri;\n\t}\n\n\t/**\n\t * Note that this is a simplistic view. See the Wikipedia article on cholesterol.\n\t * \n\t * @return\n\t */\n\tpublic int getTotalCholesterol() {\n\t\treturn getCholesterolHDL() + getCholesterolLDL() + getCholesterolTri();\n\t}\n\n\tpublic Date getDateRecorded() {\n\t\treturn dateRecorded;\n\t}\n\n\tpublic void setDateRecorded(Timestamp dateRecorded) {\n\t\tthis.dateRecorded = dateRecorded;\n\t}\n\n\t// Rounds the height off here because MySQL won't return the *exact* value you put in it\n\tpublic double getHeight() {\n\t\treturn Math.round(height * 10000) / 10000D;\n\t}\n\n\tpublic void setHeight(double height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic long getPatientID() {\n\t\treturn patientID;\n\t}\n\n\tpublic void setPatientID(long patientID) {\n\t\tthis.patientID = patientID;\n\t}\n\n\tpublic long getPersonnelID() {\n\t\treturn personnelID;\n\t}\n\n\tpublic void setPersonnelID(long personnelID) {\n\t\tthis.personnelID = personnelID;\n\t}\n\n\tpublic boolean isSmoker() {\n\t\treturn isSmoker;\n\t}\n\n\tpublic void setSmoker(boolean smoker) {\n\t\tthis.isSmoker = smoker;\n\t}\n\n\tpublic double getWeight() {\n\t\treturn Math.round(weight * 10000) / 10000D;\n\t}\n\n\tpublic void setWeight(double weight) {\n\t\tthis.weight = weight;\n\t}\n\n\tpublic double getBodyMassIndex() {\n\t\treturn 703 * (weight / (height * height));\n\t}\n}", "HospitalBean.java": "package edu.ncsu.csc.itrust.beans;\n\n/**\n * A bean for storing data about a hospital.\n * \n * A bean's purpose is to store data. Period. Little or no functionality is to be added to a bean \n * (with the exception of minor formatting such as concatenating phone numbers together). \n * A bean must only have Getters and Setters (Eclipse Hint: Use Source > Generate Getters and Setters \n * to create these easily)\n */\npublic class HospitalBean {\n\tString hospitalID;\n\tString hospitalName;\n\n\tpublic HospitalBean() {\n\t}\n\n\tpublic HospitalBean(String id) {\n\t\thospitalID = id;\n\t}\n\n\tpublic HospitalBean(String id, String name) {\n\t\thospitalID = id;\n\t\thospitalName = name;\n\t}\n\n\tpublic String getHospitalID() {\n\t\treturn hospitalID;\n\t}\n\n\tpublic void setHospitalID(String hospitalID) {\n\t\tthis.hospitalID = hospitalID;\n\t}\n\n\tpublic String getHospitalName() {\n\t\treturn hospitalName;\n\t}\n\n\tpublic void setHospitalName(String hospitalName) {\n\t\tthis.hospitalName = hospitalName;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\treturn obj != null && obj.getClass().equals(this.getClass()) && this.equals((HospitalBean) obj);\n\t}\n\n\tpublic int hashCode() {\n\t\tassert false : \"hashCode not designed\";\n\t\treturn 42; // any arbitrary constant will do\n\t}\n\n\tprivate boolean equals(HospitalBean other) {\n\t\treturn hospitalID.equals(other.hospitalID) && hospitalName.equals(other.hospitalName);\n\t}\n}", "LabProcedureBean.java": "package edu.ncsu.csc.itrust.beans;\n\nimport java.sql.Timestamp;\n\n\n\n/**\n * A bean for storing data about a lab procedure.\n * \n * A bean's purpose is to store data. Period. Little or no functionality is to be added to a bean \n * (with the exception of minor formatting such as concatenating phone numbers together). \n * A bean must only have Getters and Setters (Eclipse Hint: Use Source > Generate Getters and Setters \n * to create these easily)\n */\npublic class LabProcedureBean {\n\t\n\tpublic final static String Not_Received = \"NOT YET RECEIVED\";\n\tpublic final static String Pending = \"PENDING\";\n\tpublic final static String Completed = \"COMPLETED\";\n\tpublic final static String Allow = \"ALLOWED\";\n\tpublic final static String Restrict = \"RESTRICTED\";\n\n\t\n\t/**\n\t * Unique 10-digit number that does not start with 9\n\t */\n\t private long pid;\t \n\t \n\t /**\n\t  * Unique identifier for a laboratory procedure of a patient\n\t  */\n\t private long procedureID;\n\t \n\t /**\n\t  * Digits of the format nnnnn-n \n\t  */\n\t private String loinc; \n\t\n\t /**\n\t  * One of (NOT YET RECEIVED, PENDING, COMPLETED)\n\t  */\n\t private String status;\n\t \n\t /**\n\t  * Up to 500 alphanumeric characters\n\t  */\n\t private String commentary;\n\t \n\t /**\n\t  * Up to 500 alphanumeric characters\n\t  */\n\t private String results;\n\t \n\t /**\n\t  * Office VisitID\tIdentifier that specifies the office visit in \n\t  * which the laboratory procedure was ordered\n\t  */\n\t private long ovID; \n\t \n\t /**\n\t  * Date/Time of last status update \tTimestamp\n\t  */\n\t private Timestamp timestamp;\n\t \n\t /**\n\t  * permission granted by lhcp who ordered test:\n\t  * \"ALLOWED\", \"RESTRICTED\"\n\t  */\n\t private String rights = Allow;\n\t \n\t \n\t \n\t public LabProcedureBean(){\n\t }\n\n\n\t/**\n\t * Unique 10-digit number that does not start with 9\n\t */\n\tpublic long getPid() {\n\t\treturn pid;\n\t}\n\n\n\t/**\n\t * Unique 10-digit number that does not start with 9\n\t */\n\tpublic void setPid(long pid) {\n\t\tthis.pid = pid;\n\t}\n\n\n\t/**\n\t  * Unique identifier for a laboratory procedure of a patient\n\t  */\n\tpublic long getProcedureID() {\n\t\treturn procedureID;\n\t}\n\n\n\t/**\n\t  * Unique identifier for a laboratory procedure of a patient\n\t  */\n\tpublic void setProcedureID(long procedureID) {\n\t\tthis.procedureID = procedureID;\n\t}\n\n\n\t /**\n\t  * Digits of the format nnnnn-n \n\t  */\n\tpublic String getLoinc() {\n\t\treturn loinc;\n\t}\n\n\n\t /**\n\t  * Digits of the format nnnnn-n \n\t  */\n\tpublic void setLoinc(String loinc) {\n\t\tthis.loinc = loinc;\n\t}\n\n\n\t/**\n\t  * One of (NOT YET RECEIVED, PENDING, COMPLETED)\n\t  */\n\tpublic String getStatus() {\n\t\treturn status;\n\t}\n\n\n\t/**\n\t  * One of (NOT YET RECEIVED, PENDING, COMPLETED)\n\t  */\n\tpublic void setStatus(String status) {\n\t\tthis.status = status;\n\t}\n\n\n\t /**\n\t  * Up to 500 alphanumeric characters\n\t  */\n\tpublic String getCommentary() {\n\t\treturn commentary;\n\t}\n\n\n\t /**\n\t  * Up to 500 alphanumeric characters\n\t  */\n\tpublic void setCommentary(String commentary) {\n\t\tthis.commentary = commentary;\n\t}\n\n\n\t /**\n\t  * Up to 500 alphanumeric characters\n\t  */\n\tpublic String getResults() {\n\t\treturn results;\n\t}\n\n\n\t /**\n\t  * Up to 500 alphanumeric characters\n\t  */\n\tpublic void setResults(String results) {\n\t\tthis.results = results;\n\t}\n\n\n\t /**\n\t  * Office VisitID\tIdentifier that specifies the office visit in \n\t  * which the laboratory procedure was ordered\n\t  */\n\tpublic long getOvID() {\n\t\treturn ovID;\n\t}\n\n\n\t /**\n\t  * Office VisitID\tIdentifier that specifies the office visit in \n\t  * which the laboratory procedure was ordered\n\t  */\n\tpublic void setOvID(long ovID) {\n\t\tthis.ovID = ovID;\n\t}\n\n\n\n\tpublic Timestamp getTimestamp() {\n\t\treturn timestamp;\n\t}\n\n\n\n\tpublic void setTimestamp(Timestamp timestamp) {\n\t\tthis.timestamp = timestamp;\n\t}\n\n\t /**\n\t  * permission granted by lhcp who ordered test:\n\t  * \"ALLOWED\", \"RESTRICTED\"\n\t  */\n\tpublic String getRights() {\n\t\treturn rights;\n\t}\n\n\t /**\n\t  * permission granted by lhcp who ordered test:\n\t  * \"ALLOWED\", \"RESTRICTED\"\n\t  */\n\tpublic void setRights(String rights) {\n\t\tthis.rights = rights;\n\t}\n\t\n\t\n\t public void allow(){\n\t\t this.rights = Allow;\n\t }\n\t \n\t public void restrict(){\n\t\t this.rights = Restrict;\n\t }\n\t \n\t public void statusComplete(){\n\t \tthis.status = Completed;\n\t }\n\t \n\t public void statusPending(){\n\t\t this.status = Pending;\n\t }\n\t \n\t public void statusNotReceived(){\n\t\t this.status = Not_Received;\n\t }\n\t \n\t \n\t \n}", "LOINCbean.java": "package edu.ncsu.csc.itrust.beans;\n\n/**\n * A bean for storing data about Lab Procedure Codes.\n * \n * A bean's purpose is to store data. Period. Little or no functionality is to be added to a bean \n * (with the exception of minor formatting such as concatenating phone numbers together). \n * A bean must only have Getters and Setters (Eclipse Hint: Use Source > Generate Getters and Setters \n * to create these easily)\n */\npublic class LOINCbean {\n\tprivate String labProcedureCode;\n\tprivate String component;\n\tprivate String kindOfProperty;\n\tprivate String timeAspect;\n\tprivate String system;\n\tprivate String scaleType;\n\tprivate String methodType;\n\t\n\tpublic LOINCbean(){\n\t\t\n\t}\n\n\tpublic String getLabProcedureCode(){\n\t\treturn labProcedureCode;\n\t}\n\t\n\tpublic void setLabProcedureCode(String aLabProcedureCode){\n\t\tlabProcedureCode=aLabProcedureCode;\n\t}\n\t\n\tpublic String getComponent(){\n\t\treturn component;\n\t}\n\t\n\tpublic void setComponent(String aComponent){\n\t\tcomponent=aComponent;\n\t}\n\n\tpublic String getKindOfProperty(){\n\t\treturn kindOfProperty;\n\t}\n\t\n\tpublic void setKindOfProperty(String aKindOfProperty){\n\t\tkindOfProperty=aKindOfProperty;\n\t}\n\t\n\tpublic String getTimeAspect(){\n\t\treturn timeAspect;\n\t}\n\t\n\tpublic void setTimeAspect(String aTimeAspect){\n\t\ttimeAspect=aTimeAspect;\n\t}\n\n\tpublic String getSystem(){\n\t\treturn system;\n\t}\n\t\n\tpublic void setSystem(String aSystem){\n\t\tsystem=aSystem;\n\t}\n\tpublic String getScaleType(){\n\t\treturn scaleType;\n\t}\n\t\n\tpublic void setScaleType(String aScaleType){\n\t\tscaleType=aScaleType;\n\t}\n\n\tpublic String getMethodType(){\n\t\treturn methodType;\n\t}\n\t\n\tpublic void setMethodType(String aMethodType){\n\t\tmethodType=aMethodType;\n\t}\n\n}", "MedicationBean.java": "package edu.ncsu.csc.itrust.beans;\n\n/**\n * A medication is the same thing as an ND code - it's like \"Aspirin\". A medication is not associated with an\n * office visit; that's a \"prescription\". See {@link PrescriptionBean}\n * \n * @author Andy Meneely\n * \n */\npublic class MedicationBean {\n\tprivate String NDCode = \"\";\n\tprivate String description = \"\";\n\n\tpublic MedicationBean() {\n\t}\n\n\tpublic MedicationBean(String code) {\n\t\tNDCode = code;\n\t}\n\n\tpublic MedicationBean(String code, String description) {\n\t\tNDCode = code;\n\t\tthis.description = description;\n\t}\n\n\t/**\n\t * Gets the ND Code for this procedure\n\t * \n\t * @return The ND Code for this procedure\n\t */\n\tpublic String getNDCode() {\n\t\treturn NDCode;\n\t}\n\n\tpublic void setNDCode(String code) {\n\t\tNDCode = code;\n\t}\n\n\t/**\n\t * Gets the ND Description for this procedure\n\t * \n\t * @return The ND Description for this procedure\n\t */\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\t}\n\n\tpublic String getNDCodeFormatted() {\n\t\tString code = getNDCode();\n\t\tif (code.length() > 5)\n\t\t\treturn code.substring(0, 5) + \"-\" + code.substring(5);\n\t\telse\n\t\t\treturn code;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object other) {\n\t\treturn (other != null) && this.getClass().equals(other.getClass())\n\t\t\t\t&& this.equals((MedicationBean) other);\n\t}\n\n\tpublic int hashCode() {\n\t\tassert false : \"hashCode not designed\";\n\t\treturn 42; // any arbitrary constant will do\n\t}\n\n\tprivate boolean equals(MedicationBean other) {\n\t\treturn description.equals(other.description) && NDCode.equals(other.NDCode);\n\t}\n}", "MessageBean.java": "package edu.ncsu.csc.itrust.beans;\n\nimport java.sql.Timestamp;\n\n/**\n * A bean for storing data about a message from one user to another.\n * \n * A bean's purpose is to store data. Period. Little or no functionality is to be added to a bean \n * (with the exception of minor formatting such as concatenating phone numbers together). \n * A bean must only have Getters and Setters (Eclipse Hint: Use Source > Generate Getters and Setters \n * to create these easily)\n */\npublic class MessageBean {\n\tprivate long to;\n\tprivate long from;\n\tprivate long id;\n\tprivate long parentMsgId;\n\tprivate String subject;\n\tprivate String body;\n\tprivate Timestamp timestamp;\n\tprivate int read;\n\t\n\t/**\n\t * Gets the MIDs of the recipients for this Message\n\t * @return\n\t */\n\tpublic long getTo() {\n\t\treturn to;\n\t}\n\t\n\t/**\n\t * Sets the MIDs of the recipients for this Message\n\t * @param to\n\t */\n\tpublic void setTo(long to) {\n\t\tthis.to = to;\n\t}\n\t\n\tpublic long getMessageId()\n\t{\n\t\treturn id;\n\t}\n\t\n\tpublic void setMessageId(long id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic long getParentMessageId() {\n\t\treturn this.parentMsgId;\n\t}\n\t\n\tpublic void setParentMessageId(long parentMsgId) {\n\t\tthis.parentMsgId = parentMsgId;\n\t}\n\t\n\t/**\n\t * Gets the MID of the sender for this message\n\t * @return\n\t */\n\tpublic long getFrom() {\n\t\treturn from;\n\t}\n\n\t/**\n\t * Sets the MID of the sender for this message\n\t * @param from\n\t */\n\tpublic void setFrom(long from) {\n\t\tthis.from = from;\n\t}\n\t\n\t/**\n\t * Gets the subject of this message\n\t * @return\n\t */\n\tpublic String getSubject() {\n\t\treturn subject;\n\t}\n\t\n\t/**\n\t * Sets the subject of this message\n\t * @param subject\n\t */\n\tpublic void setSubject(String subject) {\n\t\tthis.subject = subject;\n\t}\n\n\t/**\n\t * Gets the body of this message\n\t * @return\n\t */\n\tpublic String getBody() {\n\t\treturn body;\n\t}\n\t\n\t/**\n\t * Sets the body of this message\n\t * @param body\n\t */\n\tpublic void setBody(String body) {\n\t\tthis.body = body;\n\t}\n\n\t/**\n\t * Gets the time for this message\n\t * @return\n\t */\n\tpublic Timestamp getSentDate() {\n\t\treturn this.timestamp;\n\t}\n\n\t/**\n\t * Sets the time for this message\n\t * @param timestamp\n\t */\n\tpublic void setSentDate(Timestamp timestamp) {\n\t\tthis.timestamp = timestamp;\n\t}\n\t\n\t/**\n\t * Gets read for this message\n\t * @return\n\t */\n\tpublic int getRead() {\n\t\treturn this.read;\n\t}\n\n\t/**\n\t * Sets read for this message\n\t * @param read\n\t */\n\tpublic void setRead(int read) {\n\t\tthis.read = read;\n\t}\n\n}", "OfficeVisitBean.java": "package edu.ncsu.csc.itrust.beans;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\n\n/**\n * A bean for storing data about an office visit at the hospital.\n * \n * A bean's purpose is to store data. Period. Little or no functionality is to be added to a bean \n * (with the exception of minor formatting such as concatenating phone numbers together). \n * A bean must only have Getters and Setters (Eclipse Hint: Use Source > Generate Getters and Setters \n * to create these easily)\n */\npublic class OfficeVisitBean {\n\tprivate long visitID = 0;\n\tprivate long patientID = 0;\n\tprivate long hcpID = 0;\n\tprivate String notes = \"\";\n\tprivate String visitDateStr = new SimpleDateFormat(\"MM/dd/yyyy\").format(new Date());\n\tprivate String hospitalID = \"\";\n\tprivate List<DiagnosisBean> diagnoses = new ArrayList<DiagnosisBean>();\n\tprivate List<PrescriptionBean> prescriptions = new ArrayList<PrescriptionBean>();\n\tprivate List<ProcedureBean> procedures = new ArrayList<ProcedureBean>();\n\n\tpublic OfficeVisitBean() {\n\t}\n\n\t/**\n\t * For use ONLY by DAOs\n\t * \n\t * @param visitID\n\t */\n\tpublic OfficeVisitBean(long visitID) {\n\t\tthis.visitID = visitID;\n\t}\n\n\tpublic long getID() {\n\t\treturn visitID;\n\t}\n\n\tpublic long getPatientID() {\n\t\treturn this.patientID;\n\t}\n\n\tpublic long getHcpID() {\n\t\treturn this.hcpID;\n\t}\n\n\tpublic String getNotes() {\n\t\treturn this.notes;\n\t}\n\n\tpublic Date getVisitDate() {\n\t\tDate d = null; \n\t\ttry {\n\t\t\td = new SimpleDateFormat(\"MM/dd/yyyy\").parse(visitDateStr);\n\t\t} catch (ParseException e) {\n\t\t\tSystem.out.println(e.toString());\n\t\t}\n\t\t\n\t\treturn d;\n\t}\n\n\tpublic String getVisitDateStr() {\n\t\treturn visitDateStr;\n\t}\n\n\tpublic List<DiagnosisBean> getDiagnoses() {\n\t\treturn diagnoses;\n\t}\n\n\tpublic List<PrescriptionBean> getPrescriptions() {\n\t\treturn prescriptions;\n\t}\n\n\tpublic List<ProcedureBean> getProcedures() {\n\t\treturn procedures;\n\t}\n\n\tpublic long getVisitID() {\n\t\treturn visitID;\n\t}\n\n\tpublic void setDiagnoses(List<DiagnosisBean> diagnoses) {\n\t\tthis.diagnoses = diagnoses;\n\t}\n\n\tpublic void setHcpID(long hcpID) {\n\t\tthis.hcpID = hcpID;\n\t}\n\n\tpublic void setPrescriptions(List<PrescriptionBean> prescriptions) {\n\t\tthis.prescriptions = prescriptions;\n\t}\n\n\tpublic void setNotes(String notes) {\n\t\tthis.notes = notes;\n\t}\n\n\tpublic void setPatientID(long patientID) {\n\t\tthis.patientID = patientID;\n\t}\n\n\tpublic void setProcedures(List<ProcedureBean> procedures) {\n\t\tthis.procedures = procedures;\n\t}\n\n\tpublic void setVisitDateStr(String visitDate) {\n\t\tthis.visitDateStr = visitDate;\n\t}\n\n\tpublic String getHospitalID() {\n\t\treturn hospitalID;\n\t}\n\n\tpublic void setHospitalID(String hospitalID) {\n\t\tthis.hospitalID = hospitalID;\n\t}\n\n}", "OperationalProfile.java": "package edu.ncsu.csc.itrust.beans;\n\nimport java.util.HashMap;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\n\n/**\n * A bean for storing operational profile data.\n * \n * A bean's purpose is to store data. Period. Little or no functionality is to be added to a bean \n * (with the exception of minor formatting such as concatenating phone numbers together). \n * A bean must only have Getters and Setters (Eclipse Hint: Use Source > Generate Getters and Setters \n * to create these easily)\n */\npublic class OperationalProfile {\n\tprivate int numTotalTransactions = 0;\n\tprivate int numPatientTransactions = 0;\n\tprivate int numPersonnelTransactions = 0;\n\tprivate HashMap<TransactionType, Integer> totalCount;\n\tprivate HashMap<TransactionType, Integer> personnelCount;\n\tprivate HashMap<TransactionType, Integer> patientCount;\n\n\tpublic OperationalProfile() {\n\t\ttotalCount = createEmptyMap();\n\t\tpersonnelCount = createEmptyMap();\n\t\tpatientCount = createEmptyMap();\n\t}\n\n\tprivate HashMap<TransactionType, Integer> createEmptyMap() {\n\t\tHashMap<TransactionType, Integer> map = new HashMap<TransactionType, Integer>(TransactionType\n\t\t\t\t.values().length);\n\t\tfor (TransactionType type : TransactionType.values()) {\n\t\t\tmap.put(type, 0);\n\t\t}\n\t\treturn map;\n\t}\n\n\tpublic HashMap<TransactionType, Integer> getTotalCount() {\n\t\treturn totalCount;\n\t}\n\n\tpublic void setTotalCount(HashMap<TransactionType, Integer> totalCount) {\n\t\tthis.totalCount = totalCount;\n\t}\n\n\tpublic HashMap<TransactionType, Integer> getPersonnelCount() {\n\t\treturn personnelCount;\n\t}\n\n\tpublic void setPersonnelCount(HashMap<TransactionType, Integer> personnelCount) {\n\t\tthis.personnelCount = personnelCount;\n\t}\n\n\tpublic HashMap<TransactionType, Integer> getPatientCount() {\n\t\treturn patientCount;\n\t}\n\n\tpublic void setPatientCount(HashMap<TransactionType, Integer> patientCount) {\n\t\tthis.patientCount = patientCount;\n\t}\n\n\tpublic void setNumTotalTransactions(int numTransactions) {\n\t\tthis.numTotalTransactions = numTransactions;\n\t}\n\n\tpublic int getNumTotalTransactions() {\n\t\treturn numTotalTransactions;\n\t}\n\n\tpublic int getNumPatientTransactions() {\n\t\treturn numPatientTransactions;\n\t}\n\n\tpublic void setNumPatientTransactions(int numPatientTransactions) {\n\t\tthis.numPatientTransactions = numPatientTransactions;\n\t}\n\n\tpublic int getNumPersonnelTransactions() {\n\t\treturn numPersonnelTransactions;\n\t}\n\n\tpublic void setNumPersonnelTransactions(int numPersonnelTransactions) {\n\t\tthis.numPersonnelTransactions = numPersonnelTransactions;\n\t}\n}", "PatientBean.java": "package edu.ncsu.csc.itrust.beans;\n\nimport java.io.Serializable;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport edu.ncsu.csc.itrust.enums.BloodType;\nimport edu.ncsu.csc.itrust.enums.Ethnicity;\nimport edu.ncsu.csc.itrust.enums.Gender;\n\n/**\n * A bean for storing data about a patient.\n * \n * A bean's purpose is to store data. Period. Little or no functionality is to be added to a bean \n * (with the exception of minor formatting such as concatenating phone numbers together). \n * A bean must only have Getters and Setters (Eclipse Hint: Use Source > Generate Getters and Setters \n * to create these easily)\n */\npublic class PatientBean implements Serializable {\n\tprivate static final long serialVersionUID = -6474182977342257877L;\n\t\n\tprivate long MID = 0;\n\tprivate String firstName = \"\";\n\tprivate String lastName = \"\";\n\tprivate String email = \"\";\n\tprivate String securityQuestion = \"\";\n\tprivate String securityAnswer = \"\";\n\tprivate String password = \"\";\n\tprivate String confirmPassword = \"\";\n\tprivate String streetAddress1 = \"\";\n\tprivate String streetAddress2 = \"\";\n\tprivate String city = \"\";\n\tprivate String state = \"AK\";\n\tprivate String zip1 = \"\";\n\tprivate String zip2 = \"\";\n\tprivate String phone1 = \"\";\n\tprivate String phone2 = \"\";\n\tprivate String phone3 = \"\";\n\tprivate String emergencyName = \"\";\n\tprivate String emergencyPhone1 = \"\";\n\tprivate String emergencyPhone2 = \"\";\n\tprivate String emergencyPhone3 = \"\";\n\tprivate String icName = \"\";\n\tprivate String icAddress1 = \"\";\n\tprivate String icAddress2 = \"\";\n\tprivate String icCity = \"\";\n\tprivate String icState = \"AK\";\n\tprivate String icZip1 = \"\";\n\tprivate String icZip2 = \"\";\n\tprivate String icPhone1 = \"\";\n\tprivate String icPhone2 = \"\";\n\tprivate String icPhone3 = \"\";\n\tprivate String icID = \"\";\n\tprivate String creditCardType = \"\";\n\tprivate String creditCardNumber = \"\";\n\t// Topical Health Information\n\tprivate String dateOfBirthStr = new SimpleDateFormat(\"MM/dd/yyyy\").format(new Date());\n\tprivate String dateOfDeathStr = \"\";\n\tprivate String causeOfDeath = \"\";\n\tprivate String motherMID = \"0\";\n\tprivate String fatherMID = \"0\";\n\tprivate BloodType bloodType = BloodType.NS;\n\tprivate Ethnicity ethnicity = Ethnicity.NotSpecified;\n\tprivate Gender gender = Gender.NotSpecified;\n\tprivate String topicalNotes = \"\";\n\tprivate String messageFilter= \"\";\n\n\tpublic String getMessageFilter() {\n\t\treturn messageFilter;\n\t}\n\n\tpublic void setMessageFilter(String messageFilter) {\n\t\tthis.messageFilter = messageFilter;\n\t}\n\n\tpublic BloodType getBloodType() {\n\t\treturn bloodType;\n\t}\n\n\tpublic void setBloodTypeStr(String bloodType) {\n\t\tthis.bloodType = BloodType.parse(bloodType);\n\t}\n\n\tpublic void setBloodType(BloodType bloodType) {\n\t\tthis.bloodType = bloodType;\n\t}\n\n\tpublic String getCauseOfDeath() {\n\t\treturn causeOfDeath;\n\t}\n\n\tpublic void setCauseOfDeath(String causeOfDeath) {\n\t\tthis.causeOfDeath = causeOfDeath;\n\t}\n\n\tpublic String getCity() {\n\t\treturn city;\n\t}\n\n\tpublic void setCity(String city) {\n\t\tthis.city = city;\n\t}\n\n\tpublic String getDateOfBirthStr() {\n\t\treturn dateOfBirthStr;\n\t}\n\n\tpublic Date getDateOfBirth() {\n\t\ttry {\n\t\t\treturn new SimpleDateFormat(\"MM/dd/yyyy\").parse(dateOfBirthStr);\n\t\t} catch (ParseException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic Date getDateOfDeath() {\n\t\ttry {\n\t\t\treturn new SimpleDateFormat(\"MM/dd/yyyy\").parse(dateOfDeathStr);\n\t\t} catch (ParseException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic void setDateOfBirthStr(String dateOfBirthStr) {\n\t\tthis.dateOfBirthStr = dateOfBirthStr;\n\t}\n\n\tpublic int getAge() {\n\t\ttry {\n\t\t\tlong ageInMs = System.currentTimeMillis()\n\t\t\t\t\t- new SimpleDateFormat(\"MM/dd/yyyy\").parse(dateOfBirthStr).getTime();\n\t\t\tlong age = ageInMs / (1000L * 60L * 60L * 24L * 365L);\n\t\t\treturn (int) age;\n\t\t} catch (ParseException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\tpublic long getAgeInDays() {\n\t\t\n\t\tlong age;\n\t\tlong ageInMs;\n\n\t\ttry {\n\t\t\tageInMs = System.currentTimeMillis()\n\t\t\t\t\t- new SimpleDateFormat(\"MM/dd/yyyy\").parse(dateOfBirthStr).getTime();\n\t\t\tage = ageInMs / (1000L * 60L * 60L * 24L);\n\t\n\t\t}\n\t\tcatch (ParseException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\treturn age;\n\t}\n\n\tpublic long getAgeInWeeks() {\n\t\t\n\t\tlong age;\n\t\tlong ageInMs;\n\n\t\ttry {\n\t\t\tageInMs = System.currentTimeMillis()\n\t\t\t\t\t- new SimpleDateFormat(\"MM/dd/yyyy\").parse(dateOfBirthStr).getTime();\n\t\t\tage = ageInMs / (1000L * 60L * 60L * 24L * 7L);\n\t\n\t\t}\n\t\tcatch (ParseException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\treturn age;\n\t}\n\t\n\tpublic String getDateOfDeathStr() {\n\t\treturn dateOfDeathStr;\n\t}\n\n\tpublic void setDateOfDeathStr(String dateOfDeathStr) {\n\t\tthis.dateOfDeathStr = dateOfDeathStr;\n\t}\n\n\tpublic String getEmail() {\n\t\treturn email;\n\t}\n\n\tpublic void setEmail(String email) {\n\t\tthis.email = email;\n\t}\n\n\tpublic String getEmergencyName() {\n\t\treturn emergencyName;\n\t}\n\n\tpublic void setEmergencyName(String emergencyName) {\n\t\tthis.emergencyName = emergencyName;\n\t}\n\n\tpublic Ethnicity getEthnicity() {\n\t\treturn ethnicity;\n\t}\n\n\tpublic void setEthnicityStr(String ethnicity) {\n\t\tthis.ethnicity = Ethnicity.parse(ethnicity);\n\t}\n\n\tpublic void setEthnicity(Ethnicity ethnicity) {\n\t\tthis.ethnicity = ethnicity;\n\t}\n\n\tpublic String getFatherMID() {\n\t\treturn fatherMID;\n\t}\n\n\tpublic void setFatherMID(String fatherMID) {\n\t\tthis.fatherMID = fatherMID;\n\t}\n\n\tpublic String getFullName() {\n\t\treturn getFirstName() + \" \" + getLastName();\n\t}\n\n\tpublic String getFirstName() {\n\t\treturn firstName;\n\t}\n\n\tpublic void setFirstName(String firstName) {\n\t\tthis.firstName = firstName;\n\t}\n\n\tpublic Gender getGender() {\n\t\treturn gender;\n\t}\n\n\tpublic void setGenderStr(String gender) {\n\t\tthis.gender = Gender.parse(gender);\n\t}\n\n\tpublic void setGender(Gender gender) {\n\t\tthis.gender = gender;\n\t}\n\n\tpublic String getIcAddress1() {\n\t\treturn icAddress1;\n\t}\n\n\tpublic void setIcAddress1(String icAddress1) {\n\t\tthis.icAddress1 = icAddress1;\n\t}\n\n\tpublic String getIcAddress2() {\n\t\treturn icAddress2;\n\t}\n\n\tpublic void setIcAddress2(String icAddress2) {\n\t\tthis.icAddress2 = icAddress2;\n\t}\n\n\t// Composition of city, state, and zip\n\tpublic String getIcAddress3() {\n\t\treturn getIcCity() + \", \" + getIcState() + \" \" + getIcZip();\n\t}\n\n\tpublic String getIcCity() {\n\t\treturn icCity;\n\t}\n\n\tpublic void setIcCity(String icCity) {\n\t\tthis.icCity = icCity;\n\t}\n\n\tpublic String getIcID() {\n\t\treturn icID;\n\t}\n\n\tpublic void setIcID(String icID) {\n\t\tthis.icID = icID;\n\t}\n\t\n\tpublic String getCreditCardType() {\n\t\treturn creditCardType;\n\t}\n\t\n\tpublic void setCreditCardType(String creditCardType) {\n\t\tthis.creditCardType = creditCardType;\n\t}\n\t\n\tpublic String getCreditCardNumber() {\n\t\treturn creditCardNumber;\n\t}\n\t\n\tpublic void setCreditCardNumber(String creditCardNumber) {\n\t\tthis.creditCardNumber = creditCardNumber;\n\t}\n\n\tpublic String getIcName() {\n\t\treturn icName;\n\t}\n\n\tpublic void setIcName(String icName) {\n\t\tthis.icName = icName;\n\t}\n\n\tpublic String getIcZip() {\n\t\tif (getIcZip2() != null && !\"\".equals(getIcZip2()))\n\t\t\treturn getIcZip1() + \"-\" + getIcZip2();\n\t\telse\n\t\t\treturn getIcZip1();\n\t}\n\n\tpublic String getIcZip1() {\n\t\treturn icZip1;\n\t}\n\n\tpublic void setIcZip1(String icZip1) {\n\t\tthis.icZip1 = icZip1;\n\t}\n\n\tpublic String getIcZip2() {\n\t\treturn icZip2;\n\t}\n\n\tpublic void setIcZip2(String icZip2) {\n\t\tthis.icZip2 = icZip2;\n\t}\n\n\tpublic String getIcState() {\n\t\treturn icState;\n\t}\n\n\tpublic void setIcState(String icState) {\n\t\tthis.icState = icState;\n\t}\n\n\tpublic String getLastName() {\n\t\treturn lastName;\n\t}\n\n\tpublic void setLastName(String lastName) {\n\t\tthis.lastName = lastName;\n\t}\n\n\tpublic long getMID() {\n\t\treturn MID;\n\t}\n\n\tpublic void setMID(long mid) {\n\t\tMID = mid;\n\t}\n\n\tpublic String getMotherMID() {\n\t\treturn motherMID;\n\t}\n\n\tpublic void setMotherMID(String motherMID) {\n\t\tthis.motherMID = motherMID;\n\t}\n\n\t// Note that there is no setter for this - it's stored in the database as 3 separate columns\n\tpublic String getPhone() {\n\t\treturn getPhone1() + \"-\" + getPhone2() + \"-\" + getPhone3();\n\t}\n\n\tpublic String getPhone1() {\n\t\treturn phone1;\n\t}\n\n\tpublic String getPhone2() {\n\t\treturn phone2;\n\t}\n\n\tpublic String getPhone3() {\n\t\treturn phone3;\n\t}\n\n\tpublic void setPhone1(String phone1) {\n\t\tthis.phone1 = phone1;\n\t}\n\n\tpublic void setPhone2(String phone2) {\n\t\tthis.phone2 = phone2;\n\t}\n\n\tpublic void setPhone3(String phone3) {\n\t\tthis.phone3 = phone3;\n\t}\n\n\tpublic String getSecurityAnswer() {\n\t\treturn securityAnswer;\n\t}\n\n\tpublic void setSecurityAnswer(String securityAnswer) {\n\t\tthis.securityAnswer = securityAnswer;\n\t}\n\n\tpublic String getSecurityQuestion() {\n\t\treturn securityQuestion;\n\t}\n\n\tpublic void setSecurityQuestion(String securityQuestion) {\n\t\tthis.securityQuestion = securityQuestion;\n\t}\n\n\tpublic String getState() {\n\t\treturn state;\n\t}\n\n\tpublic void setState(String state) {\n\t\tthis.state = state;\n\t}\n\n\tpublic String getStreetAddress1() {\n\t\treturn streetAddress1;\n\t}\n\n\tpublic void setStreetAddress1(String streetAddress1) {\n\t\tthis.streetAddress1 = streetAddress1;\n\t}\n\n\tpublic String getStreetAddress2() {\n\t\treturn streetAddress2;\n\t}\n\n\tpublic void setStreetAddress2(String streetAddress2) {\n\t\tthis.streetAddress2 = streetAddress2;\n\t}\n\n\t// Composition of the city, state, zip\n\tpublic String getStreetAddress3() {\n\t\treturn getCity() + \", \" + getState() + \" \" + getZip();\n\t}\n\n\tpublic String getTopicalNotes() {\n\t\treturn topicalNotes;\n\t}\n\n\tpublic void setTopicalNotes(String topicalNotes) {\n\t\tthis.topicalNotes = topicalNotes;\n\t}\n\n\tpublic String getZip() {\n\t\tif (getZip2() != null && !\"\".equals(getZip2()))\n\t\t\treturn getZip1() + \"-\" + getZip2();\n\t\telse\n\t\t\treturn getZip1();\n\t}\n\n\tpublic String getZip1() {\n\t\treturn zip1;\n\t}\n\n\tpublic void setZip1(String zip1) {\n\t\tthis.zip1 = zip1;\n\t}\n\n\tpublic String getZip2() {\n\t\treturn zip2;\n\t}\n\n\tpublic void setZip2(String zip2) {\n\t\tthis.zip2 = zip2;\n\t}\n\n\t// Same idea as \"phone\"\n\tpublic String getEmergencyPhone() {\n\t\treturn getEmergencyPhone1() + \"-\" + getEmergencyPhone2() + \"-\" + getEmergencyPhone3();\n\t}\n\n\tpublic String getEmergencyPhone1() {\n\t\treturn emergencyPhone1;\n\t}\n\n\tpublic void setEmergencyPhone1(String emergencyPhone1) {\n\t\tthis.emergencyPhone1 = emergencyPhone1;\n\t}\n\n\tpublic String getEmergencyPhone2() {\n\t\treturn emergencyPhone2;\n\t}\n\n\tpublic void setEmergencyPhone2(String emergencyPhone2) {\n\t\tthis.emergencyPhone2 = emergencyPhone2;\n\t}\n\n\tpublic String getEmergencyPhone3() {\n\t\treturn emergencyPhone3;\n\t}\n\n\tpublic void setEmergencyPhone3(String emergencyPhone3) {\n\t\tthis.emergencyPhone3 = emergencyPhone3;\n\t}\n\n\t// Same idea as \"phone\"\n\tpublic String getIcPhone() {\n\t\treturn getIcPhone1() + \"-\" + getIcPhone2() + \"-\" + getIcPhone3();\n\t}\n\n\tpublic String getIcPhone1() {\n\t\treturn icPhone1;\n\t}\n\n\tpublic void setIcPhone1(String icPhone1) {\n\t\tthis.icPhone1 = icPhone1;\n\t}\n\n\tpublic String getIcPhone2() {\n\t\treturn icPhone2;\n\t}\n\n\tpublic void setIcPhone2(String icPhone2) {\n\t\tthis.icPhone2 = icPhone2;\n\t}\n\n\tpublic String getIcPhone3() {\n\t\treturn icPhone3;\n\t}\n\n\tpublic void setIcPhone3(String icPhone3) {\n\t\tthis.icPhone3 = icPhone3;\n\t}\n\n\tpublic String getConfirmPassword() {\n\t\treturn confirmPassword;\n\t}\n\n\tpublic void setConfirmPassword(String confirmPassword) {\n\t\tthis.confirmPassword = confirmPassword;\n\t}\n\n\tpublic String getPassword() {\n\t\treturn password;\n\t}\n\n\tpublic void setPassword(String password) {\n\t\tthis.password = password;\n\t}\n}", "PatientVisitBean.java": "package edu.ncsu.csc.itrust.beans;\n\n/**\n * A bean for storing data about a patient's visit.\n * \n * A bean's purpose is to store data. Period. Little or no functionality is to be added to a bean \n * (with the exception of minor formatting such as concatenating phone numbers together). \n * A bean must only have Getters and Setters (Eclipse Hint: Use Source > Generate Getters and Setters \n * to create these easily)\n */\npublic class PatientVisitBean {\n\tprivate PatientBean patient = null;\n\tprivate String PatientName = \"\";\n\tprivate String Address1 = \"\";\n\tprivate String Address2 = \"\";\n\tprivate String LastOVDateM = \"\";\n\tprivate String LastOVDateD = \"\";\n\tprivate String LastOVDateY = \"\";\n\tprivate String LastOVDate = \"\";\n\t\n\tpublic String getLastOVDate() {\n\t\treturn LastOVDate;\n\t}\n\n\tpublic void setLastOVDate(String lastOVDate) {\n\t\tLastOVDate = lastOVDate;\n\t}\n\n\tpublic String getLastOVDateM() {\n\t\treturn LastOVDateM;\n\t}\n\n\tpublic void setLastOVDateM(String lastOVDateM) {\n\t\tLastOVDateM = lastOVDateM;\n\t}\n\n\tpublic String getLastOVDateD() {\n\t\treturn LastOVDateD;\n\t}\n\n\tpublic void setLastOVDateD(String lastOVDateD) {\n\t\tLastOVDateD = lastOVDateD;\n\t}\n\n\tpublic String getLastOVDateY() {\n\t\treturn LastOVDateY;\n\t}\n\n\tpublic void setLastOVDateY(String lastOVDateY) {\n\t\tLastOVDateY = lastOVDateY;\n\t}\n\n\tpublic PatientVisitBean() {\n\t\t\n\t}\n\n\tpublic String getPatientName() {\n\t\treturn PatientName;\n\t}\n\n\tpublic void setPatientName(String patientName) {\n\t\tPatientName = patientName;\n\t}\n\n\tpublic String getAddress1() {\n\t\treturn Address1;\n\t}\n\n\tpublic void setAddress1(String address1) {\n\t\tAddress1 = address1;\n\t}\n\n\tpublic String getAddress2() {\n\t\treturn Address2;\n\t}\n\n\tpublic void setAddress2(String address2) {\n\t\tAddress2 = address2;\n\t}\n\n\tpublic PatientBean getPatient() {\n\t\treturn patient;\n\t}\n\n\tpublic void setPatient(PatientBean patient) {\n\t\tthis.patient = patient;\n\t}\n\n}", "PersonnelBean.java": "package edu.ncsu.csc.itrust.beans;\n\nimport edu.ncsu.csc.itrust.enums.Role;\nimport java.io.Serializable;\nimport java.util.List;\n\n/**\n * A bean for storing data about a hospital employee.\n * \n * A bean's purpose is to store data. Period. Little or no functionality is to be added to a bean \n * (with the exception of minor formatting such as concatenating phone numbers together). \n * A bean must only have Getters and Setters (Eclipse Hint: Use Source > Generate Getters and Setters \n * to create these easily)\n */\npublic class PersonnelBean implements Serializable {\n\tprivate static final long serialVersionUID = 6575544592646001050L;\n\t\n\tprivate long MID = 0;\n\tprivate long AMID = 0;\n\tprivate Role role;\n\tprivate String firstName = \"\";\n\tprivate String lastName = \"\";\n\tprivate String password = \"\";\n\tprivate String confirmPassword = \"\";\n\tprivate String securityQuestion = \"\";\n\tprivate String securityAnswer = \"\";\n\tprivate String streetAddress1 = \"\";\n\tprivate String streetAddress2 = \"\";\n\tprivate String city = \"\";\n\tprivate String state = \"\";\n\tprivate String zip1 = \"\";\n\tprivate String zip2 = \"\";\n\tprivate String phone1 = \"\";\n\tprivate String phone2 = \"\";\n\tprivate String phone3 = \"\";\n\tprivate String email = \"\";\n\tprivate String specialty = \"\";\n\tprivate String messageFilter= \"\";\n\n\tpublic String getMessageFilter() {\n\t\treturn messageFilter;\n\t}\n\n\tpublic void setMessageFilter(String messageFilter) {\n\t\tthis.messageFilter = messageFilter;\n\t}\n\n\tpublic String getEmail() {\n\t\treturn email;\n\t}\n\n\tpublic void setEmail(String email) {\n\t\tthis.email = email;\n\t}\n\n\tpublic long getAMID() {\n\t\treturn AMID;\n\t}\n\n\tpublic void setAMID(long amid) {\n\t\tAMID = amid;\n\t}\n\n\tpublic String getCity() {\n\t\treturn city;\n\t}\n\n\tpublic void setCity(String city) {\n\t\tthis.city = city;\n\t}\n\n\tpublic String getConfirmPassword() {\n\t\treturn confirmPassword;\n\t}\n\n\tpublic void setConfirmPassword(String confirmPassword) {\n\t\tthis.confirmPassword = confirmPassword;\n\t}\n\n\tpublic String getFirstName() {\n\t\treturn firstName;\n\t}\n\n\tpublic void setFirstName(String firstName) {\n\t\tthis.firstName = firstName;\n\t}\n\n\tpublic String getLastName() {\n\t\treturn lastName;\n\t}\n\n\tpublic void setLastName(String lastName) {\n\t\tthis.lastName = lastName;\n\t}\n\n\tpublic String getFullName() {\n\t\treturn getFirstName() + \" \" + getLastName();\n\t}\n\n\tpublic long getMID() {\n\t\treturn MID;\n\t}\n\n\tpublic void setMID(long mid) {\n\t\tMID = mid;\n\t}\n\n\tpublic String getPassword() {\n\t\treturn password;\n\t}\n\n\tpublic void setPassword(String password) {\n\t\tthis.password = password;\n\t}\n\n\tpublic String getPhone() {\n\t\treturn phone1 + \"-\" + phone2 + \"-\" + phone3;\n\t}\n\n\tpublic String getPhone1() {\n\t\treturn phone1;\n\t}\n\n\tpublic void setPhone1(String phone1) {\n\t\tthis.phone1 = phone1;\n\t}\n\n\tpublic String getPhone2() {\n\t\treturn phone2;\n\t}\n\n\tpublic void setPhone2(String phone2) {\n\t\tthis.phone2 = phone2;\n\t}\n\n\tpublic String getPhone3() {\n\t\treturn phone3;\n\t}\n\n\tpublic void setPhone3(String phone3) {\n\t\tthis.phone3 = phone3;\n\t}\n\n\tpublic Role getRole() {\n\t\treturn role;\n\t}\n\n\tpublic void setRole(Role role) {\n\t\tthis.role = role;\n\t}\n\n\tpublic String getSecurityAnswer() {\n\t\treturn securityAnswer;\n\t}\n\n\tpublic void setSecurityAnswer(String securityAnswer) {\n\t\tthis.securityAnswer = securityAnswer;\n\t}\n\n\tpublic String getSecurityQuestion() {\n\t\treturn securityQuestion;\n\t}\n\n\tpublic void setSecurityQuestion(String securityQuestion) {\n\t\tthis.securityQuestion = securityQuestion;\n\t}\n\n\tpublic String getState() {\n\t\treturn state;\n\t}\n\n\tpublic void setState(String state) {\n\t\tthis.state = state;\n\t}\n\n\tpublic String getStreetAddress1() {\n\t\treturn streetAddress1;\n\t}\n\n\tpublic void setStreetAddress1(String streetAddress1) {\n\t\tthis.streetAddress1 = streetAddress1;\n\t}\n\n\tpublic String getStreetAddress2() {\n\t\treturn streetAddress2;\n\t}\n\n\tpublic void setStreetAddress2(String streetAddress2) {\n\t\tthis.streetAddress2 = streetAddress2;\n\t}\n\n\tpublic String getZip() {\n\t\tif (getZip2() != null && !\"\".equals(getZip2()))\n\t\t\treturn getZip1() + \"-\" + getZip2();\n\t\telse\n\t\t\treturn getZip1();\n\t}\n\n\tpublic String getZip1() {\n\t\treturn zip1;\n\t}\n\n\tpublic void setZip1(String zip1) {\n\t\tthis.zip1 = zip1;\n\t}\n\n\tpublic String getZip2() {\n\t\treturn zip2;\n\t}\n\n\tpublic void setZip2(String zip2) {\n\t\tthis.zip2 = zip2;\n\t}\n\t\n\tpublic String getSpecialty() {\n\t\treturn specialty;\n\t}\n\t\n\tpublic void setSpecialty(String specialty) {\n\t\tthis.specialty = specialty;\n\t}\n\t\n\t/*\n\tpublic int compareTo(PersonnelBean other) {\n\t\tif (MID == other.getMID()) return 0;\n\t\tif (MID > other.getMID()) return 1;\n\t\treturn -1;\n\t}*/\n\t\n\tpublic int getIndexIn(List<PersonnelBean> list) {\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tif (list.get(i).MID == this.MID) return i;\n\t\t}\n\t\treturn -1;\n\t}\n\n}", "PrescriptionBean.java": "package edu.ncsu.csc.itrust.beans;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * A bean for storing data about a prescription.\n * \n * A bean's purpose is to store data. Period. Little or no functionality is to be added to a bean \n * (with the exception of minor formatting such as concatenating phone numbers together). \n * A bean must only have Getters and Setters (Eclipse Hint: Use Source > Generate Getters and Setters \n * to create these easily)\n */\npublic class PrescriptionBean {\n\tprivate long id = 0L;\n\tprivate MedicationBean medication = new MedicationBean();\n\tprivate long visitID = 0L;\n\tprivate String startDateStr = new SimpleDateFormat(\"MM/dd/yyyy\").format(new Date());\n\tprivate String endDateStr = new SimpleDateFormat(\"MM/dd/yyyy\").format(new Date());\n\tprivate int dosage = 0;\n\tprivate String instructions = \"\";\n\n\tpublic PrescriptionBean() {\n\t}\n\n\t@Override\n\tpublic boolean equals(Object other) {\n\t\treturn (other != null) && this.getClass().equals(other.getClass())\n\t\t\t\t&& this.equals((PrescriptionBean) other);\n\t}\n\n\tprivate boolean equals(PrescriptionBean other) {\n\t\treturn (medication == other.medication || (medication != null && medication.equals(other.medication)))\n\t\t\t\t&& visitID == other.visitID\n\t\t\t\t&& startDateStr.equals(other.startDateStr)\n\t\t\t\t&& endDateStr.equals(other.endDateStr)\n\t\t\t\t&& dosage == other.dosage\n\t\t\t\t&& instructions.equals(other.instructions);\n\t}\n\n\tpublic int hashCode() {\n\t\tassert false : \"hashCode not designed\";\n\t\treturn 42; // any arbitrary constant will do\n\t}\n\n\tpublic int getDosage() {\n\t\treturn dosage;\n\t}\n\n\tpublic void setDosage(int dosage) {\n\t\tthis.dosage = dosage;\n\t}\n\n\tpublic Date getEndDate() {\n\t\ttry {\n\t\t\treturn new SimpleDateFormat(\"MM/dd/yyyy\").parse(endDateStr);\n\t\t} catch (java.text.ParseException e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic void setEndDateStr(String endDate) {\n\t\tthis.endDateStr = endDate;\n\t}\n\n\tpublic String getInstructions() {\n\t\treturn instructions;\n\t}\n\n\tpublic void setInstructions(String instruction) {\n\t\tthis.instructions = instruction;\n\t}\n\n\tpublic MedicationBean getMedication() {\n\t\treturn medication;\n\t}\n\n\tpublic void setMedication(MedicationBean medication) {\n\t\tthis.medication = medication;\n\t}\n\n\tpublic Date getStartDate() {\n\t\ttry {\n\t\t\treturn new SimpleDateFormat(\"MM/dd/yyyy\").parse(startDateStr);\n\t\t} catch (ParseException e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic String getStartDateStr() {\n\t\treturn startDateStr;\n\t}\n\n\tpublic String getEndDateStr() {\n\t\treturn endDateStr;\n\t}\n\n\tpublic void setStartDateStr(String startDate) {\n\t\tthis.startDateStr = startDate;\n\t}\n\n\tpublic long getVisitID() {\n\t\treturn visitID;\n\t}\n\n\tpublic void setVisitID(long visitID) {\n\t\tthis.visitID = visitID;\n\t}\n\n\tpublic long getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(long id) {\n\t\tthis.id = id;\n\t}\n\n}", "PrescriptionReportBean.java": "package edu.ncsu.csc.itrust.beans;\n\n/**\n * This is the container bean for the Prescription Report requirement. It contains a PrescriptionBean (which\n * in turn contains a Medication Bean), and an office visit bean. <br />\n * <br />\n * This was made so that the prescription report could be done all in one clean query.<br />\n * <br />\n * See {@link PrescriptionBean} See {@link OfficeVisitBean}\n * \n * @author Andy Meneely\n * \n */\npublic class PrescriptionReportBean {\n\tPrescriptionBean prescription;\n\tOfficeVisitBean officeVisit;\n\n\tpublic PrescriptionReportBean() {\n\t}\n\n\tpublic PrescriptionBean getPrescription() {\n\t\treturn prescription;\n\t}\n\n\tpublic void setPrescription(PrescriptionBean prescription) {\n\t\tthis.prescription = prescription;\n\t}\n\n\tpublic OfficeVisitBean getOfficeVisit() {\n\t\treturn officeVisit;\n\t}\n\n\tpublic void setOfficeVisit(OfficeVisitBean officeVisit) {\n\t\tthis.officeVisit = officeVisit;\n\t}\n}", "ProcedureBean.java": "package edu.ncsu.csc.itrust.beans;\n\nimport java.sql.Date;\n\n/**\n * A bean for storing data about a procedure.\n * \n * A bean's purpose is to store data. Period. Little or no functionality is to be added to a bean \n * (with the exception of minor formatting such as concatenating phone numbers together). \n * A bean must only have Getters and Setters (Eclipse Hint: Use Source > Generate Getters and Setters \n * to create these easily)\n */\npublic class ProcedureBean {\n\n\tprivate long ovProcedureID = 0L;\n\tprivate String CPTCode;\n\tprivate String description;\n\tprivate String attribute;\n\tprivate Date date;\n\tprivate String hcpid;\n\n\tpublic ProcedureBean() {\n\t}\n\n\tpublic ProcedureBean(String code) {\n\t\tCPTCode = code;\n\t}\n\n\tpublic ProcedureBean(String code, String description) {\n\t\tCPTCode = code;\n\t\tthis.description = description;\n\t}\n\n\tpublic ProcedureBean(String code, String description, String attribute) {\n\t\tCPTCode = code;\n\t\tthis.description = description;\n\t\tthis.attribute = attribute;\n\t}\n\t\n\tpublic ProcedureBean(String code, String description, String attribute, String hcpid) {\n\t\tCPTCode = code;\n\t\tthis.description = description;\n\t\tthis.attribute = attribute;\n\t\tthis.hcpid = hcpid;\n\t}\n\t\n\t/**\n\t * Gets the CPT Code for this procedure\n\t * \n\t * @return The CPT Code for this procedure\n\t */\n\tpublic String getCPTCode() {\n\t\treturn CPTCode;\n\t}\n\n\tpublic void setCPTCode(String code) {\n\t\tCPTCode = code;\n\t}\n\t\n\t/**\n\t * Gets the CPT Description for this procedure\n\t * \n\t * @return The CPT Description for this procedure\n\t */\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\t}\n\t\n\t/**\n\t * Gets the HCP ID of the HCP administering the immunization\n\t * @return String\n\t */\n\tpublic String getHcpid() {\n\t\treturn hcpid;\n\t}\n\n\tpublic void setHcpid(String hcpid) {\n\t\tthis.hcpid = hcpid;\n\t}\n\t\t\n\t/**\n\t * Gets the CPT attribute, used to determine if this is an immunization\n\t * @return String\n\t */\n\tpublic String getAttribute() {\n\t\treturn attribute;\n\t}\n\n\t/**\n\t * Sets the CPT attribute, used to determine if this is an immunization\n\t * @param String\n\t */\n\tpublic void setAttribute(String attrib) {\n\t\tattribute = attrib;\n\t}\n\t\n\tpublic long getOvProcedureID() {\n\t\treturn ovProcedureID;\n\t}\n\n\tpublic void setOvProcedureID(long ovProcedureID) {\n\t\tthis.ovProcedureID = ovProcedureID;\n\t}\n\t\n\tpublic Date getDate() {\n\t\treturn date;\n\t}\n\t\n\tpublic void setDate(Date d) {\n\t\tdate = d;\n\t}\n\n}", "ReferralBean.java": "package edu.ncsu.csc.itrust.beans;\n\n/**\n * A bean for storing data about a medical referral.\n * \n * A bean's purpose is to store data. Period. Little or no functionality is to be added to a bean \n * (with the exception of minor formatting such as concatenating phone numbers together). \n * A bean must only have Getters and Setters (Eclipse Hint: Use Source > Generate Getters and Setters \n * to create these easily)\n */\npublic class ReferralBean {\n\tprivate long id = 0L;\n\tprivate long patientID = 0L;\n\tprivate long senderID = 0L;\n\tprivate long receiverID = 0L;\n\tprivate String referralDetails = \"\";\n\tprivate String consultationDetails = \"\";\n\tprivate ReferralStatus status = ReferralStatus.Pending;\n\t\n\tpublic enum ReferralStatus {\n\t\tPending,\n\t\tFinished,\n\t\tDeclined\n\t}\n\n\tpublic ReferralBean() {\n\t}\n\n\t@Override\n\tpublic boolean equals(Object other) {\n\t\treturn (other != null) && this.getClass().equals(other.getClass())\n\t\t\t\t&& this.equals((ReferralBean) other);\n\t}\n\n\tprivate boolean equals(ReferralBean other) {\n\t\treturn (id == other.id\n\t\t\t\t&& senderID == other.senderID\n\t\t\t\t&& receiverID == other.receiverID\n\t\t\t\t&& referralDetails.equals(other.referralDetails)\n\t\t\t\t&& consultationDetails.equals(other.consultationDetails)\n\t\t\t\t&& status.equals(other.status));\n\t}\n\n\tpublic int hashCode() {\n\t\tassert false : \"hashCode not designed\";\n\t\treturn 42; // any arbitrary constant will do\n\t}\n\n\tpublic long getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(long id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic long getSenderID() {\n\t\treturn senderID;\n\t}\n\n\tpublic void setSenderID(long senderID) {\n\t\tthis.senderID = senderID;\n\t}\n\n\tpublic long getReceiverID() {\n\t\treturn receiverID;\n\t}\n\n\tpublic void setReceiverID(long receiverID) {\n\t\tthis.receiverID = receiverID;\n\t}\n\n\tpublic String getReferralDetails() {\n\t\treturn referralDetails;\n\t}\n\n\tpublic void setReferralDetails(String referralDetails) {\n\t\tthis.referralDetails = referralDetails;\n\t}\n\n\tpublic String getConsultationDetails() {\n\t\treturn consultationDetails;\n\t}\n\n\tpublic void setConsultationDetails(String consultationDetails) {\n\t\tthis.consultationDetails = consultationDetails;\n\t}\n\n\tpublic ReferralStatus getStatus() {\n\t\treturn status;\n\t}\n\n\tpublic void setStatus(ReferralStatus status) {\n\t\tthis.status = status;\n\t}\n\n\tpublic long getPatientID() {\n\t\treturn patientID;\n\t}\n\n\tpublic void setPatientID(long patientID) {\n\t\tthis.patientID = patientID;\n\t}\n\n\t\n\n}", "RemoteMonitoringDataBean.java": "package edu.ncsu.csc.itrust.beans;\n\nimport java.sql.Timestamp;\n\n/**\n * A bean for storing remote monitoring data for patients.\n * \n * A bean's purpose is to store data. Period. Little or no functionality is to be added to a bean \n * (with the exception of minor formatting such as concatenating phone numbers together). \n * A bean must only have Getters and Setters (Eclipse Hint: Use Source > Generate Getters and Setters \n * to create these easily)\n */\npublic class RemoteMonitoringDataBean {\n\tprivate long patientMID;\n\tprivate Timestamp time;\n\tprivate int systolicBloodPressure;\n\tprivate int diastolicBloodPressure;\n\tprivate int glucoseLevel;\n\tprivate String reporterRole;\n\tprivate long reporterMID;\n\n\t/**\n\t * Constructor with no parameters\n\t */\n\tpublic RemoteMonitoringDataBean() {\n\t\t\n\t}\n\t\n\t/**\n\t * Constructor with loggedInMID parameter\n\t */\n\tpublic RemoteMonitoringDataBean(long patientMID) {\n\t\tthis.patientMID = patientMID;\n\t}\n\t\n\tpublic long getReporterMID() {\n\t\treturn reporterMID;\n\t}\n\n\tpublic void setReporterMID(long reporterMID) {\n\t\tthis.reporterMID = reporterMID;\n\t}\n\t\n\tpublic long getPatientMID() {\n\t\treturn patientMID;\n\t}\n\t\n\tpublic void setLoggedInMID(long patientMID) {\n\t\tthis.patientMID = patientMID;\n\t}\n\t\n\tpublic Timestamp getTime() {\n\t\treturn time;\n\t}\n\t\n\tpublic void setTime(Timestamp time) {\n\t\tthis.time = time;\n\t}\n\t\n\tpublic int getSystolicBloodPressure() {\n\t\treturn systolicBloodPressure;\n\t}\n\t\n\tpublic void setSystolicBloodPressure(int systolicBloodPressure) {\n\t\tthis.systolicBloodPressure = systolicBloodPressure;\n\t}\n\t\n\tpublic int getDiastolicBloodPressure() {\n\t\treturn diastolicBloodPressure;\n\t}\n\t\n\tpublic void setDiastolicBloodPressure(int diastolicBloodPressure) {\n\t\tthis.diastolicBloodPressure = diastolicBloodPressure;\n\t}\n\t\n\tpublic int getGlucoseLevel() {\n\t\treturn glucoseLevel;\n\t}\n\t\n\tpublic void setGlucoseLevel(int glucoseLevel) {\n\t\tthis.glucoseLevel = glucoseLevel;\n\t}\n\t\n\tpublic String getReporterRole() {\n\t\treturn reporterRole;\n\t}\n\n\tpublic void setReporterRole(String reporterRole) {\n\t\tthis.reporterRole = reporterRole;\n\t}\n\n}", "ReportRequestBean.java": "package edu.ncsu.csc.itrust.beans;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport edu.ncsu.csc.itrust.Messages;\n\n/**\n * A bean for storing data about a report request.\n * \n * A bean's purpose is to store data. Period. Little or no functionality is to be added to a bean \n * (with the exception of minor formatting such as concatenating phone numbers together). \n * A bean must only have Getters and Setters (Eclipse Hint: Use Source > Generate Getters and Setters \n * to create these easily)\n */\npublic class ReportRequestBean {\n\tprivate long ID = 0L;\n\tprivate long requesterMID = 0L;\n\tprivate long patientMID = 0L;\n//\tprivate long approverMID = 0L;\n\tprivate Date requestedDate;\n//\tprivate Date approvedDate;\n\tprivate Date viewedDate;\n\tprivate String status = \"\"; //$NON-NLS-1$\n//\tprivate String comment = \"\"; //$NON-NLS-1$\n\n\tpublic final static String dateFormat = \"MM/dd/yyyy HH:mm\"; //$NON-NLS-1$\n\n\tpublic final static String Requested = Messages.getString(\"ReportRequestBean.requested\"); //$NON-NLS-1$\n//\tpublic final static String Approved = Messages.getString(\"ReportRequestBean.approved\"); //$NON-NLS-1$\n//\tpublic final static String Rejected = Messages.getString(\"ReportRequestBean.rejected\"); //$NON-NLS-1$\n\tpublic final static String Viewed = Messages.getString(\"ReportRequestBean.viewed\"); //$NON-NLS-1$\n\n\tpublic ReportRequestBean() {\n\t}\n\n\tpublic void setID(long iD) {\n\t\tID = iD;\n\t}\n\n\tpublic long getID() {\n\t\treturn ID;\n\t}\n\n\tpublic void setRequesterMID(long requesterMID) {\n\t\tthis.requesterMID = requesterMID;\n\t}\n\n\tpublic long getRequesterMID() {\n\t\treturn requesterMID;\n\t}\n\n\tpublic void setPatientMID(long patientMID) {\n\t\tthis.patientMID = patientMID;\n\t}\n\n\tpublic long getPatientMID() {\n\t\treturn patientMID;\n\t}\n\n//\tpublic void setApproverMID(long approverMID) {\n//\t\tthis.approverMID = approverMID;\n//\t}\n//\n//\tpublic long getApproverMID() {\n//\t\treturn approverMID;\n//\t}\n\n\tpublic void setRequestedDate(Date requestedDate) {\n\t\tthis.requestedDate = (requestedDate == null ? null : (Date) requestedDate.clone());\n\t}\n\n\tpublic void setRequestedDateString(String s) {\n\t\ttry {\n\t\t\tsetRequestedDate(new SimpleDateFormat(dateFormat).parse(s));\n\t\t} catch (ParseException ex) {\n\t\t\tSystem.out.println(ex.getMessage());\n\t\t}\n\t}\n\n\tpublic Date getRequestedDate() {\n\t\treturn (requestedDate == null ? null : (Date) requestedDate.clone());\n\t}\n\n\tpublic String getRequestedDateString() {\n\t\tif (requestedDate == null)\n\t\t\treturn \"\"; //$NON-NLS-1$\n\t\treturn new SimpleDateFormat(dateFormat).format(requestedDate);\n\t}\n\n//\tpublic void setApprovedDate(Date approvedDate) {\n//\t\tthis.approvedDate = (approvedDate == null ? null : (Date) approvedDate.clone());\n//\t}\n//\n//\tpublic void setApprovedDateString(String s) {\n//\t\ttry {\n//\t\t\tsetApprovedDate(new SimpleDateFormat(dateFormat).parse(s));\n//\t\t} catch (ParseException ex) {\n//\t\t\tSystem.out.println(ex.getMessage());\n//\t\t}\n//\t}\n//\n//\tpublic Date getApprovedDate() {\n//\t\treturn (approvedDate == null ? null : (Date) approvedDate.clone());\n//\t}\n//\n//\tpublic String getApprovedDateString() {\n//\t\tif (approvedDate == null)\n//\t\t\treturn \"\"; //$NON-NLS-1$\n//\t\treturn new SimpleDateFormat(dateFormat).format(approvedDate);\n//\t}\n\n\tpublic void setViewedDate(Date viewedDate) {\n\t\tthis.viewedDate = (viewedDate == null ? null : (Date) viewedDate.clone());\n\t}\n\n\tpublic void setViewedDateString(String s) {\n\t\ttry {\n\t\t\tsetViewedDate(new SimpleDateFormat(dateFormat).parse(s));\n\t\t} catch (ParseException ex) {\n\t\t\tSystem.out.println(ex.getMessage());\n\t\t}\n\t}\n\n\tpublic Date getViewedDate() {\n\t\treturn (viewedDate == null ? null : (Date) viewedDate.clone());\n\t}\n\n\tpublic String getViewedDateString() {\n\t\tif (viewedDate == null)\n\t\t\treturn \"\"; //$NON-NLS-1$\n\t\t//DateFormat dateFormatter = DateFormat.getDateTimeInstance(DateFormat.SHORT,DateFormat.SHORT,Localization.instance().getCurrentLocale());\n\t\t//return dateFormatter.format(viewedDate);\n\t\treturn new SimpleDateFormat(dateFormat).format(viewedDate);\n\t}\n\n\tpublic void setStatus(String status) {\n\t\tthis.status = status;\n\t}\n\n\tpublic String getStatus() {\n\t\treturn status;\n\t}\n\n//\tpublic void setComment(String comment) {\n//\t\tthis.comment = comment;\n//\t}\n//\n//\tpublic String getComment() {\n//\t\treturn comment;\n//\t}\n}", "SecurityQA.java": "package edu.ncsu.csc.itrust.beans;\n\n/**\n * A bean for storing data about a security question and answer.\n * \n * A bean's purpose is to store data. Period. Little or no functionality is to be added to a bean \n * (with the exception of minor formatting such as concatenating phone numbers together). \n * A bean must only have Getters and Setters (Eclipse Hint: Use Source > Generate Getters and Setters \n * to create these easily)\n */\npublic class SecurityQA {\n\n\tString question, answer, confirmAnswer;\n\n\tpublic String getQuestion() {\n\t\treturn question;\n\t}\n\n\tpublic void setQuestion(String question) {\n\t\tthis.question = question;\n\t}\n\n\tpublic String getAnswer() {\n\t\treturn answer;\n\t}\n\n\tpublic void setAnswer(String answer) {\n\t\tthis.answer = answer;\n\t}\n\n\tpublic String getConfirmAnswer() {\n\t\treturn confirmAnswer;\n\t}\n\n\tpublic void setConfirmAnswer(String confirmAnswer) {\n\t\tthis.confirmAnswer = confirmAnswer;\n\t}\n\n}", "SurveyBean.java": "package edu.ncsu.csc.itrust.beans;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * A bean for storing survey data associated with an office visit.\n * \n * A bean's purpose is to store data. Period. Little or no functionality is to be added to a bean \n * (with the exception of minor formatting such as concatenating phone numbers together). \n * A bean must only have Getters and Setters (Eclipse Hint: Use Source > Generate Getters and Setters \n * to create these easily)\n */\npublic class SurveyBean {\n\tprivate long visitID;\n\tprivate Date surveyDate;\n\tprivate int waitingRoomMinutes;\n\tprivate int examRoomMinutes;\n\tprivate int visitSatisfaction;\n\tprivate int treatmentSatisfaction;\n\n\tpublic final static String dateFormat = \"MM/dd/yyyy HH:mm\";\n\t\n\tpublic void setVisitID(long iD) {\n\t\tvisitID = iD;\n\t}\n\tpublic long getVisitID() {\n\t\treturn visitID;\n\t}\n\n\tpublic void setSurveyDate(Date surveyDate) {\n\t\tthis.surveyDate = (surveyDate == null ? null : (Date)surveyDate.clone());\n\t}\n\tpublic void setSurveyDateString(String s) {\n\t\ttry {\n\t\t\tsetSurveyDate(new SimpleDateFormat(dateFormat).parse(s));\n\t\t}\n\t\tcatch (ParseException ex) {\n\t\t\tSystem.out.println(ex.getMessage());\n\t\t}\n\t}\n\tpublic Date getSurveyDate() {\n\t\treturn (surveyDate == null ? null : (Date)surveyDate.clone());\n\t}\n\tpublic String getSurveyDateString() {\n\t\tif (surveyDate == null) return \"\";\n\t\treturn new SimpleDateFormat(dateFormat).format(getSurveyDate());\n\t}\n\t\n\tpublic void setWaitingRoomMinutes(int waitingRoomMinutes) {\n\t\tthis.waitingRoomMinutes = waitingRoomMinutes;\n\t}\n\tpublic int getWaitingRoomMinutes() {\n\t\treturn waitingRoomMinutes;\n\t}\n\t\n\tpublic void setExamRoomMinutes(int examRoomMinutes) {\n\t\tthis.examRoomMinutes = examRoomMinutes;\n\t}\n\tpublic int getExamRoomMinutes() {\n\t\treturn examRoomMinutes;\n\t}\n\t\n\tpublic void setVisitSatisfaction(int visitSatisfaction) {\n\t\tthis.visitSatisfaction = visitSatisfaction;\n\t}\n\tpublic int getVisitSatisfaction() {\n\t\treturn visitSatisfaction;\n\t}\n\t\n\tpublic void setTreatmentSatisfaction(int treatmentSatisfaction) {\n\t\tthis.treatmentSatisfaction = treatmentSatisfaction;\n\t}\n\tpublic int getTreatmentSatisfaction() {\n\t\treturn treatmentSatisfaction;\n\t}\n\n\t\n}", "SurveyResultBean.java": "package edu.ncsu.csc.itrust.beans;\n\n/**\n * Bean to be used for survey results (search).  Stores address information about a HCP\n * in addition to their specialty, hospital, and averages from survey (results range from 1-5).  This\n * beans also contains a variable that stores the percent of office visits that satisfaction results are \n * available.\n */\npublic class SurveyResultBean {\n\n\tprivate long hcpMID;\n\tprivate String hcpFirstName;\n\tprivate String hcpLastName;\n\tprivate String hcpAddress1;\n\tprivate String hcpAddress2;\n\tprivate String hcpCity;\n\tprivate String hcpState;\n\tprivate String hcpZip;\n\tprivate String hcpSpecialty;\n\tprivate String hcpHospitalID;\n\tprivate float avgWaitingRmMinutes;\n\tprivate float avgExamRmMinutues;\n\tprivate float avgVisitSatisfaction;\n\tprivate float avgTreatmentSatisfaction;\n\tprivate float percentSatResultsAvailable;\n\t\n\t//list of specialties\n\tpublic final static String GENERAL_SPECIALTY = \"General\";\n\tpublic final static String SURGEON_SPECIALTY = \"Surgeon\";\n\tpublic final static String HEART_SPECIALTY = \"Heart Specialist\";\n\tpublic final static String PEDIATRICIAN_SPECIALTY = \"Pediatrician\";\n\tpublic final static String OBGYN_SPECIALTY = \"OB/GYN\";\n\tpublic final static String ANY_SPECIALTY = \"None\";\n\t\n\tpublic void setHCPMID(long mid) {\n\t\thcpMID = mid;\n\t}\n\tpublic long getHCPMID() {\n\t\treturn hcpMID;\n\t}\n\t\n\tpublic void setHCPFirstName(String firstName) {\n\t\tthis.hcpFirstName = firstName;\n\t}\n\tpublic String getHCPFirstName() {\n\t\treturn hcpFirstName;\n\t}\n\t\n\tpublic void setHCPLastName(String lastName) {\n\t\tthis.hcpLastName = lastName;\n\t}\n\tpublic String getHCPLastName() {\n\t\treturn hcpLastName;\n\t}\n\t\n\tpublic void setHCPaddress1(String address1) {\n\t\tthis.hcpAddress1 = address1;\n\t}\n\tpublic String getHCPaddress1() {\n\t\treturn hcpAddress1;\n\t}\n\t\n\tpublic void setHCPaddress2(String address2) {\n\t\tthis.hcpAddress2 = address2;\n\t}\n\tpublic String getHCPaddress2() {\n\t\treturn hcpAddress2;\n\t}\n\t\n\tpublic void setHCPcity(String city) {\n\t\tthis.hcpCity = city;\n\t}\n\tpublic String getHCPcity() {\n\t\treturn hcpCity;\n\t}\n\t\n\tpublic void setHCPstate(String state) {\n\t\tthis.hcpState = state;\n\t}\n\tpublic String getHCPstate() {\n\t\treturn hcpState;\n\t}\n\t\n\tpublic void setHCPzip(String zip) {\n\t\tthis.hcpZip = zip;\n\t}\n\tpublic String getHCPzip() {\n\t\treturn hcpZip;\n\t}\n\t\n\tpublic void setHCPspecialty(String specialty) {\n\t\tthis.hcpSpecialty = specialty;\n\t}\n\tpublic String getHCPspecialty() {\n\t\treturn hcpSpecialty;\n\t}\n\t\n\tpublic void setHCPhospital(String hospital) {\n\t\tthis.hcpHospitalID = hospital;\n\t}\n\tpublic String getHCPhospital() {\n\t\treturn hcpHospitalID;\n\t}\n\t\n\tpublic void setAvgWaitingRoomMinutes(float waitingRoomMinutes) {\n\t\tthis.avgWaitingRmMinutes = waitingRoomMinutes;\n\t}\n\tpublic float getAvgWaitingRoomMinutes() {\n\t\treturn avgWaitingRmMinutes;\n\t}\n\t\n\tpublic void setAvgExamRoomMinutes(float examRoomMinutes) {\n\t\tthis.avgExamRmMinutues = examRoomMinutes;\n\t}\n\tpublic float getAvgExamRoomMinutes() {\n\t\treturn avgExamRmMinutues;\n\t}\n\t\n\tpublic void setAvgVisitSatisfaction(float visitSatisfaction) {\n\t\tthis.avgVisitSatisfaction = visitSatisfaction;\n\t}\n\tpublic float getAvgVisitSatisfaction() {\n\t\treturn avgVisitSatisfaction;\n\t}\n\t\n\tpublic void setAvgTreatmentSatisfaction(float treatmentSatisfaction) {\n\t\tthis.avgTreatmentSatisfaction = treatmentSatisfaction;\n\t}\n\tpublic float getAvgTreatmentSatisfaction() {\n\t\treturn avgTreatmentSatisfaction;\n\t}\n\t\n\tpublic void setPercentSatisfactionResults (float percent) {\n\t\tthis.percentSatResultsAvailable= percent;\n\t}\n\tpublic float getPercentSatisfactionResults() {\n\t\treturn percentSatResultsAvailable;\n\t}\n}", "TransactionBean.java": "package edu.ncsu.csc.itrust.beans;\n\nimport java.sql.Timestamp;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\n\n/**\n * A bean for storing data about a transaction that occurred within iTrust.\n * \n * A bean's purpose is to store data. Period. Little or no functionality is to be added to a bean \n * (with the exception of minor formatting such as concatenating phone numbers together). \n * A bean must only have Getters and Setters (Eclipse Hint: Use Source > Generate Getters and Setters \n * to create these easily)\n */\npublic class TransactionBean {\n\tprivate long transactionID;\n\tprivate long loggedInMID;\n\tprivate long secondaryMID;\n\tprivate TransactionType transactionType;\n\tprivate Timestamp timeLogged;\n\tprivate String addedInfo;\n\tprivate String role;\n\n\tpublic String getRole() {\n\t\treturn role;\n\t}\n\n\tpublic void setRole(String role) {\n\t\tthis.role = role;\n\t}\n\n\tpublic String getAddedInfo() {\n\t\treturn addedInfo;\n\t}\n\n\tpublic void setAddedInfo(String addedInfo) {\n\t\tthis.addedInfo = addedInfo;\n\t}\n\n\tpublic long getLoggedInMID() {\n\t\treturn loggedInMID;\n\t}\n\n\tpublic void setLoggedInMID(long loggedInMID) {\n\t\tthis.loggedInMID = loggedInMID;\n\t}\n\n\tpublic long getSecondaryMID() {\n\t\treturn secondaryMID;\n\t}\n\n\tpublic void setSecondaryMID(long secondaryMID) {\n\t\tthis.secondaryMID = secondaryMID;\n\t}\n\n\tpublic Timestamp getTimeLogged() {\n\t\treturn timeLogged;\n\t}\n\n\tpublic void setTimeLogged(Timestamp timeLogged) {\n\t\tthis.timeLogged = timeLogged;\n\t}\n\n\tpublic TransactionType getTransactionType() {\n\t\treturn transactionType;\n\t}\n\n\tpublic void setTransactionType(TransactionType tranactionType) {\n\t\tthis.transactionType = tranactionType;\n\t}\n\n\tpublic long getTransactionID() {\n\t\treturn transactionID;\n\t}\n\n\tpublic void setTransactionID(long transactionID) {\n\t\tthis.transactionID = transactionID;\n\t}\n}", "EditOfficeVisitForm.java": "package edu.ncsu.csc.itrust.beans.forms;\n\n/**\n * A form to contain data coming from editing an office visit.\n * \n * A form is a bean, kinda. You could say that it's a \"form\" of a bean :) \n * Think of a form as a real-life administrative form that you would fill out to get \n * something done, not necessarily making sense by itself.\n */\npublic class EditOfficeVisitForm {\n\tprivate String ovID;\n\tprivate String hcpID;\n\tprivate String patientID;\n\tprivate String hospitalID;\n\tprivate String removeLabProcID;\n\tprivate String removeDiagID;\n\tprivate String removeProcID;\n\tprivate String removeImmunizationID;\n\tprivate String removeMedID;\n\tprivate String addLabProcID;\n\tprivate String addDiagID;\n\tprivate String addProcID;\n\tprivate String addImmunizationID;\n\tprivate String addMedID;\n\tprivate String notes;\n\tprivate String visitDate;\n\tprivate String startDate;\n\tprivate String endDate;\n\tprivate String dosage;\n\tprivate String instructions;\n\tprivate String causeOfDeath;\n\n\tpublic String getAddDiagID() {\n\t\treturn addDiagID;\n\t}\n\n\tpublic void setAddDiagID(String addDiagID) {\n\t\tthis.addDiagID = addDiagID;\n\t}\n\n\tpublic String getAddLabProcID() {\n\t\treturn addLabProcID;\n\t}\n\n\tpublic void setAddLabProcID(String addLabProcID) {\n\t\tthis.addLabProcID = addLabProcID;\n\t}\n\t\n\tpublic String getAddMedID() {\n\t\treturn addMedID;\n\t}\n\n\tpublic void setAddMedID(String addMedID) {\n\t\tthis.addMedID = addMedID;\n\t}\n\n\tpublic String getAddProcID() {\n\t\treturn addProcID;\n\t}\n\n\tpublic void setAddProcID(String addProcID) {\n\t\tthis.addProcID = addProcID;\n\t}\n\n\tpublic String getAddImmunizationID() {\n\t\treturn addImmunizationID;\n\t}\n\n\tpublic void setAddImmunizationID(String addImmunizationID) {\n\t\tthis.addImmunizationID = addImmunizationID;\n\t}\n\t\n\tpublic String getNotes() {\n\t\treturn notes;\n\t}\n\n\tpublic void setNotes(String notes) {\n\t\tthis.notes = notes;\n\t}\n\n\tpublic String getOvID() {\n\t\treturn ovID;\n\t}\n\n\tpublic void setOvID(String ovID) {\n\t\tthis.ovID = ovID;\n\t}\n\n\tpublic String getRemoveLabProcID() {\n\t\treturn removeLabProcID;\n\t}\n\n\tpublic void setRemoveLabProcID(String removeLabProcID) {\n\t\tthis.removeLabProcID = removeLabProcID;\n\t}\n\t\n\tpublic String getRemoveDiagID() {\n\t\treturn removeDiagID;\n\t}\n\n\tpublic void setRemoveDiagID(String removeDiagID) {\n\t\tthis.removeDiagID = removeDiagID;\n\t}\n\n\tpublic String getRemoveMedID() {\n\t\treturn removeMedID;\n\t}\n\n\tpublic void setRemoveMedID(String removeMedID) {\n\t\tthis.removeMedID = removeMedID;\n\t}\n\n\tpublic String getRemoveProcID() {\n\t\treturn removeProcID;\n\t}\n\n\tpublic void setRemoveProcID(String removeProcID) {\n\t\tthis.removeProcID = removeProcID;\n\t}\n\t\n\tpublic String getRemoveImmunizationID() {\n\t\treturn removeImmunizationID;\n\t}\n\n\tpublic void setRemoveImmunizationID(String removeImmunizationID) {\n\t\tthis.removeImmunizationID = removeImmunizationID; \n\t}\n\n\tpublic String getVisitDate() {\n\t\treturn visitDate;\n\t}\n\n\tpublic void setVisitDate(String visitDate) {\n\t\tthis.visitDate = visitDate;\n\t}\n\n\tpublic String getHcpID() {\n\t\treturn hcpID;\n\t}\n\n\tpublic void setHcpID(String hcpID) {\n\t\tthis.hcpID = hcpID;\n\t}\n\n\tpublic String getPatientID() {\n\t\treturn patientID;\n\t}\n\n\tpublic void setPatientID(String patientID) {\n\t\tthis.patientID = patientID;\n\t}\n\n\tpublic String getHospitalID() {\n\t\treturn hospitalID;\n\t}\n\n\tpublic void setHospitalID(String hospitalID) {\n\t\tthis.hospitalID = hospitalID;\n\t}\n\n\tpublic String getDosage() {\n\t\treturn dosage;\n\t}\n\n\tpublic void setDosage(String dosage) {\n\t\tthis.dosage = dosage;\n\t}\n\n\tpublic String getEndDate() {\n\t\treturn endDate;\n\t}\n\n\tpublic void setEndDate(String endDate) {\n\t\tthis.endDate = endDate;\n\t}\n\n\tpublic String getInstructions() {\n\t\treturn instructions;\n\t}\n\n\tpublic void setInstructions(String instructions) {\n\t\tthis.instructions = instructions;\n\t}\n\n\tpublic String getStartDate() {\n\t\treturn startDate;\n\t}\n\n\tpublic void setStartDate(String startDate) {\n\t\tthis.startDate = startDate;\n\t}\n\n\tpublic String getCauseOfDeath() {\n\t\treturn causeOfDeath;\n\t}\n\n\tpublic void setCauseOfDeath(String causeOfDeath) {\n\t\tthis.causeOfDeath = causeOfDeath;\n\t}\n}", "HealthRecordForm.java": "package edu.ncsu.csc.itrust.beans.forms;\n\n/**\n * A form to contain data coming from editing a health record.\n * \n * A form is a bean, kinda. You could say that it's a \"form\" of a bean :) \n * Think of a form as a real-life administrative form that you would fill out to get \n * something done, not necessarily making sense by itself.\n */\npublic class HealthRecordForm {\n\tprivate String height = \"0.0\";\n\tprivate String weight = \"0.0\";\n\tprivate String isSmoker = \"false\";\n\tprivate String bloodPressureN = \"0\";\n\tprivate String bloodPressureD = \"0\";\n\tprivate String cholesterolHDL = \"0\";\n\tprivate String cholesterolLDL = \"0\";\n\tprivate String cholesterolTri = \"0\";\n\n\tpublic HealthRecordForm() {\n\t}\n\n\tpublic String getBloodPressureD() {\n\t\treturn bloodPressureD;\n\t}\n\n\tpublic void setBloodPressureD(String bloodPressureD) {\n\t\tthis.bloodPressureD = bloodPressureD;\n\t}\n\n\tpublic String getBloodPressureN() {\n\t\treturn bloodPressureN;\n\t}\n\n\tpublic void setBloodPressureN(String bloodPressureN) {\n\t\tthis.bloodPressureN = bloodPressureN;\n\t}\n\n\tpublic String getCholesterolHDL() {\n\t\treturn cholesterolHDL;\n\t}\n\n\tpublic void setCholesterolHDL(String cholesterolHDL) {\n\t\tthis.cholesterolHDL = cholesterolHDL;\n\t}\n\n\tpublic String getCholesterolLDL() {\n\t\treturn cholesterolLDL;\n\t}\n\n\tpublic void setCholesterolLDL(String cholesterolLDL) {\n\t\tthis.cholesterolLDL = cholesterolLDL;\n\t}\n\n\tpublic String getCholesterolTri() {\n\t\treturn cholesterolTri;\n\t}\n\n\tpublic void setCholesterolTri(String cholesterolTri) {\n\t\tthis.cholesterolTri = cholesterolTri;\n\t}\n\n\tpublic String getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setHeight(String height) {\n\t\tthis.height = height;\n\t}\n\n\tpublic String getIsSmoker() {\n\t\treturn isSmoker;\n\t}\n\n\tpublic void setIsSmoker(String isSmoker) {\n\t\tthis.isSmoker = isSmoker;\n\t}\n\n\tpublic String getWeight() {\n\t\treturn weight;\n\t}\n\n\tpublic void setWeight(String weight) {\n\t\tthis.weight = weight;\n\t}\n}", "AdverseEventBeanLoader.java": "package edu.ncsu.csc.itrust.beans.loaders;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.AdverseEventBean;\n\n/**\n * A loader for AdverseEventBeans.\n * \n * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. \n * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}\n */\npublic class AdverseEventBeanLoader implements BeanLoader<AdverseEventBean> {\n\n\tpublic List<AdverseEventBean> loadList(ResultSet rs) throws SQLException {\n\t\tArrayList<AdverseEventBean> list = new ArrayList<AdverseEventBean>();\n\t\twhile (rs.next()) {\n\t\t\tlist.add(loadSingle(rs));\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic AdverseEventBean loadSingle(ResultSet rs) throws SQLException {\n\t\tAdverseEventBean adverseEvent = new AdverseEventBean();\n\t\tadverseEvent.setMID(rs.getString(\"PatientMID\"));\n\t\tadverseEvent.setDrug(rs.getString(\"PresImmu\"));\n\t\tadverseEvent.setDescription(rs.getString(\"Comment\"));\n\t\tadverseEvent.setCode(rs.getString(\"Code\"));\n\t\tadverseEvent.setDate(rs.getTimestamp(\"TimeLogged\").toString());\n\t\tadverseEvent.setId(rs.getInt(\"id\"));\n\t\tadverseEvent.setStatus(rs.getString(\"Status\"));\n\t\treturn adverseEvent;\n\t}\n\n\tpublic PreparedStatement loadParameters(PreparedStatement ps, AdverseEventBean bean) throws SQLException {\n\t\tthrow new IllegalStateException(\"unimplemented!\");\n\t}\n\n}", "AllergyBeanLoader.java": "package edu.ncsu.csc.itrust.beans.loaders;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.AllergyBean;\n\n/**\n * A loader for AllergyBeans.\n * \n * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. \n * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}\n */\npublic class AllergyBeanLoader implements BeanLoader<AllergyBean> {\n\n\tpublic List<AllergyBean> loadList(ResultSet rs) throws SQLException {\n\t\tArrayList<AllergyBean> list = new ArrayList<AllergyBean>();\n\t\twhile (rs.next()) {\n\t\t\tlist.add(loadSingle(rs));\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic AllergyBean loadSingle(ResultSet rs) throws SQLException {\n\t\tAllergyBean allergy = new AllergyBean();\n\t\tallergy.setId(rs.getLong(\"ID\"));\n\t\tallergy.setPatientID(rs.getLong(\"PatientID\"));\n\t\tallergy.setDescription(rs.getString(\"Description\"));\n\t\tallergy.setFirstFound(rs.getTimestamp(\"FirstFound\"));\n\t\treturn allergy;\n\t}\n\n\tpublic PreparedStatement loadParameters(PreparedStatement ps, AllergyBean bean) throws SQLException {\n\t\tthrow new IllegalStateException(\"unimplemented!\");\n\t}\n\n}", "ApptBeanLoader.java": "package edu.ncsu.csc.itrust.beans.loaders;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.ApptBean;\n\npublic class ApptBeanLoader implements BeanLoader<ApptBean> {\n\n\tpublic List<ApptBean> loadList(ResultSet rs) throws SQLException {\n\t\tList<ApptBean> list = new ArrayList<ApptBean>();\n\t\twhile (rs.next())\n\t\t\tlist.add(loadSingle(rs));\n\t\treturn list;\n\t}\n\n\tpublic PreparedStatement loadParameters(PreparedStatement ps, ApptBean bean) throws SQLException {\n\t\tps.setString(1, bean.getApptType());\n\t\tps.setLong(2, bean.getPatient());\n\t\tps.setLong(3, bean.getHcp());\n\t\tps.setTimestamp(4, bean.getDate());\n\t\tps.setString(5, bean.getComment());\n\t\treturn ps;\n\t}\n\n\tpublic ApptBean loadSingle(ResultSet rs) throws SQLException {\n\t\tApptBean bean = new ApptBean();\n\t\tbean.setApptType(rs.getString(\"appt_type\"));\n\t\tbean.setPatient(rs.getLong(\"patient_id\"));\n\t\tbean.setHcp(rs.getLong(\"doctor_id\"));\n\t\tbean.setDate(rs.getTimestamp(\"sched_date\"));\n\t\tbean.setComment(rs.getString(\"comment\"));\n\t\treturn bean;\n\t}\n\n}", "ApptTypeBeanLoader.java": "package edu.ncsu.csc.itrust.beans.loaders;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.ApptTypeBean;\n\npublic class ApptTypeBeanLoader implements BeanLoader<ApptTypeBean> {\n\n\tpublic List<ApptTypeBean> loadList(ResultSet rs) throws SQLException {\n\t\tList<ApptTypeBean> list = new ArrayList<ApptTypeBean>();\n\t\twhile (rs.next())\n\t\t\tlist.add(loadSingle(rs));\n\t\treturn list;\n\t}\n\n\tpublic PreparedStatement loadParameters(PreparedStatement ps, ApptTypeBean apptType) throws SQLException {\n\t\tps.setString(1, apptType.getName());\n\t\tps.setInt(2, apptType.getDuration());\n\t\treturn ps;\n\t}\n\n\tpublic ApptTypeBean loadSingle(ResultSet rs) throws SQLException {\n\t\tApptTypeBean apptType = new ApptTypeBean();\n\t\tapptType.setName(rs.getString(\"appt_type\"));\n\t\tapptType.setDuration(rs.getInt(\"duration\"));\n\t\treturn apptType;\n\t}\n\n}", "BeanLoader.java": "package edu.ncsu.csc.itrust.beans.loaders;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.List;\n\n/**\n * This interface helps enforce the paradigm of what should be contained in a loader.\n * \n * The generic type <T> specifies the type of bean that the loader is responsible for extacting from\n * a result set.\n * \n * @param <T> A type for the bean that will be loaded with this class.\n */\npublic interface BeanLoader<T> {\n\t/**\n\t * Loads a list of the bean of type T from a result set.  Typically makes iterated calls\n\t * to loadSingle.\n\t * @param rs The java.sql.ResultSet we are extracting.\n\t * @return A java.util.List<T> where T is the type for this loader.\n\t * @throws SQLException\n\t */\n\tpublic List<T> loadList(ResultSet rs) throws SQLException;\n\n\t/**\n\t * Contains the instructions for mapping the rows in this java.sql.ResultSet into\n\t * beans of type <T>.\n\t * @param rs The java.sql.ResultSet to be loaded.\n\t * @return A Bean of type T containing the loaded information, typically of the first (or next) item in the result set.\n\t * @throws SQLException\n\t */\n\tpublic T loadSingle(ResultSet rs) throws SQLException;\n\n\t/**\n\t * Used for an insert or update, this method contains the instructions for mapping the fields within\n\t * a bean of type T into a prepared statement which modifies the appropriate table.\n\t * @param ps The prepared statement to be loaded.\n\t * @param bean The bean containing the data to be placed.\n\t * @return A prepared statement with the appropriately loaded parameters.\n\t * @throws SQLException\n\t */\n\tpublic PreparedStatement loadParameters(PreparedStatement ps, T bean) throws SQLException;\n}", "DiagnosisBeanLoader.java": "package edu.ncsu.csc.itrust.beans.loaders;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.DiagnosisBean;\n\n/**\n * A loader for DiagnosisBeans.\n * \n * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency.\n * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader} \n */\n\npublic class DiagnosisBeanLoader implements BeanLoader<DiagnosisBean> {\n\tprivate boolean loadOVDiagnosisID = false;\n\n\tpublic DiagnosisBeanLoader() {\n\t\tloadOVDiagnosisID = false;\n\t}\n\n\tpublic DiagnosisBeanLoader(boolean loadOVDiagnosisID) {\n\t\tthis.loadOVDiagnosisID = loadOVDiagnosisID;\n\t}\n\n\tpublic List<DiagnosisBean> loadList(ResultSet rs) throws SQLException {\n\t\tArrayList<DiagnosisBean> list = new ArrayList<DiagnosisBean>();\n\t\twhile (rs.next()) {\n\t\t\tlist.add(loadSingle(rs));\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic DiagnosisBean loadSingle(ResultSet rs) throws SQLException {\n\t\t\n\t\tDiagnosisBean diag = new DiagnosisBean(rs.getString(\"Code\"), rs.getString(\"Description\"), rs.getString(\"Chronic\"));\n\t\tif (loadOVDiagnosisID) {\n\t\t\tdiag.setOvDiagnosisID(rs.getInt(\"ID\"));\n\t\t\tdiag.setVisitID(rs.getLong(\"VisitID\"));\n\t\t}\n\t\treturn diag;\n\t}\n\n\tpublic PreparedStatement loadParameters(PreparedStatement ps, DiagnosisBean bean) throws SQLException {\n\t\tthrow new IllegalStateException(\"unimplemented!\");\n\t}\n}", "DrugInteractionBeanLoader.java": "package edu.ncsu.csc.itrust.beans.loaders;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.DrugInteractionBean;\n\n/**\n * A loader for MedicationBeans.\n * \n * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. \n * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}\n */\npublic class DrugInteractionBeanLoader implements BeanLoader<DrugInteractionBean> {\n\tpublic DrugInteractionBeanLoader() {\n\t}\n\n\tpublic List<DrugInteractionBean> loadList(ResultSet rs) throws SQLException {\n\t\tArrayList<DrugInteractionBean> list = new ArrayList<DrugInteractionBean>();\n\t\twhile (rs.next()) {\n\t\t\tlist.add(loadSingle(rs));\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic DrugInteractionBean loadSingle(ResultSet rs) throws SQLException {\n\t\t// MedicationBean med = new MedicationBean();\n\t\tDrugInteractionBean drugIt = new DrugInteractionBean();\n\t\tdrugIt.setDescription(rs.getString(\"Description\"));\n\t\tdrugIt.setFirstDrug(rs.getString(\"FirstDrug\"));\n\t\tdrugIt.setSecondDrug(rs.getString(\"SecondDrug\"));\n\t\treturn drugIt;\n\t}\n\n\tpublic PreparedStatement loadParameters(PreparedStatement ps, DrugInteractionBean bean) throws SQLException {\n\t\tthrow new IllegalStateException(\"unimplemented!\");\n\t}\n}", "EmailBeanLoader.java": "package edu.ncsu.csc.itrust.beans.loaders;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.Email;\n\n/**\n * A loader for Fake Emails.\n * \n * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. \n * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}\n */\npublic class EmailBeanLoader implements BeanLoader<Email> {\n\n\tpublic List<Email> loadList(ResultSet rs) throws SQLException {\n\t\tList<Email> list = new ArrayList<Email>();\n\t\twhile (rs.next())\n\t\t\tlist.add(loadSingle(rs));\n\t\treturn list;\n\t}\n\n\tpublic PreparedStatement loadParameters(PreparedStatement ps, Email email) throws SQLException {\n\t\tps.setString(1, email.getToListStr());\n\t\tps.setString(2, email.getFrom());\n\t\tps.setString(3, email.getSubject());\n\t\tps.setString(4, email.getBody());\n\t\treturn ps;\n\t}\n\n\tpublic Email loadSingle(ResultSet rs) throws SQLException {\n\t\tEmail email = new Email();\n\t\temail.setFrom(rs.getString(\"FromAddr\"));\n\t\temail.setToList(Arrays.asList(rs.getString(\"ToAddr\").split(\",\")));\n\t\temail.setBody(rs.getString(\"Body\"));\n\t\temail.setSubject(rs.getString(\"Subject\"));\n\t\temail.setTimeAdded(rs.getTimestamp(\"AddedDate\"));\n\t\treturn email;\n\t}\n\n}", "FamilyBeanLoader.java": "package edu.ncsu.csc.itrust.beans.loaders;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.FamilyMemberBean;\n\n/**\n * A loader for FamilyMemberBeans.\n * \n * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. \n * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}\n */\npublic class FamilyBeanLoader implements BeanLoader<FamilyMemberBean> {\n\tprivate String relation;\n\n\tpublic FamilyBeanLoader(String relation) {\n\t\tthis.relation = relation;\n\t}\n\n\tpublic List<FamilyMemberBean> loadList(ResultSet rs) throws SQLException {\n\t\tArrayList<FamilyMemberBean> list = new ArrayList<FamilyMemberBean>();\n\t\twhile (rs.next()) {\n\t\t\tlist.add(loadSingle(rs));\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic PreparedStatement loadParameters(PreparedStatement ps, FamilyMemberBean bean) throws SQLException {\n\t\tthrow new IllegalStateException(\"unimplemented!\");\n\t}\n\n\tpublic FamilyMemberBean loadSingle(ResultSet rs) throws SQLException {\n\t\tFamilyMemberBean fam = new FamilyMemberBean();\n\t\tfam.setRelation(relation);\n\t\tfam.setFirstName(rs.getString(\"FirstName\"));\n\t\tfam.setLastName(rs.getString(\"LastName\"));\n\t\tfam.setMid(rs.getInt(\"MID\"));\n\t\treturn fam;\n\t}\n}", "HealthRecordsBeanLoader.java": "package edu.ncsu.csc.itrust.beans.loaders;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.HealthRecord;\n\n/**\n * A loader for HealthRecords.\n * \n * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. \n * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}\n */\npublic class HealthRecordsBeanLoader implements BeanLoader<HealthRecord> {\n\tpublic List<HealthRecord> loadList(ResultSet rs) throws SQLException {\n\t\tArrayList<HealthRecord> list = new ArrayList<HealthRecord>();\n\t\twhile (rs.next()) {\n\t\t\tlist.add(loadSingle(rs));\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic PreparedStatement loadParameters(PreparedStatement ps, HealthRecord bean) throws SQLException {\n\t\tint i = 1;\n\t\tps.setLong(i++, bean.getPatientID());\n\t\tps.setDouble(i++, bean.getHeight());\n\t\tps.setDouble(i++, bean.getWeight());\n\t\tps.setInt(i++, bean.isSmoker() ? 1 : 0);\n\t\tps.setInt(i++, bean.getBloodPressureN());\n\t\tps.setInt(i++, bean.getBloodPressureD());\n\t\tps.setInt(i++, bean.getCholesterolHDL());\n\t\tps.setInt(i++, bean.getCholesterolLDL());\n\t\tps.setInt(i++, bean.getCholesterolTri());\n\t\tps.setLong(i++, bean.getPersonnelID());\n\t\treturn ps;\n\t}\n\n\tpublic HealthRecord loadSingle(ResultSet rs) throws SQLException {\n\t\tHealthRecord hr = new HealthRecord();\n\t\thr.setBloodPressureN(rs.getInt(\"BloodPressureN\"));\n\t\thr.setBloodPressureD(rs.getInt(\"BloodPressureD\"));\n\t\thr.setCholesterolHDL(rs.getInt(\"CholesterolHDL\"));\n\t\thr.setCholesterolLDL(rs.getInt(\"CholesterolLDL\"));\n\t\thr.setCholesterolTri(rs.getInt(\"CholesterolTri\"));\n\t\thr.setDateRecorded(rs.getTimestamp(\"AsOfDate\"));\n\t\thr.setSmoker(rs.getInt(\"Smoker\") == 1);\n\t\thr.setHeight(rs.getDouble(\"Height\"));\n\t\thr.setWeight(rs.getDouble(\"Weight\"));\n\t\thr.setPersonnelID(rs.getLong(\"HCPID\"));\n\t\thr.setPatientID(rs.getLong(\"PatientID\"));\n\t\treturn hr;\n\t}\n}", "HospitalBeanLoader.java": "package edu.ncsu.csc.itrust.beans.loaders;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.HospitalBean;\n\n/**\n * A loader for HospitalBeans.\n * \n * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. \n * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}\n */\n\npublic class HospitalBeanLoader implements BeanLoader<HospitalBean> {\n\tpublic List<HospitalBean> loadList(ResultSet rs) throws SQLException {\n\t\tArrayList<HospitalBean> list = new ArrayList<HospitalBean>();\n\t\twhile (rs.next()) {\n\t\t\tlist.add(loadSingle(rs));\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic HospitalBean loadSingle(ResultSet rs) throws SQLException {\n\t\t// HospitalBean hosp = new HospitalBean();\n\t\tHospitalBean hosp = new HospitalBean(rs.getString(\"HospitalID\"), rs.getString(\"HospitalName\"));\n\t\treturn hosp;\n\t}\n\n\tpublic PreparedStatement loadParameters(PreparedStatement ps, HospitalBean bean) throws SQLException {\n\t\tthrow new IllegalStateException(\"unimplemented!\");\n\t}\n}", "LabProcedureBeanLoader.java": "package edu.ncsu.csc.itrust.beans.loaders;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.LabProcedureBean;\n\n/**\n * A loader for LabProcedureBeans.\n * \n * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. \n * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}\n */\npublic class LabProcedureBeanLoader implements BeanLoader<LabProcedureBean> {\n\t\n\tpublic List<LabProcedureBean> loadList(ResultSet rs) throws SQLException {\n\t\tArrayList<LabProcedureBean> list = new ArrayList<LabProcedureBean>();\n\t\twhile (rs.next()) {\n\t\t\tlist.add(loadSingle(rs));\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic LabProcedureBean loadSingle(ResultSet rs) throws SQLException {\n\t\tLabProcedureBean LabProcedure = new LabProcedureBean();\n\t\tLabProcedure.setProcedureID(rs.getLong(\"LaboratoryProcedureID\"));\n\t\tLabProcedure.setPid(rs.getLong(\"PatientMID\"));\n\t\tLabProcedure.setLoinc(rs.getString(\"LaboratoryProcedureCode\"));\n\t\tLabProcedure.setStatus(rs.getString(\"Status\"));\n\t\tLabProcedure.setCommentary(rs.getString(\"Commentary\"));\n\t\tLabProcedure.setResults(rs.getString(\"Results\"));\n\t\tLabProcedure.setOvID(rs.getLong(\"OfficeVisitID\"));\n\t\tLabProcedure.setTimestamp(rs.getTimestamp(\"UpdatedDate\"));\n\t\tLabProcedure.setRights(rs.getString(\"Rights\"));\t\t\n\t\treturn LabProcedure;\n\t}\n\n\tpublic PreparedStatement loadParameters(PreparedStatement ps, LabProcedureBean bean) throws SQLException {\n\t\tthrow new IllegalStateException(\"unimplemented!\");\n\t}\n\n}", "LOINCBeanLoader.java": "package edu.ncsu.csc.itrust.beans.loaders;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.LOINCbean;\n\n/**\n * A loader for LOINCBeans.\n * \n * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. \n * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}\n */\npublic class LOINCBeanLoader implements BeanLoader<LOINCbean> {\n\t\n\tpublic List<LOINCbean> loadList(ResultSet rs) throws SQLException {\n\t\tArrayList<LOINCbean> list = new ArrayList<LOINCbean>();\n\t\twhile (rs.next()) {\n\t\t\tlist.add(loadSingle(rs));\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic LOINCbean loadSingle(ResultSet rs) throws SQLException {\n\t\tLOINCbean LOINC = new LOINCbean();\n\t\tLOINC.setLabProcedureCode(rs.getString(\"LaboratoryProcedureCode\"));\n\t\tLOINC.setComponent(rs.getString(\"Component\"));\n\t\tLOINC.setKindOfProperty(rs.getString(\"KindOfProperty\"));\n\t\tLOINC.setTimeAspect(rs.getString(\"TimeAspect\"));\n\t\tLOINC.setSystem(rs.getString(\"System\"));\n\t\tLOINC.setScaleType(rs.getString(\"ScaleType\"));\n\t\tLOINC.setMethodType(rs.getString(\"MethodType\"));\n\t\treturn LOINC;\n\t}\n\n\tpublic PreparedStatement loadParameters(PreparedStatement ps, LOINCbean bean) throws SQLException {\n\t\tthrow new IllegalStateException(\"unimplemented!\");\n\t}\n\n}", "MedicationBeanLoader.java": "package edu.ncsu.csc.itrust.beans.loaders;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.MedicationBean;\n\n/**\n * A loader for MedicationBeans.\n * \n * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. \n * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}\n */\npublic class MedicationBeanLoader implements BeanLoader<MedicationBean> {\n\tpublic MedicationBeanLoader() {\n\t}\n\n\tpublic List<MedicationBean> loadList(ResultSet rs) throws SQLException {\n\t\tArrayList<MedicationBean> list = new ArrayList<MedicationBean>();\n\t\twhile (rs.next()) {\n\t\t\tlist.add(loadSingle(rs));\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic MedicationBean loadSingle(ResultSet rs) throws SQLException {\n\t\t// MedicationBean med = new MedicationBean();\n\t\tMedicationBean med = new MedicationBean(rs.getString(\"Code\"));\n\t\tmed.setDescription(rs.getString(\"Description\"));\n\t\treturn med;\n\t}\n\n\tpublic PreparedStatement loadParameters(PreparedStatement ps, MedicationBean bean) throws SQLException {\n\t\tthrow new IllegalStateException(\"unimplemented!\");\n\t}\n}", "MessageBeanLoader.java": "package edu.ncsu.csc.itrust.beans.loaders;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.MessageBean;\n\n/**\n * A loader for MessageBeans.\n * \n * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. \n * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}\n */\npublic class MessageBeanLoader implements BeanLoader<MessageBean> {\n\n\tpublic List<MessageBean> loadList(ResultSet rs) throws SQLException {\n\t\tList<MessageBean> list = new ArrayList<MessageBean>();\n\t\twhile (rs.next())\n\t\t\tlist.add(loadSingle(rs));\n\t\treturn list;\n\t}\n\n\tpublic PreparedStatement loadParameters(PreparedStatement ps, MessageBean message) throws SQLException {\n\t\tps.setLong(1, message.getFrom());\n\t\tps.setLong(2, message.getTo());\n\t\tps.setString(3, message.getBody());\n\t\tps.setString(4, message.getSubject());\n\t\tps.setInt(5, message.getRead());\n\t\tif (message.getParentMessageId() != 0L) {\n\t\t\t\tps.setLong(6, message.getParentMessageId());\n\t\t}\n\t\treturn ps;\n\t}\n\n\tpublic MessageBean loadSingle(ResultSet rs) throws SQLException {\n\t\tMessageBean message = new MessageBean();\n\t\tmessage.setMessageId(rs.getLong(\"message_id\"));\n\t\tmessage.setFrom(rs.getLong(\"from_id\"));\n\t\tmessage.setTo(rs.getLong(\"to_id\"));\n\t\tmessage.setSubject(rs.getString(\"subject\"));\n\t\tmessage.setBody(rs.getString(\"message\"));\n\t\tmessage.setSentDate(rs.getTimestamp(\"sent_date\"));\n\t\tmessage.setRead(rs.getInt(\"been_read\"));\n\t\tmessage.setParentMessageId(rs.getLong(\"parent_msg_id\"));\n\t\treturn message;\n\t}\n\n}", "OfficeVisitLoader.java": "package edu.ncsu.csc.itrust.beans.loaders;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.OfficeVisitBean;\n\n/**\n * A loader for OfficeVisitBeans.\n * \n * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. \n * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}\n */\npublic class OfficeVisitLoader implements BeanLoader<OfficeVisitBean> {\n\tpublic List<OfficeVisitBean> loadList(ResultSet rs) throws SQLException {\n\t\tList<OfficeVisitBean> list = new ArrayList<OfficeVisitBean>();\n\t\twhile (rs.next()) {\n\t\t\tlist.add(loadSingle(rs));\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic OfficeVisitBean loadSingle(ResultSet rs) throws SQLException {\n\t\tOfficeVisitBean ov = new OfficeVisitBean(rs.getInt(\"ID\"));\n\t\tov.setHcpID(rs.getLong(\"HCPID\"));\n\t\tov.setNotes(rs.getString(\"Notes\"));\n\t\tov.setPatientID(rs.getLong(\"PatientID\"));\n\t\tov.setHospitalID(rs.getString(\"HospitalID\"));\n\t\tov.setVisitDateStr(new SimpleDateFormat(\"MM/dd/yyyy\").format(new Date(rs.getDate(\"VisitDate\").getTime())));\n\n\t\treturn ov;\n\t}\n\n\tpublic PreparedStatement loadParameters(PreparedStatement ps, OfficeVisitBean p) throws SQLException {\n\t\tthrow new IllegalStateException(\"unimplemented!\");\n\t}\n}", "OperationalProfileLoader.java": "package edu.ncsu.csc.itrust.beans.loaders;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.OperationalProfile;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\n\n/**\n * A loader for the operational profile.\n * \n * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. \n * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}\n */\npublic class OperationalProfileLoader implements BeanLoader<OperationalProfile> {\n\tpublic List<OperationalProfile> loadList(ResultSet rs) throws SQLException {\n\t\tthrow new IllegalStateException(\"unimplemented!\");\n\t}\n\n\tpublic PreparedStatement loadParameters(PreparedStatement ps, OperationalProfile bean)\n\t\t\tthrows SQLException {\n\t\tthrow new IllegalStateException(\"unimplemented!\");\n\t}\n\n\tpublic OperationalProfile loadSingle(ResultSet rs) throws SQLException {\n\t\tOperationalProfile op = new OperationalProfile();\n\t\tint grandTotal = 0;\n\t\tint grandPatient = 0;\n\t\tint grandPersonnel = 0;\n\t\twhile (rs.next()) {\n\t\t\tTransactionType type = TransactionType.parse(rs.getInt(\"TransactionCode\"));\n\t\t\tint totalCount = rs.getInt(\"TotalCount\");\n\t\t\tint patientCount = rs.getInt(\"PatientCount\");\n\t\t\tint personnelCount = rs.getInt(\"PersonnelCount\");\n\t\t\top.getTotalCount().put(type, totalCount);\n\t\t\top.getPatientCount().put(type, patientCount);\n\t\t\top.getPersonnelCount().put(type, personnelCount);\n\t\t\tgrandTotal += totalCount;\n\t\t\tgrandPatient += patientCount;\n\t\t\tgrandPersonnel += personnelCount;\n\t\t}\n\t\top.setNumTotalTransactions(grandTotal);\n\t\top.setNumPatientTransactions(grandPatient);\n\t\top.setNumPersonnelTransactions(grandPersonnel);\n\t\treturn op;\n\t}\n}", "PatientLoader.java": "package edu.ncsu.csc.itrust.beans.loaders;\n\nimport java.sql.Date;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.PatientBean;\n\n/**\n * A loader for PatientBeans.\n * \n * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. \n * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}\n */\npublic class PatientLoader implements BeanLoader<PatientBean> {\n\tpublic List<PatientBean> loadList(ResultSet rs) throws SQLException {\n\t\tList<PatientBean> list = new ArrayList<PatientBean>();\n\t\twhile (rs.next()) {\n\t\t\tlist.add(loadSingle(rs));\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic PatientBean loadSingle(ResultSet rs) throws SQLException {\n\t\tPatientBean p = new PatientBean();\n\t\tp.setMID(rs.getInt(\"MID\"));\n\t\tp.setFirstName(rs.getString(\"firstName\"));\n\t\tp.setLastName(rs.getString(\"LastName\"));\n\t\tDate dateOfBirth = rs.getDate(\"DateOfBirth\");\n\t\tif (dateOfBirth != null)\n\t\t\tp.setDateOfBirthStr(new SimpleDateFormat(\"MM/dd/yyyy\").format(dateOfBirth));\n\t\tDate dateOfDeath = rs.getDate(\"DateOfDeath\");\n\t\tif (dateOfDeath != null)\n\t\t\tp.setDateOfDeathStr(new SimpleDateFormat(\"MM/dd/yyyy\").format(dateOfDeath));\n\t\tp.setCauseOfDeath(rs.getString(\"CauseOfDeath\"));\n\t\tp.setEmail(rs.getString(\"Email\"));\n\t\tp.setStreetAddress1(rs.getString(\"address1\"));\n\t\tp.setStreetAddress2(rs.getString(\"address2\"));\n\t\tp.setCity(rs.getString(\"City\"));\n\t\tp.setState(rs.getString(\"State\"));\n\t\tp.setZip1((rs.getString(\"Zip1\")));\n\t\tp.setZip2((rs.getString(\"Zip2\")));\n\t\tp.setPhone1((rs.getString(\"phone1\")));\n\t\tp.setPhone2((rs.getString(\"phone2\")));\n\t\tp.setPhone3((rs.getString(\"phone3\")));\n\t\tp.setEmergencyName(rs.getString(\"eName\"));\n\t\tp.setEmergencyPhone1(rs.getString(\"ePhone1\"));\n\t\tp.setEmergencyPhone2(rs.getString(\"ePhone2\"));\n\t\tp.setEmergencyPhone3(rs.getString(\"ePhone3\"));\n\t\tp.setIcName(rs.getString(\"icName\"));\n\t\tp.setIcAddress1(rs.getString(\"icAddress1\"));\n\t\tp.setIcAddress2(rs.getString(\"icAddress2\"));\n\t\tp.setIcCity(rs.getString(\"icCity\"));\n\t\tp.setIcState(rs.getString(\"icState\"));\n\t\tp.setIcZip1(rs.getString(\"icZip1\"));\n\t\tp.setIcZip2(rs.getString(\"icZip2\"));\n\t\tp.setIcPhone1(rs.getString(\"icPhone1\"));\n\t\tp.setIcPhone2(rs.getString(\"icPhone2\"));\n\t\tp.setIcPhone3(rs.getString(\"icPhone3\"));\n\t\tp.setIcID(rs.getString(\"icID\"));\n\t\tp.setMotherMID(rs.getString(\"MotherMID\"));\n\t\tp.setFatherMID(rs.getString(\"FatherMID\"));\n\t\tp.setBloodTypeStr(rs.getString(\"BloodType\"));\n\t\tp.setEthnicityStr(rs.getString(\"Ethnicity\"));\n\t\tp.setGenderStr(rs.getString(\"Gender\"));\n\t\tp.setTopicalNotes(rs.getString(\"TopicalNotes\"));\n\t\tp.setCreditCardType(rs.getString(\"CreditCardType\"));\n\t\tp.setCreditCardNumber(rs.getString(\"CreditCardNumber\"));\n\t\tp.setMessageFilter(rs.getString(\"MessageFilter\"));\n\t\treturn p;\n\t}\n\n\tpublic PreparedStatement loadParameters(PreparedStatement ps, PatientBean p) throws SQLException {\n\t\tint i = 1;\n\t\tps.setString(i++, p.getFirstName());\n\t\tps.setString(i++, p.getLastName());\n\t\tps.setString(i++, p.getEmail());\n\t\t// ps.setString(i++, p.getSecurityQuestion());\n\t\t// ps.setString(i++, p.getSecurityAnswer());\n\t\tps.setString(i++, p.getStreetAddress1());\n\t\tps.setString(i++, p.getStreetAddress2());\n\t\tps.setString(i++, p.getCity());\n\t\tps.setString(i++, p.getState());\n\t\tps.setString(i++, p.getZip1());\n\t\tps.setString(i++, p.getZip2());\n\t\tps.setString(i++, p.getPhone1());\n\t\tps.setString(i++, p.getPhone2());\n\t\tps.setString(i++, p.getPhone3());\n\t\tps.setString(i++, p.getEmergencyName());\n\t\tps.setString(i++, p.getEmergencyPhone1());\n\t\tps.setString(i++, p.getEmergencyPhone2());\n\t\tps.setString(i++, p.getEmergencyPhone3());\n\t\tps.setString(i++, p.getIcName());\n\t\tps.setString(i++, p.getIcAddress1());\n\t\tps.setString(i++, p.getIcAddress2());\n\t\tps.setString(i++, p.getIcCity());\n\t\tps.setString(i++, p.getIcState());\n\t\tps.setString(i++, p.getIcZip1());\n\t\tps.setString(i++, p.getIcZip2());\n\t\tps.setString(i++, p.getIcPhone1());\n\t\tps.setString(i++, p.getIcPhone2());\n\t\tps.setString(i++, p.getIcPhone3());\n\t\tps.setString(i++, p.getIcID());\n\t\tDate date = null;\n\t\ttry {\n\t\t\tdate = new java.sql.Date(new SimpleDateFormat(\"MM/dd/yyyy\").parse(p.getDateOfBirthStr())\n\t\t\t\t\t.getTime());\n\t\t} catch (ParseException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tps.setDate(i++, date);\n\t\tdate = null;\n\t\ttry {\n\t\t\tdate = new java.sql.Date(new SimpleDateFormat(\"MM/dd/yyyy\").parse(p.getDateOfDeathStr())\n\t\t\t\t\t.getTime());\n\t\t} catch (ParseException e) {\n\t\t\tif (\"\".equals(p.getDateOfDeathStr()))\n\t\t\t\tdate = null;\n\t\t\telse\n\t\t\t\te.printStackTrace();\n\t\t}\n\t\tps.setDate(i++, date);\n\t\tps.setString(i++, p.getCauseOfDeath());\n\t\tps.setString(i++, p.getMotherMID());\n\t\tps.setString(i++, p.getFatherMID());\n\t\tps.setString(i++, p.getBloodType().getName());\n\t\tps.setString(i++, p.getEthnicity().getName());\n\t\tps.setString(i++, p.getGender().getName());\n\t\tps.setString(i++, p.getTopicalNotes());\n\t\tps.setString(i++, p.getCreditCardType());\n\t\tps.setString(i++, p.getCreditCardNumber());\n\t\tps.setString(i++, p.getMessageFilter());\n\t\treturn ps;\n\t}\n}", "PersonnelLoader.java": "package edu.ncsu.csc.itrust.beans.loaders;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.PersonnelBean;\nimport edu.ncsu.csc.itrust.enums.Role;\n\n/**\n * A loader for PersonnelBeans.\n * \n * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. \n * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}\n */\npublic class PersonnelLoader implements BeanLoader<PersonnelBean> {\n\tpublic List<PersonnelBean> loadList(ResultSet rs) throws SQLException {\n\t\tList<PersonnelBean> list = new ArrayList<PersonnelBean>();\n\t\twhile (rs.next()) {\n\t\t\tlist.add(loadSingle(rs));\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic PersonnelBean loadSingle(ResultSet rs) throws SQLException {\n\t\tPersonnelBean p = new PersonnelBean();\n\t\tp.setMID(rs.getLong(\"MID\"));\n\t\tp.setAMID(rs.getLong(\"amid\"));\n\t\tp.setRole(Role.parse(rs.getString(\"role\")));\n\t\tp.setLastName(rs.getString(\"lastName\"));\n\t\tp.setFirstName(rs.getString(\"firstName\"));\n\t\tp.setPhone1(rs.getString(\"phone1\"));\n\t\tp.setPhone2(rs.getString(\"phone2\"));\n\t\tp.setPhone3(rs.getString(\"phone3\"));\n\t\tp.setStreetAddress1(rs.getString(\"address1\"));\n\t\tp.setStreetAddress2(rs.getString(\"address2\"));\n\t\tp.setCity(rs.getString(\"city\"));\n\t\tp.setState(rs.getString(\"state\"));\n\t\tp.setZip1((rs.getString(\"zip1\")));\n\t\tp.setZip2((rs.getString(\"zip2\")));\n\t\tp.setEmail(rs.getString(\"email\"));\n\t\tp.setSpecialty(rs.getString(\"specialty\"));\n\t\tp.setMessageFilter(rs.getString(\"MessageFilter\"));\n\t\treturn p;\n\t}\n\n\tpublic PreparedStatement loadParameters(PreparedStatement ps, PersonnelBean p) throws SQLException {\n\t\tint i = 1;\n\t\tps.setLong(i++, p.getAMID());\n\t\tps.setString(i++, p.getFirstName());\n\t\tps.setString(i++, p.getLastName());\n\t\tps.setString(i++, p.getPhone1());\n\t\tps.setString(i++, p.getPhone2());\n\t\tps.setString(i++, p.getPhone3());\n\t\tps.setString(i++, p.getStreetAddress1());\n\t\tps.setString(i++, p.getStreetAddress2());\n\t\tps.setString(i++, p.getCity());\n\t\tps.setString(i++, p.getState());\n\t\tps.setString(i++, p.getZip());\n\t\tps.setString(i++, p.getZip1());\n\t\tps.setString(i++, p.getZip2());\n\t\t//ps.setString(i++, p.getSpecialty());\n\t\tps.setString(i++, p.getEmail());\n\t\tps.setString(i++, p.getMessageFilter());\n\t\treturn ps;\n\t}\n}", "PrescriptionBeanLoader.java": "package edu.ncsu.csc.itrust.beans.loaders;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.PrescriptionBean;\n\n/**\n * A loader for PrescriptionBeans.\n * \n * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. \n * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}\n */\npublic class PrescriptionBeanLoader implements BeanLoader<PrescriptionBean> {\n\tprivate MedicationBeanLoader medLoader;\n\n\tpublic PrescriptionBeanLoader() {\n\t\tmedLoader = new MedicationBeanLoader();\n\t}\n\n\tpublic List<PrescriptionBean> loadList(ResultSet rs) throws SQLException {\n\t\tArrayList<PrescriptionBean> list = new ArrayList<PrescriptionBean>();\n\t\twhile (rs.next()) {\n\t\t\tlist.add(loadSingle(rs));\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic PrescriptionBean loadSingle(ResultSet rs) throws SQLException {\n\t\tPrescriptionBean pres = new PrescriptionBean();\n\t\tpres.setId(rs.getLong(\"ID\"));\n\t\tpres.setVisitID((long) rs.getInt(\"VisitID\"));\n\t\tpres.setStartDateStr(new SimpleDateFormat(\"MM/dd/yyyy\").format(new java.util.Date(rs.getDate(\n\t\t\t\t\"StartDate\").getTime())));\n\t\tpres.setEndDateStr(new SimpleDateFormat(\"MM/dd/yyyy\").format(new java.util.Date(rs.getDate(\"EndDate\")\n\t\t\t\t.getTime())));\n\t\tpres.setDosage(rs.getInt(\"Dosage\"));\n\t\tpres.setInstructions(rs.getString(\"Instructions\"));\n\t\tpres.setMedication(medLoader.loadSingle(rs));\n\t\treturn pres;\n\t}\n\n\tpublic PreparedStatement loadParameters(PreparedStatement ps, PrescriptionBean pres) throws SQLException {\n\t\tps.setLong(1, pres.getVisitID());\n\t\tps.setString(2, pres.getMedication().getNDCode());\n\t\tps.setDate(3, new java.sql.Date(pres.getStartDate().getTime()));\n\t\tps.setDate(4, new java.sql.Date(pres.getEndDate().getTime()));\n\t\tps.setInt(5, pres.getDosage());\n\t\tps.setString(6, pres.getInstructions());\n\t\treturn ps;\n\t}\n}", "PrescriptionReportBeanLoader.java": "package edu.ncsu.csc.itrust.beans.loaders;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.PrescriptionReportBean;\n\n/**\n * A loader for PrescriptionReportBeans.\n * \n * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. \n * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}\n */\npublic class PrescriptionReportBeanLoader implements BeanLoader<PrescriptionReportBean> {\n\tprivate PrescriptionBeanLoader presLoader;\n\tprivate OfficeVisitLoader ovLoader;\n\n\tpublic PrescriptionReportBeanLoader() {\n\t\tovLoader = new OfficeVisitLoader();\n\t\tpresLoader = new PrescriptionBeanLoader();\n\t}\n\n\tpublic List<PrescriptionReportBean> loadList(ResultSet rs) throws SQLException {\n\t\tArrayList<PrescriptionReportBean> list = new ArrayList<PrescriptionReportBean>();\n\t\twhile (rs.next()) {\n\t\t\tlist.add(loadSingle(rs));\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic PrescriptionReportBean loadSingle(ResultSet rs) throws SQLException {\n\t\tPrescriptionReportBean pres = new PrescriptionReportBean();\n\t\tpres.setOfficeVisit(ovLoader.loadSingle(rs));\n\t\tpres.setPrescription(presLoader.loadSingle(rs));\n\t\treturn pres;\n\t}\n\n\tpublic PreparedStatement loadParameters(PreparedStatement ps, PrescriptionReportBean pres)\n\t\t\tthrows SQLException {\n\t\tthrow new IllegalStateException(\"unimplemented!\");\n\t}\n}", "ProcedureBeanLoader.java": "package edu.ncsu.csc.itrust.beans.loaders;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.ProcedureBean;\n\n/**\n * A loader for ProcedureBeans.\n * \n * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. \n * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}\n */\npublic class ProcedureBeanLoader implements BeanLoader<ProcedureBean> {\n\tprivate boolean loadOVProcedureID;\n\n\tpublic ProcedureBeanLoader() {\n\t\tthis.loadOVProcedureID = false;\n\t}\n\n\tpublic ProcedureBeanLoader(boolean loadOVProcedureID) {\n\t\tthis.loadOVProcedureID = loadOVProcedureID;\n\t}\n\n\tpublic List<ProcedureBean> loadList(ResultSet rs) throws SQLException {\n\t\tArrayList<ProcedureBean> list = new ArrayList<ProcedureBean>();\n\t\twhile (rs.next()) {\n\t\t\tlist.add(loadSingle(rs));\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic ProcedureBean loadSingle(ResultSet rs) throws SQLException {\n\t\tProcedureBean procedure = new ProcedureBean(rs.getString(\"Code\"));\n\t\tprocedure.setDescription(rs.getString(\"Description\"));\n\t\tprocedure.setAttribute(rs.getString(\"Attribute\"));\n\t\tif (loadOVProcedureID) {\n\t\t\tprocedure.setOvProcedureID(rs.getLong(\"ID\"));\n\t\t\tprocedure.setDate(rs.getDate(\"visitDate\"));\n\t\t}\n\t\t\n\t\treturn procedure;\n\n\t}\n\n\tpublic PreparedStatement loadParameters(PreparedStatement ps, ProcedureBean bean) throws SQLException {\n\t\tps.setString(1, bean.getDescription());\n\t\treturn ps;\n\t}\n}", "ReferralBeanLoader.java": "package edu.ncsu.csc.itrust.beans.loaders;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.ReferralBean;\nimport edu.ncsu.csc.itrust.beans.ReferralBean.ReferralStatus;\n\n/**\n * A loader for ReferralBeans.\n * \n * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. \n * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}\n */\npublic class ReferralBeanLoader implements BeanLoader<ReferralBean> {\n\n\tpublic ReferralBeanLoader() {\n\n\t}\n\n\tpublic List<ReferralBean> loadList(ResultSet rs) throws SQLException {\n\t\tArrayList<ReferralBean> list = new ArrayList<ReferralBean>();\n\t\twhile (rs.next()) {\n\t\t\tlist.add(loadSingle(rs));\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic ReferralBean loadSingle(ResultSet rs) throws SQLException {\n\t\tReferralBean ref = new ReferralBean();\n\t\t// ERIC: fixed to correct for the mysql database bug plaguing java 1.5\n\t\tref.setId((long) rs.getInt(\"id\"));\n\t\t//ref.setId(rs.getLong(\"id\"));\n\t\tref.setSenderID(rs.getLong(\"SenderID\"));\n\t\tref.setReceiverID(rs.getLong(\"ReceiverID\"));\n\t\tref.setPatientID((long) rs.getInt(\"PatientID\"));\n\t\tref.setReferralDetails(rs.getString(\"ReferralDetails\"));\n\t\tref.setConsultationDetails(rs.getString(\"ConsultationDetails\"));\n\t\t\n\t\tif (rs.getString(\"Status\").equals(\"Pending\")) \n\t\t\tref.setStatus(ReferralStatus.Pending);\n\t\telse if (rs.getString(\"Status\").equals(\"Finished\")) \n\t\t\tref.setStatus(ReferralStatus.Finished);\n\t\telse \n\t\t\tref.setStatus(ReferralStatus.Declined);\n\t\t\n\t\t\n\t\treturn ref;\n\t}\n\n\tpublic PreparedStatement loadParameters(PreparedStatement ps, ReferralBean ref) throws SQLException {\n\t\tps.setLong(1, ref.getPatientID());\n\t\tps.setLong(2, ref.getSenderID());\n\t\tps.setLong(3, ref.getReceiverID());\n\t\tps.setString(4, ref.getReferralDetails());\n\t\tps.setString(5, ref.getConsultationDetails());\n\t\tps.setString(6, ref.getStatus().toString());\n\t\treturn ps;\n\t}\n}", "RemoteMonitoringDataBeanLoader.java": "package edu.ncsu.csc.itrust.beans.loaders;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.RemoteMonitoringDataBean;\n\n/**\n * A loader for RemoteMonitoringDataBeans.\n * \n * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. \n * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}\n */\npublic class RemoteMonitoringDataBeanLoader implements BeanLoader<RemoteMonitoringDataBean> {\n\n\tpublic List<RemoteMonitoringDataBean> loadList(ResultSet rs) throws SQLException {\n\t\tList<RemoteMonitoringDataBean> list = new ArrayList<RemoteMonitoringDataBean>();\n\t\twhile (rs.next()) {\n\t\t\tlist.add(loadSingle(rs));\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic PreparedStatement loadParameters(PreparedStatement ps, RemoteMonitoringDataBean bean) throws SQLException {\n\t\tthrow new IllegalStateException(\"unimplemented!\");\n\t}\n\n\tpublic RemoteMonitoringDataBean loadSingle(ResultSet rs) throws SQLException {\n\t\tRemoteMonitoringDataBean d = new RemoteMonitoringDataBean();\n\t\td.setLoggedInMID(rs.getLong(\"PatientID\"));\n\t\td.setSystolicBloodPressure(rs.getInt(\"systolicBloodPressure\"));\n\t\td.setDiastolicBloodPressure(rs.getInt(\"diastolicBloodPressure\"));\n\t\td.setGlucoseLevel(rs.getInt(\"glucoseLevel\"));\n\t\td.setTime(rs.getTimestamp(\"timeLogged\"));\n\t\td.setReporterRole(rs.getString(\"ReporterRole\"));\n\t\td.setReporterMID(rs.getLong(\"ReporterID\"));\n\t\treturn d;\n\t}\n\n}", "ReportRequestBeanLoader.java": "package edu.ncsu.csc.itrust.beans.loaders;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.ReportRequestBean;\n\n\n/**\n * A loader for ReportRequestBeans.\n * \n * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. \n * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}\n */\npublic class ReportRequestBeanLoader implements BeanLoader<ReportRequestBean> {\n\n\tpublic List<ReportRequestBean> loadList(ResultSet rs) throws SQLException {\n\t\tArrayList<ReportRequestBean> list = new ArrayList<ReportRequestBean>();\n\t\twhile (rs.next()) {\n\t\t\tlist.add(loadSingle(rs));\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic ReportRequestBean loadSingle(ResultSet rs) throws SQLException {\n\t\tReportRequestBean b = new ReportRequestBean();\n\t\tb.setID(rs.getLong(\"ID\"));\n\t\tb.setRequesterMID(rs.getLong(\"RequesterMID\"));\n\t\tb.setPatientMID(rs.getLong(\"PatientMID\"));\n\t\tb.setRequestedDate(rs.getTimestamp(\"RequestedDate\"));\n\t\tb.setViewedDate(rs.getTimestamp(\"ViewedDate\"));\n\t\tb.setStatus(rs.getString(\"Status\"));\n\t\treturn b;\n\t}\n\n\tpublic PreparedStatement loadParameters(PreparedStatement ps, ReportRequestBean bean) throws SQLException {\n\t\tthrow new IllegalStateException(\"unimplemented!\");\n\t}\n\n\n}", "SurveyLoader.java": "package edu.ncsu.csc.itrust.beans.loaders;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.SurveyBean;\n\n\n/**\n * A loader for SurveyBeans.\n * \n * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. \n * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}\n */\npublic class SurveyLoader implements BeanLoader<SurveyBean>{\n\n\tpublic List<SurveyBean> loadList(ResultSet rs) throws SQLException {\n\t\tthrow new IllegalStateException(\"unimplemented!\");\n\t}\n\n\tpublic PreparedStatement loadParameters(PreparedStatement ps, SurveyBean bean) throws SQLException {\n\t\tthrow new IllegalStateException(\"unimplemented!\");\n\t}\n\n\tpublic SurveyBean loadSingle(ResultSet rs) throws SQLException {\n\t\tSurveyBean survey = new SurveyBean();\n\t\tsurvey.setVisitID(rs.getLong(\"VisitID\"));\n\t\tsurvey.setSurveyDate(rs.getTimestamp(\"SurveyDate\"));\n\t\tsurvey.setExamRoomMinutes(rs.getInt(\"ExamRoomMinutes\"));\n\t\tsurvey.setWaitingRoomMinutes(rs.getInt(\"WaitingRoomMinutes\"));\n\t\tsurvey.setTreatmentSatisfaction(rs.getInt(\"TreatmentSatisfaction\"));\n\t\tsurvey.setVisitSatisfaction(rs.getInt(\"VisitSatisfaction\"));\n\n\t\treturn survey;\n\t}\n\n}", "SurveyResultBeanLoader.java": "package edu.ncsu.csc.itrust.beans.loaders;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.SurveyResultBean;\n/**\n * A loader for SurveyResultBeans.\n * \n * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. \n * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}\n */\npublic class SurveyResultBeanLoader implements BeanLoader<SurveyResultBean> {\n\n\tpublic List<SurveyResultBean> loadList(ResultSet rs) throws SQLException {\n\t\tArrayList<SurveyResultBean> list = new ArrayList<SurveyResultBean>();\n\t\twhile (rs.next()) {\n\t\t\tlist.add(loadSingle(rs));\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic PreparedStatement loadParameters(PreparedStatement ps, SurveyResultBean bean) throws SQLException {\n\t\tthrow new IllegalStateException(\"unimplemented!\");\n\t}\n\n\tpublic SurveyResultBean loadSingle(ResultSet rs) throws SQLException {\n\t\tSurveyResultBean surveyResult = new SurveyResultBean();\n\t\tsurveyResult.setHCPMID(rs.getLong(\"mid\"));\n\t\tsurveyResult.setAvgExamRoomMinutes(rs.getFloat(\"AvgExamRoomMinutes\"));\n\t\tsurveyResult.setAvgTreatmentSatisfaction(rs.getFloat(\"AvgTreatmentSatisfation\"));\n\t\tsurveyResult.setAvgVisitSatisfaction(rs.getFloat(\"AvgVisitSatisfaction\"));\n\t\tsurveyResult.setAvgWaitingRoomMinutes(rs.getFloat(\"AvgWaitingRoomMinutes\"));\n\t\tsurveyResult.setHCPaddress1(rs.getString(\"address1\"));\n\t\tsurveyResult.setHCPaddress2(rs.getString(\"address2\"));\n\t\tsurveyResult.setHCPcity(rs.getString(\"city\"));\n\t\tsurveyResult.setHCPstate(rs.getString(\"state\"));\n\t\tsurveyResult.setHCPzip(rs.getString(\"zip\"));\n\t\tsurveyResult.setHCPhospital(rs.getString(\"hospitalID\"));\n\t\tsurveyResult.setHCPFirstName(rs.getString(\"firstName\"));\n\t\tsurveyResult.setHCPLastName(rs.getString(\"lastName\"));\n\t\tsurveyResult.setHCPspecialty(rs.getString(\"specialty\"));\n\t\tsurveyResult.setPercentSatisfactionResults(rs.getFloat(\"PercentSatisfactionResults\"));\n\t\t\n\t\treturn surveyResult;\n\t}\n\n}", "TransactionBeanLoader.java": "package edu.ncsu.csc.itrust.beans.loaders;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.TransactionBean;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\n\n/**\n * A loader for TransactionBeans.\n * \n * Loads in information to/from beans using ResultSets and PreparedStatements. Use the superclass to enforce consistency. \n * For details on the paradigm for a loader (and what its methods do), see {@link BeanLoader}\n */\npublic class TransactionBeanLoader implements BeanLoader<TransactionBean> {\n\n\tpublic List<TransactionBean> loadList(ResultSet rs) throws SQLException {\n\t\tList<TransactionBean> list = new ArrayList<TransactionBean>();\n\t\twhile (rs.next()) {\n\t\t\tlist.add(loadSingle(rs));\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic PreparedStatement loadParameters(PreparedStatement ps, TransactionBean bean) throws SQLException {\n\t\tthrow new IllegalStateException(\"unimplemented!\");\n\t}\n\n\tpublic TransactionBean loadSingle(ResultSet rs) throws SQLException {\n\t\tTransactionBean t = new TransactionBean();\n\t\tt.setAddedInfo(rs.getString(\"addedInfo\"));\n\t\tt.setLoggedInMID(rs.getLong(\"loggedInMID\"));\n\t\tt.setSecondaryMID(rs.getLong(\"secondaryMID\"));\n\t\tt.setTimeLogged(rs.getTimestamp(\"timeLogged\"));\n\t\tt.setTransactionType(TransactionType.parse(rs.getInt(\"transactionCode\")));\n\t\tt.setTransactionID(rs.getLong(\"transactionID\"));\n\t\treturn t;\n\t}\n\n}", "AdverseEventsData.java": "package edu.ncsu.csc.itrust.charts;\n\nimport java.io.Serializable;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jfree.data.category.CategoryDataset;\nimport org.jfree.data.category.DefaultCategoryDataset;\n\nimport de.laures.cewolf.DatasetProduceException;\nimport de.laures.cewolf.DatasetProducer;\nimport de.laures.cewolf.links.CategoryItemLinkGenerator;\nimport de.laures.cewolf.tooltips.CategoryToolTipGenerator;\nimport edu.ncsu.csc.itrust.beans.AdverseEventBean;\n\n/**\n * This class handles the data for charting in CeWolf/JFreeChart. This class implements DatasetProducer,\n * CategoryToolTipGenerator, CategoryItemLinkGenerator, and Serializable.\n * \n * @author Jason\n *\n */\npublic class AdverseEventsData implements DatasetProducer, CategoryToolTipGenerator, CategoryItemLinkGenerator, Serializable {\n\t\n\t/**\n\t * The generated serializable ID.\n\t */\n\tprivate static final long serialVersionUID = 6145689621506271656L;\n\n\t// Hardcoded months array to make implementation simpler for Adverse Event charts\n    private final String[] months = {\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"June\",\"July\",\"Aug\",\"Sept\",\"Oct\",\"Nov\",\"Dec\"};\n   \n    // Initialize the values for each month to 0\n    private int[] values = {0,0,0,0,0,0,0,0,0,0,0,0};\n    \n    // This will be the list of adverse events\n    private List<AdverseEventBean> adverseEvents = new LinkedList<AdverseEventBean>();\n    \n    // This will be the name of the prescription or immunization under analysis\n    private String codeName;\n    \n    /**\n     * Called from the JSP page to initialize the list of Adverse Events needed to\n     * produce the desired chart.\n     * \n     * @param adEvents\n     * @param name\n     */\n    public void setAdverseEventsList(List<AdverseEventBean> adEvents, String name)\n    {\n    \tadverseEvents = adEvents;\n    \tthis.codeName = name;\n    }\n    \n    /**\n     * This method parses the list of Adverse Event Beans to initialize the chart dataset.\n     */\n    @SuppressWarnings(\"unchecked\")\n\tpublic Object produceDataset(Map params) throws DatasetProduceException {\n    \t// The DefaultCategoryDataset is used for bar charts.\n    \t// This dataset class may change based on the type of chart you wish to produce.\n        DefaultCategoryDataset dataset = new DefaultCategoryDataset(){\n\t\t\t/**\n\t\t\t * The generated serializable ID.\n\t\t\t */\n\t\t\tprivate static final long serialVersionUID = -8238489914590553747L;\n\n\t\t\t/**\n\t\t\t * @see java.lang.Object#finalize()\n\t\t\t */\n\t\t\tprotected void finalize() throws Throwable {\n\t\t\t\tsuper.finalize();\n\t\t\t}\n        };\n        \n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");\n        // For each Adverse Event in the list,\n        // parse the string repreentation of the report date\n        // to a Java Date object. Then, get the month of the\n        // Date object and increment the value count for that month.\n        for(AdverseEventBean event : adverseEvents)\n        {\n        \tCalendar cal = Calendar.getInstance();\n        \ttry {\n\t\t\t\tcal.setTime(sdf.parse(event.getDate()));\n\t\t\t} catch (ParseException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tthrow new DatasetProduceException(e.getMessage());\n\t\t\t}\n        \tint monthOfReport = cal.get(Calendar.MONTH);\n        \tvalues[monthOfReport]++;\n        }\n        \n        // For each month, add the monthly values to the dataset for\n        // producing the chart.\n        for(int i = 0; i < 12; i++)\n        {\n        \t// values[i] represents the number of adverse events for month i\n        \t// codeName represents the given prescription/immunization being analyzed\n        \t// month[i] is the static array of month names, to be used as labels on the chart\n        \tdataset.addValue(values[i],codeName,months[i]);\n        }\n          \n        return dataset;\n    }\n\n    /**\n     * This producer's data is invalidated after 5 seconds. By this method the\n     * producer can influence Cewolf's caching behaviour the way it wants to.\n     */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic boolean hasExpired(Map params, Date since) {\t\t\n\t\treturn (System.currentTimeMillis() - since.getTime())  > 5000;\n\t}\n\n\t/**\n\t * Returns a unique ID for this DatasetProducer\n\t */\n\tpublic String getProducerId() {\n\t\treturn \"AdverseEventsData DatasetProducer\";\n\t}\n\n    /**\n     * Returns a link target for a special data item.\n     */\n    public String generateLink(Object data, int series, Object category) {\n        return months[series];\n    }\n    \n\t/**\n\t * @see java.lang.Object#finalize()\n\t */\n\tprotected void finalize() throws Throwable {\n\t\tsuper.finalize();\n\t}\n\n\t/**\n\t * @see org.jfree.chart.tooltips.CategoryToolTipGenerator#generateToolTip(CategoryDataset, int, int)\n\t */\n\tpublic String generateToolTip(CategoryDataset arg0, int series, int arg2) {\n\t\treturn months[series];\n\t}\n\n}", "DAOFactory.java": "package edu.ncsu.csc.itrust.dao;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport edu.ncsu.csc.itrust.dao.mysql.AccessDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.AdverseEventDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.AllergyDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.ApptDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.ApptTypeDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.AuthDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.CPTCodesDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.DrugInteractionDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.FakeEmailDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.FamilyDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.HealthRecordsDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.HospitalsDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.ICDCodesDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.LOINCDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.LabProcedureDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.MessageDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.NDCodesDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.OfficeVisitDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.PatientDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.PersonnelDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.ReferralDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.RemoteMonitoringDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.ReportRequestDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.RiskDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.SurveyDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.SurveyResultDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.TransactionDAO;\nimport edu.ncsu.csc.itrust.dao.mysql.VisitRemindersDAO;\nimport edu.ncsu.csc.itrust.testutils.EvilDAOFactory;\nimport edu.ncsu.csc.itrust.testutils.TestDAOFactory;\n\n/**\n * The central mediator for all Database Access Objects. The production instance uses the database connection pool\n * provided by Tomcat (so use the production instance when doing stuff from JSPs in the \"real code\"). Both the\n * production and the test instance parses the context.xml file to get the JDBC connection.\n * \n * Also, @see {@link EvilDAOFactory} and @see {@link TestDAOFactory}.\n * \n * Any DAO that is added to the system should be added in this class, in the same way that all other DAOs are.\n * \n * @author Andy\n * \n */\npublic class DAOFactory {\n\tprivate static DAOFactory productionInstance = null;\n\tprivate IConnectionDriver driver;\n\n\t/**\n\t * \n\t * @return A production instance of the DAOFactory, to be used in deployment (by Tomcat).\n\t */\n\tpublic static DAOFactory getProductionInstance() {\n\t\tif (productionInstance == null)\n\t\t\tproductionInstance = new DAOFactory();\n\t\treturn productionInstance;\n\t}\n\n\tprotected DAOFactory() {\n\t\tthis.driver = new ProductionConnectionDriver();\n\t}\n\n\tpublic Connection getConnection() throws SQLException {\n\t\treturn driver.getConnection();\n\t}\n\n\tpublic AccessDAO getAccessDAO() {\n\t\treturn new AccessDAO(this);\n\t}\n\n\tpublic AllergyDAO getAllergyDAO() {\n\t\treturn new AllergyDAO(this);\n\t}\n\t\n\tpublic ApptDAO getApptDAO() {\n\t\treturn new ApptDAO(this);\n\t}\n\t\n\tpublic ApptTypeDAO getApptTypeDAO() {\n\t\treturn new ApptTypeDAO(this);\n\t}\n\n\tpublic AuthDAO getAuthDAO() {\n\t\treturn new AuthDAO(this);\n\t}\n\n\tpublic CPTCodesDAO getCPTCodesDAO() {\n\t\treturn new CPTCodesDAO(this);\n\t}\n\t\n\tpublic DrugInteractionDAO getDrugInteractionDAO() {\n\t\treturn new DrugInteractionDAO(this);\n\t}\n\n\tpublic FamilyDAO getFamilyDAO() {\n\t\treturn new FamilyDAO(this);\n\t}\n\n\tpublic HealthRecordsDAO getHealthRecordsDAO() {\n\t\treturn new HealthRecordsDAO(this);\n\t}\n\n\tpublic HospitalsDAO getHospitalsDAO() {\n\t\treturn new HospitalsDAO(this);\n\t}\n\n\tpublic ICDCodesDAO getICDCodesDAO() {\n\t\treturn new ICDCodesDAO(this);\n\t}\n\n\tpublic NDCodesDAO getNDCodesDAO() {\n\t\treturn new NDCodesDAO(this);\n\t}\n\n\tpublic OfficeVisitDAO getOfficeVisitDAO() {\n\t\treturn new OfficeVisitDAO(this);\n\t}\n\n\tpublic PatientDAO getPatientDAO() {\n\t\treturn new PatientDAO(this);\n\t}\n\n\tpublic PersonnelDAO getPersonnelDAO() {\n\t\treturn new PersonnelDAO(this);\n\t}\n\n\tpublic ReferralDAO getReferralDAO() {\n\t\treturn new ReferralDAO(this);\n\t}\n\t\n\tpublic RiskDAO getRiskDAO() {\n\t\treturn new RiskDAO(this);\n\t}\n\n\tpublic TransactionDAO getTransactionDAO() {\n\t\treturn new TransactionDAO(this);\n\t}\n\n\tpublic VisitRemindersDAO getVisitRemindersDAO() {\n\t\treturn new VisitRemindersDAO(this);\n\t}\n\n\tpublic FakeEmailDAO getFakeEmailDAO() {\n\t\treturn new FakeEmailDAO(this);\n\t}\n\n\tpublic ReportRequestDAO getReportRequestDAO() {\n\t\treturn new ReportRequestDAO(this);\n\t}\n\n\tpublic SurveyDAO getSurveyDAO() {\n\t\treturn new SurveyDAO(this);\n\t}\n\n\tpublic LabProcedureDAO getLabProcedureDAO() {\n\t\treturn new LabProcedureDAO(this);\n\t}\n\n\tpublic LOINCDAO getLOINCDAO() {\n\t\treturn new LOINCDAO(this);\n\t}\n\n\tpublic SurveyResultDAO getSurveyResultDAO() {\n\t\treturn new SurveyResultDAO(this);\n\t}\n\t\n\tpublic MessageDAO getMessageDAO() {\n\t\treturn new MessageDAO(this);\n\t}\n\t\n\tpublic AdverseEventDAO getAdverseEventDAO() {\n\t\treturn new AdverseEventDAO(this);\n\t}\n\t\n\tpublic RemoteMonitoringDAO getRemoteMonitoringDAO() {\n\t\treturn new RemoteMonitoringDAO(this);\n\t}\n\t\n}", "IConnectionDriver.java": "package edu.ncsu.csc.itrust.dao;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\n\n/**\n * Used by DAOFactory to abstract away different ways of getting our JDBC connection\n * \n * @author Andy\n * \n */\npublic interface IConnectionDriver {\n\tpublic Connection getConnection() throws SQLException;\n}", "ProductionConnectionDriver.java": "package edu.ncsu.csc.itrust.dao;\n\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport javax.naming.Context;\nimport javax.naming.InitialContext;\nimport javax.naming.NamingException;\nimport javax.sql.DataSource;\n\n/**\n * Produces the JDBC connection from Tomcat's JDBC connection pool (defined in context.xml). Produces and\n * exception when running the unit tests because they're not being run through Tomcat.\n * \n * @author Andy\n * \n */\npublic class ProductionConnectionDriver implements IConnectionDriver {\n\tpublic Connection getConnection() throws SQLException {\n\t\ttry {\n\t\t\treturn ((DataSource) (((Context) new InitialContext().lookup(\"java:comp/env\")))\n\t\t\t\t\t.lookup(\"jdbc/itrust\")).getConnection();\n\t\t} catch (NamingException e) {\n\t\t\tthrow new SQLException((\"Context Lookup Naming Exception: \" + e.getMessage()));\n\t\t}\n\t}\n}", "AccessDAO.java": "package edu.ncsu.csc.itrust.dao.mysql;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport edu.ncsu.csc.itrust.DBUtil;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\n\n/**\n * AccessDAO is for all queries related to authorization.\n * \n * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,\n * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are\n * added. DAOs can assume that all data has been validated and is correct.\n * \n * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be\n * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC\n * connections and/or accessing other DAOs.\n * \n * \n * @author Andy\n * \n */\npublic class AccessDAO {\n\tprivate DAOFactory factory;\n\n\t/**\n\t * The typical constructor.\n\t * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.\n\t */\n\tpublic AccessDAO(DAOFactory factory) {\n\t\tthis.factory = factory;\n\t}\n\n\t/**\n\t * Returns the number of minutes it would take for a session to time out. This is done by effectively\n\t * using the database table as a hash table. If a row in GlobalVariables does not exist, one is inserted\n\t * with the default value '20'.\n\t * \n\t * @return An int for the number of minutes.\n\t * @throws DBException\n\t */\n\tpublic int getSessionTimeoutMins() throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT Value FROM GlobalVariables WHERE Name='Timeout'\");\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\tif (rs.next())\n\t\t\t\treturn rs.getInt(\"Value\");\n\t\t\telse {\n\t\t\t\tinsertDefaultTimeout(conn, 20);\n\t\t\t\treturn 20;\n\t\t\t}\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Sets the number of minutes it would take for a session to timeout.\n\t * \n\t * @param mins An int specifying the number of minutes\n\t * @throws DBException\n\t */\n\tpublic void setSessionTimeoutMins(int mins) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"UPDATE GlobalVariables SET Value=? WHERE Name='Timeout'\");\n\t\t\tps.setInt(1, mins);\n\t\t\tint numUpdated = ps.executeUpdate();\n\t\t\tif (numUpdated == 0) // no value in the table\n\t\t\t\tinsertDefaultTimeout(conn, mins);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\tprivate void insertDefaultTimeout(Connection conn, int mins) throws SQLException {\n\t\tPreparedStatement ps = null;\n\t\tps = conn.prepareStatement(\"INSERT INTO GlobalVariables(Name,Value) VALUES ('Timeout', ?)\");\n\t\tps.setInt(1, mins);\n\t\tps.executeUpdate();\n\t}\n}", "AdverseEventDAO.java": "package edu.ncsu.csc.itrust.dao.mysql;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.DBUtil;\nimport edu.ncsu.csc.itrust.beans.AdverseEventBean;\nimport edu.ncsu.csc.itrust.beans.loaders.AdverseEventBeanLoader;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport java.sql.Timestamp;\n\n/**\n * Used for the logging mechanism.\n * \n * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,\n * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are\n * added. DAOs can assume that all data has been validated and is correct.\n * \n * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be\n * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC\n * connections and/or accessing other DAOs.\n * \n * @author Andy\n * \n */\npublic class AdverseEventDAO {\n\tprivate DAOFactory factory;\n\tprivate AdverseEventBeanLoader aeLoader;\n\n\t/**\n\t * The typical constructor.\n\t * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.\n\t */\n\tpublic AdverseEventDAO(DAOFactory factory) {\n\t\tthis.factory = factory;\n\t\tthis.aeLoader = new AdverseEventBeanLoader();\n\t}\n\n\t/**\n\t * Gets all the adverse event reports for a certain user MID.\n\t * @param mid The MID of the user to be looked up.\n\t * @return A java.util.List of AdverseEventBeans.\n\t * @throws SQLException\n\t * @throws DBException \n\t */\npublic List<AdverseEventBean> getReportsFor(long mid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\t\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM AdverseEvents WHERE PatientMID = ?\");\n\t\t\tps.setLong(1, mid);\n\t\t\tResultSet rs = ps.executeQuery();\n\n\t\t\tList<AdverseEventBean> aeList = this.aeLoader.loadList(rs);\n\t\t\treturn aeList;\n\t\t} catch(SQLException e){\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally{\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Adds a message to the database.\n\t * @param mBean A bean representing the message to be added.\n\t * @throws SQLException\n\t * @throws DBException \n\t */\n\tpublic void addReport(AdverseEventBean aeBean, long hcpmid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry{\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\n\t\t\t\t\t\"INSERT INTO AdverseEvents (PatientMID, PresImmu, Code, Comment, Prescriber, Status) \"\n\t\t\t\t\t  + \"VALUES (?, ?, ?, ?, ?, ?)\");\n\t\t\tps.setString(1, aeBean.getMID());\n\t\t\tps.setString(2, aeBean.getDrug());\n\t\t\tps.setString(3, aeBean.getCode());\n\t\t\tps.setString(4, aeBean.getDescription());\n\t\t\tps.setLong(5, hcpmid);\n\t\t\tps.setString(6,\"Active\");\n\t\t\tps.executeUpdate();\n\t\t} catch(SQLException e){\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\tpublic long getHCPMID(int id) throws DBException{\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM AdverseEvents WHERE id=?\");\n\t\t\tps.setInt(1, id);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\n\t\t\tlong hcpMID = 0;\n\t\t\tif(rs.next()) {\n\t\t\t\t\n\t\t\t\t hcpMID = rs.getLong(\"Prescriber\");\n\t\t\t}\n\t\t\treturn hcpMID;\n\t\t} catch(SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\tpublic AdverseEventBean getReport(int id) throws DBException{\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM AdverseEvents WHERE id=?\");\n\t\t\tps.setInt(1, id);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\n\t\t\tList<AdverseEventBean> aeList = aeLoader.loadList(rs);\n\t\t\treturn aeList.get(0);\n\t\t} catch(SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\t\t\t\n\t\t}\n\t}\n\t\n\tpublic long removeReport(int id) throws DBException{\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"UPDATE AdverseEvents SET Status = ? WHERE id = ?\");\n\t\t\tString removed = \"removed\";\n\t\t\tps.setString(1, removed);\n\t\t\tps.setInt(2,id);\n\t\t\tps.executeUpdate();\n\t\t\tlong a = DBUtil.getLastInsert(conn);\n\t\t\treturn a;\n\t\t} catch(SQLException e){\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\t\n\t\t}\n\t}\n\t\n\tpublic List<AdverseEventBean> getUnremovedAdverseEventsByCode(String code) throws DBException\n\t{\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM adverseevents WHERE code=? AND status=?\");\n\t\t\tps.setString(1, code);\n\t\t\tps.setString(2, \"Active\");\n\t\t\tResultSet rs;\n\t\t\trs = ps.executeQuery();\n\t\t\treturn aeLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\tpublic String getNameForCode(String code) throws DBException\n\t{\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT PresImmu FROM adverseevents WHERE code=?\");\n\t\t\tps.setString(1, code);\n\t\t\tResultSet rs;\n\t\t\trs = ps.executeQuery();\n\t\t\tif(rs.next()) {\n\t\t\t\t return rs.getString(\"PresImmu\");\n\t\t\t}\n\t\t\treturn \"Name not Found\";\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\tpublic List<AdverseEventBean> getPerscriptions(String start, String end) throws ParseException, DBException{\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\t\n\t\ttry{\n\t\t\tSimpleDateFormat fmt = new SimpleDateFormat(\"MM/dd/yyy\");\n\t\t\tDate beginning = fmt.parse(start);\n\t\t\tDate ending = fmt.parse(end);\n\t \n\t\t\tconn = factory.getConnection();\n\t\t\t//AND NDCodes.Code=AdverseEvents.Code \n\t\t\tps = conn.prepareStatement(\"SELECT * FROM AdverseEvents,NDCodes WHERE AdverseEvents.TimeLogged >= ? AND AdverseEvents.TimeLogged <= ? AND NDCodes.Code=AdverseEvents.Code ORDER BY AdverseEvents.Code, AdverseEvents.TimeLogged DESC\");\n\t\t\t \n\t\t\tps.setTimestamp(1, new Timestamp(beginning.getTime()));\n\t\t\tps.setTimestamp(2, new Timestamp(ending.getTime() + 1000L * 60L * 60 * 24L));\n\t\t\tResultSet rs = ps.executeQuery();\n\t\n\t\t\tList<AdverseEventBean> aeList = aeLoader.loadList(rs);\n\t\t\treturn aeList;\n\t\t} catch(SQLException e){\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\t\n\t\t}\n\t}\n\t\n\tpublic List<AdverseEventBean> getImmunizations(String start, String end) throws ParseException, DBException{\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tSimpleDateFormat fmt = new SimpleDateFormat(\"MM/dd/yyy\");\n\t\t\tDate beginning = fmt.parse(start);\n\t\t\tDate ending = fmt.parse(end);\n\t \n\t\t\tconn = factory.getConnection();\n\t\t\t//AND NDCodes.Code=AdverseEvents.Code \n\t\t\tps = conn.prepareStatement(\"SELECT * FROM AdverseEvents,CPTCodes WHERE AdverseEvents.TimeLogged >= ? AND AdverseEvents.TimeLogged <= ? AND CPTCodes.Code=AdverseEvents.Code ORDER BY AdverseEvents.Code, AdverseEvents.TimeLogged DESC\");\n\t\t\t \n\t\t\tps.setTimestamp(1, new Timestamp(beginning.getTime()));\n\t\t\tps.setTimestamp(2, new Timestamp(ending.getTime() + 1000L * 60L * 60 * 24L));\n\t\t\tResultSet rs = ps.executeQuery();\n\t\n\t\t\tList<AdverseEventBean> aeList = aeLoader.loadList(rs);\n\t\t\treturn aeList;\n\t\t} catch(SQLException e){\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\t\t\t\n\t\t}\n\t}\n}", "AllergyDAO.java": "package edu.ncsu.csc.itrust.dao.mysql;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.DBUtil;\nimport edu.ncsu.csc.itrust.beans.AllergyBean;\nimport edu.ncsu.csc.itrust.beans.loaders.AllergyBeanLoader;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\n\n/**\n * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,\n * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are\n * added. DAOs can assume that all data has been validated and is correct.\n * \n * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be\n * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC\n * connections and/or accessing other DAOs.\n * \n * @author Andy\n * \n */\npublic class AllergyDAO {\n\tprivate DAOFactory factory;\n\tprivate AllergyBeanLoader allergyBeanLoader = new AllergyBeanLoader();\n\n\t/**\n\t * The typical constructor.\n\t * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.\n\t */\n\tpublic AllergyDAO(DAOFactory factory) {\n\t\tthis.factory = factory;\n\t}\n\n\t/**\n\t * Returns a list of patient's allergies.\n\t * @param pid A long for the MID of the patient we are looking up.\n\t * @return A java.util.List of AllergyBeans associated with this patient.\n\t * @throws DBException\n\t */\n\tpublic List<AllergyBean> getAllergies(long pid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM Allergies WHERE PatientID=? ORDER BY FirstFound DESC\");\n\t\t\tps.setLong(1, pid);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn allergyBeanLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Adds an allergy to this patient's list.\n\t * @param pid The MID of the patient whose allergy we are adding.\n\t * @param description The name of the allergen.\n\t * @throws DBException\n\t */\n\tpublic void addAllergy(long pid, String description) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"INSERT INTO Allergies(PatientID, Description) VALUES (?,?)\");\n\t\t\tps.setLong(1, pid);\n\t\t\tps.setString(2, description);\n\t\t\tps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n}", "ApptDAO.java": "package edu.ncsu.csc.itrust.dao.mysql;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.DBUtil;\nimport edu.ncsu.csc.itrust.beans.ApptBean;\nimport edu.ncsu.csc.itrust.beans.loaders.ApptBeanLoader;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\n\npublic class ApptDAO {\n\tprivate DAOFactory factory;\n\tprivate ApptBeanLoader abloader;\n\t\n\tpublic ApptDAO(DAOFactory factory) {\n\t\tthis.factory = factory;\n\t\tthis.abloader = new ApptBeanLoader();\n\t}\n\t\n\tpublic List<ApptBean> getApptsFor(long mid) throws SQLException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\tconn = factory.getConnection();\n\t\t\n\t\tif(mid >= (long) 999999999){\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM appointment WHERE doctor_id=? ORDER BY sched_date;\");\n\t\t}\n\t\telse {\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM appointment WHERE patient_id=? ORDER BY sched_date;\");\n\t\t}\n\t\t\n\t\tps.setLong(1, mid);\n\t\t\n\t\tResultSet rs = ps.executeQuery();\n\t\tList<ApptBean> abList = this.abloader.loadList(rs);\n\t\tDBUtil.closeConnection(conn, ps);\n\t\treturn abList;\n\t}\n\t\n\tpublic List<ApptBean> getAllAppts() throws SQLException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\tconn = factory.getConnection();\n\t\t\n\t\tps = conn.prepareStatement(\"SELECT * FROM appointment;\");\n\t\t\n\t\tResultSet rs = ps.executeQuery();\n\t\tList<ApptBean> abList = this.abloader.loadList(rs);\n\t\tDBUtil.closeConnection(conn, ps);\n\t\treturn abList;\n\t}\n\t\n\tpublic void scheduleAppt(ApptBean appt) throws SQLException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\tconn = factory.getConnection();\n\t\t\n\t\tps = conn.prepareStatement(\n\t\t\t\t\"INSERT INTO appointment (appt_type, patient_id, doctor_id, sched_date, comment) \"\n\t\t\t  + \"VALUES (?, ?, ?, ?, ?)\");\n\t\tps = this.abloader.loadParameters(ps, appt);\n\t\t\n\t\tps.executeUpdate();\n\t\t\n\t\tDBUtil.closeConnection(conn, ps);\n\t}\n}", "ApptTypeDAO.java": "package edu.ncsu.csc.itrust.dao.mysql;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.DBUtil;\nimport edu.ncsu.csc.itrust.beans.ApptTypeBean;\nimport edu.ncsu.csc.itrust.beans.loaders.ApptTypeBeanLoader;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\n\npublic class ApptTypeDAO {\n\tprivate DAOFactory factory;\n\tprivate ApptTypeBeanLoader atLoader;\n\t\n\tpublic ApptTypeDAO(DAOFactory factory) {\n\t\tthis.factory = factory;\n\t\tthis.atLoader = new ApptTypeBeanLoader();\n\t}\n\t\n\tpublic List<ApptTypeBean> getApptTypes() throws SQLException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\n\t\tconn = factory.getConnection();\n\t\tps = conn.prepareStatement(\"SELECT * FROM appointmenttype\");\n\t\tResultSet rs = ps.executeQuery();\n\t\t\n\t\tList<ApptTypeBean> atList = this.atLoader.loadList(rs);\n\t\tDBUtil.closeConnection(conn, ps);\n\n\t\treturn atList;\n\t}\n\t\n\tpublic boolean addApptType(ApptTypeBean apptType) throws SQLException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\n\t\tconn = factory.getConnection();\n\t\tps = conn.prepareStatement(\n\t\t\t\t\"INSERT INTO appointmenttype (appt_type, duration) \"\n\t\t\t  + \"VALUES (?, ?)\");\n\t\tthis.atLoader.loadParameters(ps, apptType);\n\t\tint x = ps.executeUpdate();\n\n\t\tDBUtil.closeConnection(conn, ps);\n\t\t\n\t\tif(x > 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\t\n\tpublic boolean editApptType(ApptTypeBean apptType) throws SQLException, DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\n\t\tconn = factory.getConnection();\n\t\tps = conn.prepareStatement(\"UPDATE appointmenttype SET duration=? WHERE appt_type=?\");\n\t\tps.setInt(1, apptType.getDuration());\n\t\tps.setString(2, apptType.getName());\n\t\tint x = ps.executeUpdate();\n\n\t\tDBUtil.closeConnection(conn, ps);\n\t\t\n\t\tif(x > 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n}", "AuthDAO.java": "package edu.ncsu.csc.itrust.dao.mysql;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport edu.ncsu.csc.itrust.DBUtil;\nimport edu.ncsu.csc.itrust.RandomPassword;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.enums.Role;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\n\n/**\n * AuthDAO is for anything that has to do with authentication. Most methods access the users table.\n * \n * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,\n * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are\n * added. DAOs can assume that all data has been validated and is correct.\n * \n * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be\n * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC\n * connections and/or accessing other DAOs.\n * \n * @author Andy\n * \n */\npublic class AuthDAO {\n\tpublic static final long LOGIN_TIMEOUT = 15 * 60 * 1000;// 15 min\n\tprivate DAOFactory factory;\n\n\t/**\n\t * The typical constructor.\n\t * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.\n\t */\n\tpublic AuthDAO(DAOFactory factory) {\n\t\tthis.factory = factory;\n\t}\n\n\t/**\n\t * Add a particular user to the system. Does not add user-specific information (e.g. Patient or HCP).\n\t * Initially sets security question to a random set of characters, so that nobody should be able to guess\n\t * its value.\n\t * \n\t * @param mid The user's MID as a Long.\n\t * @param role The role of the user as a Role enum {@link Role}\n\t * @param password The password for the new user.\n\t * @return A string representing the newly added randomly-generated password. \n\t * @throws DBException\n\t */\n\tpublic String addUser(Long mid, Role role, String password) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement pstmt = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tpstmt = conn\n\t\t\t\t\t.prepareStatement(\"INSERT INTO Users (MID, PASSWORD, ROLE, sQuestion, sAnswer) VALUES (?,?,?,?,?)\");\n\t\t\tpstmt.setLong(1, mid);\n\t\t\tpstmt.setString(2, password);\n\t\t\tpstmt.setString(3, role.toString());\n\t\t\tpstmt.setString(4, \"Enter the random password given in your account email\");\n\t\t\tString pwd = RandomPassword.getRandomPassword();\n\t\t\tpstmt.setString(5, pwd);\n\t\t\tpstmt.executeUpdate();\n\t\t\treturn pwd;\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, pstmt);\n\t\t}\n\t}\n\n\t/**\n\t * Reset the security question and answer for a particular user\n\t * \n\t * @param question The security question as a string.\n\t * @param answer The security answer as a string.\n\t * @param mid The MID of the user as a long.\n\t * @throws DBException\n\t */\n\tpublic void setSecurityQuestionAnswer(String question, String answer, long mid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement pstmt = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tpstmt = conn.prepareStatement(\"UPDATE Users SET sQuestion = ?, sAnswer = ? WHERE MID = ?\");\n\t\t\tpstmt.setString(1, question);\n\t\t\tpstmt.setString(2, answer);\n\t\t\tpstmt.setLong(3, mid);\n\t\t\tpstmt.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, pstmt);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the user name of a user from just the MID\n\t * \n\t * @param mid The MID of the user to get the name of.\n\t * @return The user's name as a String.\n\t * @throws DBException\n\t * @throws iTrustException\n\t */\n\tpublic String getUserName(long mid) throws DBException, iTrustException {\n\t\tRole role = getUserRole(mid);\n\t\tswitch (role) {\n\t\t\tcase HCP:\n\t\t\tcase PHA:\n\t\t\tcase ADMIN:\n\t\t\tcase UAP:\n\t\t\tcase ER:\n\t\t\t\treturn factory.getPersonnelDAO().getName(mid);\n\t\t\tcase PATIENT:\n\t\t\t\treturn factory.getPatientDAO().getName(mid);\n\t\t\tcase TESTER:\n\t\t\t\treturn String.valueOf(mid);\n\t\t\tdefault:\n\t\t\t\tthrow new iTrustException(\"Role \" + role + \" not supported\");\n\t\t}\n\t}\n\n\t/**\n\t * Returns the role of a particular MID\n\t * \n\t * @param mid The MID of the user to look up.\n\t * @return The {@link Role} of the user as an enum.\n\t * @throws DBException\n\t * @throws iTrustException\n\t */\n\tpublic Role getUserRole(long mid) throws DBException, iTrustException {\n\t\tConnection conn = null;\n\t\tPreparedStatement pstmt = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tpstmt = conn.prepareStatement(\"SELECT role FROM Users WHERE MID=?\");\n\t\t\tpstmt.setLong(1, mid);\n\t\t\tResultSet rs;\n\t\t\trs = pstmt.executeQuery();\n\t\t\tif (rs.next()) {\n\t\t\t\treturn Role.parse(rs.getString(\"role\"));\n\t\t\t} else {\n\t\t\t\tthrow new iTrustException(\"User does not exist\");\n\t\t\t}\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, pstmt);\n\t\t}\n\t}\n\n\t/**\n\t * Change the password of a particular user\n\t * \n\t * @param mid The MID of the user whose password we are changing.\n\t * @param password The new password.\n\t * @throws DBException\n\t */\n\tpublic void resetPassword(long mid, String password) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"UPDATE Users SET password=? WHERE MID=?\");\n\t\t\tps.setString(1, password);\n\t\t\tps.setLong(2, mid);\n\t\t\tps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Return the security question for a particular user.\n\t * \n\t * @param mid The MID of the user we are looking up.\n\t * @return The security question of the user we are looking up.\n\t * @throws iTrustException\n\t */\n\tpublic String getSecurityQuestion(long mid) throws iTrustException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT sQuestion FROM Users WHERE MID=?\");\n\t\t\tps.setLong(1, mid);\n\t\t\tResultSet r = ps.executeQuery();\n\t\t\tif (r.next())\n\t\t\t\treturn r.getString(\"sQuestion\");\n\t\t\telse\n\t\t\t\tthrow new iTrustException(\"No security question set for MID: \" + mid);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Return the security answer of a particular user\n\t * \n\t * @param mid The MID of the user we are looking up.\n\t * @return The security answer as a String.\n\t * @throws iTrustException\n\t */\n\tpublic String getSecurityAnswer(long mid) throws iTrustException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT sAnswer FROM Users WHERE MID=?\");\n\t\t\tps.setLong(1, mid);\n\t\t\tResultSet r = ps.executeQuery();\n\t\t\tif (r.next())\n\t\t\t\treturn r.getString(\"sAnswer\");\n\t\t\telse\n\t\t\t\tthrow new iTrustException(\"No security answer set for MID \" + mid);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Record a login failure, which blacklists the ipAddress. Uses the database table like a hash table where\n\t * the key is the user's IP address. If the user's IP address is not in the table, a row with \"1\" is\n\t * added.\n\t * \n\t * @param ipAddr The IP address of the user as a String.\n\t * @throws DBException\n\t */\n\tpublic void recordLoginFailure(String ipAddr) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn\n\t\t\t\t\t.prepareStatement(\"UPDATE LoginFailures SET FailureCount=FailureCount+1, lastFailure=CURRENT_TIMESTAMP WHERE IPAddress=?\");\n\t\t\t\t\t//.prepareStatement(\"INSERT INTO LoginFailures VALUES(?,?,?)\");\n\t\t\tps.setString(1, ipAddr);\n\t\t\t//ps.setInt(2, failures);\n\t\t\t//ps.setDate(3, Calendar.getInstance().getTime());\n\t\t\tint numUpdated = ps.executeUpdate();\n\t\t\tif (numUpdated == 0) // if there wasn't an empty row to begin with\n\t\t\t\tinsertLoginFailureRow(ipAddr, 1, conn);// now they have a row AND a strike against\n\t\t\t// 'em\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Record a reset password failure, which blacklists the ipAddress. Uses the database table like a hash\n\t * table where the key is the user's IP address. If the user's IP address is not in the table, a row with\n\t * \"1\" is added.\n\t * \n\t * @param ipAddr The IP address of the user as a String.\n\t * @throws DBException\n\t */\n\tpublic void recordResetPasswordFailure(String ipAddr) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn\n\t\t\t\t\t.prepareStatement(\"UPDATE ResetPasswordFailures SET failurecount=failurecount+1 WHERE ipaddress=?\");\n\t\t\tps.setString(1, ipAddr);\n\t\t\tint numUpdated = ps.executeUpdate();\n\t\t\tif (numUpdated == 0) // if there wasn't an empty row to begin with\n\t\t\t\tinsertResetPasswordRow(ipAddr, 1, conn);// now they have a row AND a strike against\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Return the number of failures from resetting a password, given an IP address.\n\t * \n\t * @param ipAddr An IP address for the associated attempt as a String.\n\t * @return An int representing the number of failures.\n\t * @throws DBException\n\t */\n\tpublic int getResetPasswordFailures(String ipAddr) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM ResetPasswordFailures WHERE IPADDRESS=?\");\n\t\t\tps.setString(1, ipAddr);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\tif (rs.next()) {\n\t\t\t\t// if we're more than X minutes out, clear the failure count\n\t\t\t\tif (System.currentTimeMillis() - rs.getTimestamp(\"lastFailure\").getTime() > LOGIN_TIMEOUT) {\n\t\t\t\t\tupdateResetFailuresToZero(ipAddr, conn);\n\t\t\t\t\treturn 0;\n\t\t\t\t} else {\n\t\t\t\t\treturn rs.getInt(\"failureCount\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tinsertResetPasswordRow(ipAddr, 0, conn);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Return the number of failures from login failures a password, given an IP address.\n\t * \n\t * @param ipAddr The IP address for this attempt as a String.\n\t * @return An int representing the number of failures which have occured.\n\t * @throws DBException\n\t */\n\tpublic int getLoginFailures(String ipAddr) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM LoginFailures WHERE IPADDRESS=?\");\n\t\t\tps.setString(1, ipAddr);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\tif (rs.next()) {\n\t\t\t\t// if we're more than X minutes out, clear the failure count\n\t\t\t\tif (System.currentTimeMillis() - rs.getTimestamp(\"lastFailure\").getTime() > LOGIN_TIMEOUT) {\n\t\t\t\t\tupdateFailuresToZero(ipAddr, conn);\n\t\t\t\t\treturn 0;\n\t\t\t\t} else {\n\t\t\t\t\treturn rs.getInt(\"failureCount\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tinsertLoginFailureRow(ipAddr, 0, conn);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\tprivate void insertLoginFailureRow(String ipAddr, int failureCount, Connection conn) throws DBException,\n\t\t\tSQLException {\n\t\tPreparedStatement ps = conn\n\t\t\t\t.prepareStatement(\"INSERT INTO LoginFailures(IPAddress, failureCount) VALUES(?,?)\");\n\t\tps.setString(1, ipAddr);\n\t\tps.setInt(2, failureCount);\n\t\tps.executeUpdate();\n\t}\n\n\tprivate void insertResetPasswordRow(String ipAddr, int failureCount, Connection conn) throws DBException,\n\t\t\tSQLException {\n\t\tPreparedStatement ps = conn\n\t\t\t\t.prepareStatement(\"INSERT INTO ResetPasswordFailures(IPAddress, failureCount) VALUES(?,?)\");\n\t\tps.setString(1, ipAddr);\n\t\tps.setInt(2, failureCount);\n\t\tps.executeUpdate();\n\t}\n\n\tprivate void updateFailuresToZero(String ipAddr, Connection conn) throws DBException, SQLException {\n\t\tPreparedStatement ps = conn\n\t\t\t\t.prepareStatement(\"UPDATE LoginFailures SET failureCount=0 WHERE IPAddress=?\");\n\t\tps.setString(1, ipAddr);\n\t\tps.executeUpdate();\n\t}\n\t\n\tpublic void resetLoginFailuresToZero(String ipAddr) throws DBException, SQLException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry{\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn\n\t\t\t\t\t.prepareStatement(\"UPDATE LoginFailures SET failureCount=0 WHERE IPAddress=?\");\n\t\t\tps.setString(1, ipAddr);\n\t\t\tps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\tprivate void updateResetFailuresToZero(String ipAddr, Connection conn) throws DBException, SQLException {\n\t\tPreparedStatement ps = conn\n\t\t\t\t.prepareStatement(\"UPDATE ResetPasswordFailures SET failureCount=0 WHERE IPAddress=?\");\n\t\tps.setString(1, ipAddr);\n\t\tps.executeUpdate();\n\t}\n\n\t/**\n\t * Check that a user actually exists.\n\t * \n\t * @param mid\n\t * @return\n\t * @throws DBException\n\t */\n\tpublic boolean checkUserExists(long mid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM Users WHERE MID=?\");\n\t\t\tps.setLong(1, mid);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn rs.next();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n}", "CPTCodesDAO.java": "package edu.ncsu.csc.itrust.dao.mysql;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.DBUtil;\nimport edu.ncsu.csc.itrust.beans.ProcedureBean;\nimport edu.ncsu.csc.itrust.beans.loaders.ProcedureBeanLoader;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\n\n/**\n * Used for managing CPT codes.\n * \n * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,\n * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are\n * added. DAOs can assume that all data has been validated and is correct.\n * \n * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be\n * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC\n * connections and/or accessing other DAOs.\n * \n * The CPT code set accurately describes medical, surgical, and diagnostic services \n * and is designed to communicate uniform information about medical services and procedures \n * among physicians, coders, patients, accreditation organizations, and payers for administrative, \n * financial, and analytical purposes.\n *\n * @see http://www.ama-assn.org/ama/pub/physician-resources/solutions-managing-your-practice/coding-billing-insurance/cpt/about-cpt.shtml\n * @author Andy\n * \n */\npublic class CPTCodesDAO {\n\tprivate DAOFactory factory;\n\tprivate ProcedureBeanLoader procedureBeanLoader = new ProcedureBeanLoader();\n\n\t/**\n\t * The typical constructor.\n\t * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.\n\t */\n\tpublic CPTCodesDAO(DAOFactory factory) {\n\t\tthis.factory = factory;\n\t}\n\n\t/**\n\t * Returns a list of all CPT codes.\n\t * \n\t * @return A java.util.List of ProcedureBeans for the CPT codes.\n\t * @throws DBException\n\t */\n\tpublic List<ProcedureBean> getAllCPTCodes() throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM CPTCodes ORDER BY CODE\");\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn procedureBeanLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * Returns a list of all CPT codes.\n\t * \n\t * @return A java.util.List of all Immunization-related CPT codes.\n\t * @throws DBException\n\t */\n\tpublic List<ProcedureBean> getImmunizationCPTCodes() throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"select * from cptcodes where attribute='immunization' order by code\");\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn procedureBeanLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Returns a particular procedure description for a code.\n\t * \n\t * @param code The string representation of the code.\n\t * @return The textual description of the code.\n\t * @throws DBException\n\t */\n\tpublic ProcedureBean getCPTCode(String code) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM CPTCodes WHERE Code = ?\");\n\t\t\tps.setString(1, code);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\tif (rs.next())\n\t\t\t\treturn procedureBeanLoader.loadSingle(rs);\n\t\t\treturn null;\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Adds a new CPT code, returns that it was added successfully\n\t * \n\t * @param proc A ProcedureBean representing the new code information.\n\t * @return A boolean for whether the operation was successful.\n\t * @throws DBException\n\t * @throws iTrustException\n\t */\n\tpublic boolean addCPTCode(ProcedureBean proc) throws DBException, iTrustException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"INSERT INTO CPTCodes (Code, Description, Attribute) \" + \"VALUES (?,?,?)\");\n\t\t\tps.setString(1, proc.getCPTCode());\n\t\t\tps.setString(2, proc.getDescription());\n\t\t\tps.setString(3, proc.getAttribute());\n\t\t\treturn (1 == ps.executeUpdate());\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tif (1062 == e.getErrorCode())\n\t\t\t\tthrow new iTrustException(\"Error: Code already exists.\");\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Change the procedure description for a particular CPT code\n\t * \n\t * @param proc A ProcedureBean representing the new code information.\n\t * @return A boolean for whether the operation was successful.\n\t * @throws DBException\n\t */\n\tpublic int updateCode(ProcedureBean proc) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"UPDATE CPTCodes SET Description = ?, Attribute = ? WHERE Code = ?\");\n\t\t\tps.setString(1, proc.getDescription());\n\t\t\tps.setString(2, proc.getAttribute());\n\t\t\tps.setString(3, proc.getCPTCode());\n\t\t\treturn ps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n}", "DrugInteractionDAO.java": "package edu.ncsu.csc.itrust.dao.mysql;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.DBUtil;\nimport edu.ncsu.csc.itrust.beans.DrugInteractionBean;\nimport edu.ncsu.csc.itrust.beans.loaders.DrugInteractionBeanLoader;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\n\n/**\n * Used for managing drug interactions.\n * \n * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,\n * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are\n * added. DAOs can assume that all data has been validated and is correct.\n * \n * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be\n * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC\n * connections and/or accessing other DAOs.\n * \n * @see http://www.fda.gov/Drugs/InformationOnDrugs/ucm142438.htm\n * @author Andy\n * \n */\npublic class DrugInteractionDAO {\n\tprivate DAOFactory factory;\n\tprivate DrugInteractionBeanLoader interactionLoader;\n\t\n\t/**\n\t * The typical constructor.\n\t * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.\n\t */\n\tpublic DrugInteractionDAO(DAOFactory factory) {\n\t\tthis.factory = factory;\n\t\tinteractionLoader = new DrugInteractionBeanLoader();\n\t}\n\t\n\t/**\n\t * Returns a list of all drug interactions for the input drug name\n\t * \n\t * @return A java.util.List of DrugInteractionBeans.\n\t * @throws DBException\n\t */\n\tpublic List<DrugInteractionBean> getInteractions(String drugCode) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM druginteractions WHERE FirstDrug = ? OR SecondDrug = ?\");\n\t\t\tps.setString(1, drugCode);\n\t\t\tps.setString(2, drugCode);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn interactionLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * Adds a new drug interaction, returns whether or not the addition was successful. If the code already exists, an\n\t * iTrustException is thrown.\n\t * \n\t * @param firstDrug  The name of the first drug in an interaction.\n\t * @param secondDrug  The name of the second drug in an interaction.\n\t * @param description  Explanation of the drug interaction.\n\t * @return A boolean indicating success or failure.\n\t * @throws DBException\n\t * @throws iTrustException\n\t */\n\tpublic boolean reportInteraction(String firstDrug, String secondDrug, String description) throws DBException, iTrustException {\n\t\tif(firstDrug.equals(secondDrug)) throw new iTrustException(\"Drug cannot interact with itself.\");\n\t\t\n\t\tList<DrugInteractionBean> currentIntsDrug2 = getInteractions(secondDrug);\n\t\tfor(DrugInteractionBean dib : currentIntsDrug2){\n\t\t\tif(dib.getSecondDrug().equals(firstDrug)){\n\t\t\t\tthrow new iTrustException(\"Error: Interaction between these drugs already exists.\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"INSERT INTO druginteractions (FirstDrug, SecondDrug, Description) \" + \"VALUES (?,?,?)\");\n\t\t\tps.setString(1, firstDrug);\n\t\t\tps.setString(2, secondDrug);\n\t\t\tps.setString(3, description);\n\t\t\treturn (1 == ps.executeUpdate());\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tif (1062 == e.getErrorCode())\n\t\t\t\tthrow new iTrustException(\"Error: Interaction between these drugs already exists.\");\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * Remove an interaction from the database\n\t * \n\t * @param firstDrug  The name of the first patient\n\t * @param secondDrug  The name of the second patient\n\t * @return true if removed successfully, false if not in list\n\t */\n\tpublic boolean deleteInteraction(String firstDrug,String secondDrug) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"DELETE FROM druginteractions WHERE (FirstDrug = ? OR SecondDrug = ?) AND (FirstDrug = ? OR SecondDrug = ?)\");\n\t\t\tps.setString(1, firstDrug);\n\t\t\tps.setString(2, firstDrug);\n\t\t\tps.setString(3, secondDrug);\n\t\t\tps.setString(4, secondDrug);\n\t\t\tif(ps.executeUpdate() == 0)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n}", "FakeEmailDAO.java": "package edu.ncsu.csc.itrust.dao.mysql;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.DBUtil;\nimport edu.ncsu.csc.itrust.beans.Email;\nimport edu.ncsu.csc.itrust.beans.loaders.EmailBeanLoader;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\n\n/**\n * \n * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,\n * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are\n * added. DAOs can assume that all data has been validated and is correct.\n * \n * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be\n * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC\n * connections and/or accessing other DAOs.\n * \n * @author Andy\n * \n */\npublic class FakeEmailDAO {\n\tprivate DAOFactory factory;\n\tprivate EmailBeanLoader emailBeanLoader = new EmailBeanLoader();\n\n\t/**\n\t * The typical constructor.\n\t * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.\n\t */\n\tpublic FakeEmailDAO(DAOFactory factory) {\n\t\tthis.factory = factory;\n\t}\n\n\t/**\n\t * Return all emails that have been \"sent\" (inserted into the database)\n\t * \n\t * @return A java.util.List of Email objects representing fake e-mails.\n\t * @throws DBException\n\t */\n\tpublic List<Email> getAllEmails() throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM FakeEmail ORDER BY AddedDate DESC\");\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn emailBeanLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * Return all emails that a person has sent\n\t * \n\t * @param email The \"From\" email address as a string.\n\t * @return A java.util.List of fake emails.\n\t * @throws DBException\n\t */\n\tpublic List<Email> getEmailsByPerson(String email) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM FakeEmail WHERE ToAddr LIKE ? ORDER BY AddedDate DESC\");\n\t\t\tps.setString(1, \"%\" + email + \"%\");\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn emailBeanLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * \"Send\" an email, which just inserts it into the database.\n\t * \n\t * @param email The Email object to insert.\n\t * @throws DBException\n\t */\n\tpublic void sendEmailRecord(Email email) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"INSERT INTO FakeEmail (ToAddr, FromAddr, Subject, Body) \"\n\t\t\t\t\t+ \"VALUES (?,?,?,?)\");\n\t\t\temailBeanLoader.loadParameters(ps, email);\n\t\t\tps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Returns a list of emails that have the given string as a substring of the body\n\t * @param string The string to search within the body.\n\t * @return A java.util.List of fake emails.\n\t * @throws DBException \n\t */\n\tpublic List<Email> getEmailWithBody(String bodySubstring) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM FakeEmail WHERE Instr(Body,?)>0 ORDER BY AddedDate DESC\");\n\t\t\tps.setString(1, bodySubstring);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn emailBeanLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n}", "FamilyDAO.java": "package edu.ncsu.csc.itrust.dao.mysql;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.DBUtil;\nimport edu.ncsu.csc.itrust.beans.FamilyMemberBean;\nimport edu.ncsu.csc.itrust.beans.loaders.FamilyBeanLoader;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\n\n/**\n * Used for queries related to families.\n * \n * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,\n * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are\n * added. DAOs can assume that all data has been validated and is correct.\n * \n * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be\n * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC\n * connections and/or accessing other DAOs.\n * \n * @author Andy\n * \n */\npublic class FamilyDAO {\n\tprivate DAOFactory factory;\n\tprivate FamilyBeanLoader familyBeanLoader;\n\n\t/**\n\t * The typical constructor.\n\t * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.\n\t */\n\tpublic FamilyDAO(DAOFactory factory) {\n\t\tthis.factory = factory;\n\t}\n\n\t/**\n\t * Return the information of the mother and father of this patient\n\t * \n\t * @param pid -\n\t *            this patient\n\t * @return\n\t * @throws DBException\n\t */\n\tpublic List<FamilyMemberBean> getParents(long pid) throws DBException {\n\t\treturn getFamilyMembers(pid, \"Parent\",\n\t\t\t\t\"SELECT p2.FirstName AS FirstName, p2.LastName AS LastName, p2.MID as MID \"\n\t\t\t\t\t\t+ \"FROM Patients p1, Patients p2 \"\n\t\t\t\t\t\t+ \"WHERE p1.MID=? AND (p1.MotherMID=p2.MID OR p1.FatherMID=p2.MID)\", false);\n\t}\n\n\t/**\n\t * Return a list of patients who share at least one parent (and that parent is not '0') with this patient\n\t * \n\t * @param pid -\n\t *            this patient\n\t * @return A java.util.list of FamilyMemberBeans.\n\t * @throws DBException\n\t */\n\tpublic List<FamilyMemberBean> getSiblings(long pid) throws DBException {\n\t\treturn getFamilyMembers(pid, \"Sibling\",\n\t\t\t\t\"SELECT p2.FirstName AS FirstName, p2.LastName AS LastName, p2.MID as MID \"\n\t\t\t\t\t\t+ \"FROM Patients p1, Patients p2 \" + \"WHERE p1.MID=? AND p1.MID<>p2.MID \"\n\t\t\t\t\t\t+ \"AND( (p1.MotherMID=p2.MotherMID AND p2.MotherMID<>0)\"\n\t\t\t\t\t\t+ \"  OR (p1.FatherMID=p2.FatherMID AND p1.FatherMID<>0))\", false);\n\t}\n\n\t/**\n\t * Return a list of patients whose mother or father is this patient\n\t * \n\t * @param pid -\n\t *            this patient\n\t * @return A java.util.List of FamilyMemberBeans.\n\t * @throws DBException\n\t */\n\tpublic List<FamilyMemberBean> getChildren(long pid) throws DBException {\n\t\treturn getFamilyMembers(pid, \"Child\", \"SELECT FirstName, LastName, MID FROM Patients \"\n\t\t\t\t+ \"WHERE MotherMID=? or FatherMID=?\", true);\n\t}\n\n\t/**\n\t * Private helper method (since all three are alike)\n\t * \n\t * @param pid\n\t * @param relation\n\t * @param query\n\t * @param secondParam -\n\t *            add the pid as the second parameter (the 3rd query was a little different)\n\t * \n\t * @return A java.util.List of FamilyMemberBeans.\n\t * @throws DBException\n\t */\n\tprivate List<FamilyMemberBean> getFamilyMembers(long pid, String relation, String query,\n\t\t\tboolean secondParam) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\tfamilyBeanLoader = new FamilyBeanLoader(relation);\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(query);\n\t\t\tps.setLong(1, pid);\n\t\t\tif (secondParam)\n\t\t\t\tps.setLong(2, pid);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn familyBeanLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n}", "HealthRecordsDAO.java": "package edu.ncsu.csc.itrust.dao.mysql;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.DBUtil;\nimport edu.ncsu.csc.itrust.beans.HealthRecord;\nimport edu.ncsu.csc.itrust.beans.loaders.HealthRecordsBeanLoader;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\n\n/**\n * Used for all health records where a whole history is kept.\n * \n * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,\n * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are\n * added. DAOs can assume that all data has been validated and is correct.\n * \n * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be\n * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC\n * connections and/or accessing other DAOs.\n * \n * @author Andy\n * \n */\npublic class HealthRecordsDAO {\n\tprivate HealthRecordsBeanLoader loader = new HealthRecordsBeanLoader();\n\tprivate DAOFactory factory;\n\n\t/**\n\t * The typical constructor.\n\t * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.\n\t */\n\tpublic HealthRecordsDAO(DAOFactory factory) {\n\t\tthis.factory = factory;\n\t}\n\n\t/**\n\t * Returns a list of all health records for a particular patient\n\t * \n\t * @param mid The MID of the patient to look up.\n\t * @return A java.util.List of HealthRecords.\n\t * @throws DBException\n\t */\n\tpublic List<HealthRecord> getAllHealthRecords(long mid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM PersonalHealthInformation \"\n\t\t\t\t\t+ \"WHERE PatientID=? ORDER BY ASOFDATE DESC\");\n\t\t\tps.setLong(1, mid);\n\t\t\tResultSet rs;\n\t\t\trs = ps.executeQuery();\n\t\t\treturn loader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Adds a health record for a particular patient\n\t * \n\t * @param record The HealthRecord object to insert.\n\t * @return A boolean indicating whether the insert was successful.\n\t * @throws DBException\n\t */\n\tpublic boolean add(HealthRecord record) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"INSERT INTO PersonalHealthInformation(PatientID,Height,Weight,\"\n\t\t\t\t\t+ \"Smoker,BloodPressureN,BloodPressureD,CholesterolHDL,CholesterolLDL,CholesterolTri,\"\n\t\t\t\t\t+ \"HCPID) VALUES(?,?,?,?,?,?,?,?,?,?)\");\n\t\t\tloader.loadParameters(ps, record);\n\t\t\tint numInserted = ps.executeUpdate();\n\t\t\treturn (numInserted == 1);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n}", "HospitalsDAO.java": "package edu.ncsu.csc.itrust.dao.mysql;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.DBUtil;\nimport edu.ncsu.csc.itrust.beans.HospitalBean;\nimport edu.ncsu.csc.itrust.beans.loaders.HospitalBeanLoader;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\n\n/**\n * Used for managing hospitals\n * \n * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,\n * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are\n * added. DAOs can assume that all data has been validated and is correct.\n * \n * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be\n * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC\n * connections and/or accessing other DAOs.\n * \n * @author Andy\n * \n */\npublic class HospitalsDAO {\n\tprivate DAOFactory factory;\n\tprivate HospitalBeanLoader hospitalLoader = new HospitalBeanLoader();\n\n\t/**\n\t * The typical constructor.\n\t * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.\n\t */\n\tpublic HospitalsDAO(DAOFactory factory) {\n\t\tthis.factory = factory;\n\t}\n\n\t/**\n\t * Returns a list of all hospitals sorted alphabetically\n\t * \n\t * @return A java.util.List of HospitalBeans.\n\t * @throws DBException\n\t */\n\tpublic List<HospitalBean> getAllHospitals() throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM Hospitals ORDER BY HospitalName\");\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn hospitalLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Returns a particular hospital given its ID\n\t * \n\t * @param id The String ID of the hospital.\n\t * @return A HospitalBean representing this hospital.\n\t * @throws DBException\n\t */\n\tpublic HospitalBean getHospital(String id) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM Hospitals WHERE HospitalID = ?\");\n\t\t\tps.setString(1, id);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\tif (rs.next())\n\t\t\t\treturn hospitalLoader.loadSingle(rs);\n\t\t\treturn null;\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Adds a hospital\n\t * \n\t * @param hosp The HospitalBean object to insert.\n\t * @return A boolean indicating whether the insertion was successful.\n\t * @throws DBException\n\t * @throws iTrustException\n\t */\n\tpublic boolean addHospital(HospitalBean hosp) throws DBException, iTrustException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"INSERT INTO Hospitals (HospitalID, HospitalName) \" + \"VALUES (?,?)\");\n\t\t\tps.setString(1, hosp.getHospitalID());\n\t\t\tps.setString(2, hosp.getHospitalName());\n\t\t\treturn (1 == ps.executeUpdate());\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tif (1062 == e.getErrorCode())\n\t\t\t\tthrow new iTrustException(\"Error: Hospital already exists.\");\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Updates a particular hospital's description. Returns the number of rows affected (should be 1)\n\t * \n\t * @param hosp The HospitalBean to update.\n\t * @return An int indicating the number of affected rows.\n\t * @throws DBException\n\t */\n\tpublic int updateHospital(HospitalBean hosp) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"UPDATE Hospitals SET HospitalName = ? \" + \"WHERE HospitalID = ?\");\n\t\t\tps.setString(1, hosp.getHospitalName());\n\t\t\tps.setString(2, hosp.getHospitalID());\n\t\t\treturn ps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Assign an HCP to a hospital. If they have already been assigned to that hospital, then an\n\t * iTrustException is thrown.\n\t * \n\t * @param hcpID The HCP's MID to assign to the hospital.\n\t * @param hospitalID The ID of the hospital to assign them to.\n\t * @return A boolean indicating whether the assignment was a success.\n\t * @throws DBException\n\t * @throws iTrustException\n\t */\n\tpublic boolean assignHospital(long hcpID, String hospitalID) throws DBException, iTrustException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"INSERT INTO HCPAssignedHos (HCPID, HosID) VALUES (?,?)\");\n\t\t\tps.setLong(1, hcpID);\n\t\t\tps.setString(2, hospitalID);\n\t\t\treturn (1 == ps.executeUpdate());\n\t\t} catch (SQLException e) {\n\t\t\tif (1062 == e.getErrorCode())\n\t\t\t\tthrow new iTrustException(\"HCP \" + hcpID + \" already assigned to hospital \" + hospitalID);\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Unassigns an HCP to a hospital. Returns whether or not any changes were made\n\t * \n\t * @param hcpID The MID of the HCP to remove.\n\t * @param hospitalID The ID of the hospital being removed from.\n\t * @return A boolean indicating success.\n\t * @throws DBException\n\t */\n\tpublic boolean removeHospitalAssignment(long hcpID, String hospitalID) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"DELETE FROM HCPAssignedHos WHERE HCPID = ? AND HosID = ?\");\n\t\t\tps.setLong(1, hcpID);\n\t\t\tps.setString(2, hospitalID);\n\t\t\treturn (1 == ps.executeUpdate());\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Removes all hospital assignments for a particular HCP. Returns the number of rows affected.\n\t * \n\t * @param hcpID The MID of the HCP.\n\t * @return An int representing the number of hospital assignments removed.\n\t * @throws DBException\n\t */\n\tpublic int removeAllHospitalAssignmentsFrom(long hcpID) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"DELETE FROM HCPAssignedHos WHERE HCPID = ?\");\n\t\t\tps.setLong(1, hcpID);\n\t\t\treturn ps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n}", "ICDCodesDAO.java": "package edu.ncsu.csc.itrust.dao.mysql;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.DBUtil;\nimport edu.ncsu.csc.itrust.beans.DiagnosisBean;\nimport edu.ncsu.csc.itrust.beans.loaders.DiagnosisBeanLoader;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\n\n/**\n * Used for managing all ICD codes.\n * \n * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,\n * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are\n * added. DAOs can assume that all data has been validated and is correct.\n * \n * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be\n * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC\n * connections and/or accessing other DAOs.\n * \n * The International Statistical Classification of Diseases and Related Health Problems \n * (most commonly known by the abbreviation ICD) provides codes to classify diseases and a \n * wide variety of signs, symptoms, abnormal findings, complaints, social circumstances and \n * external causes of injury or disease. \n * \n * @see http://www.cdc.gov/nchs/icd9.htm\n * @author Andy\n * \n */\npublic class ICDCodesDAO {\n\tprivate DAOFactory factory;\n\tprivate DiagnosisBeanLoader diagnosisLoader = new DiagnosisBeanLoader();\n\n\t/**\n\t * The typical constructor.\n\t * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.\n\t */\n\tpublic ICDCodesDAO(DAOFactory factory) {\n\t\tthis.factory = factory;\n\t}\n\n\t/**\n\t * Returns all ICD9CM codes sorted by code\n\t * \n\t * @return java.util.List of DiagnosisBeans\n\t * @throws DBException\n\t */\n\tpublic List<DiagnosisBean> getAllICDCodes() throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM ICDCodes ORDER BY CODE\");\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn diagnosisLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Returns a particular description for a given code\n\t * \n\t * @param code The String representation of the code.\n\t * @return A DiagnosisBean of the code.\n\t * @throws DBException\n\t */\n\tpublic DiagnosisBean getICDCode(String code) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM ICDCodes WHERE Code = ?\");\n\t\t\tps.setString(1, code);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\tif (rs.next())\n\t\t\t\treturn diagnosisLoader.loadSingle(rs);\n\t\t\treturn null;\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Adds an ICD9CM code. Returns whether or not the change was made.\n\t * \n\t * @param diag The DiagnosisBean representing the changes.\n\t * @return A boolean indicating success.\n\t * @throws DBException\n\t * @throws iTrustException\n\t */\n\tpublic boolean addICDCode(DiagnosisBean diag) throws DBException, iTrustException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"INSERT INTO ICDCodes (Code, Description, Chronic) \" + \"VALUES (?,?,?)\");\n\t\t\tps.setString(1, diag.getICDCode());\n\t\t\tps.setString(2, diag.getDescription());\n\t\t\tps.setString(3, diag.getClassification());\n\t\t\treturn (1 == ps.executeUpdate());\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tif (1062 == e.getErrorCode())\n\t\t\t\tthrow new iTrustException(\"Error: Code already exists.\");\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Changes a the description of a particular code.\n\t * \n\t * @param diag A DiagnosisBean representing the changes.\n\t * @return A boolean indicating the number of updated rows.\n\t * @throws DBException\n\t */\n\tpublic int updateCode(DiagnosisBean diag) throws DBException {\n\t\tint rows;\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"UPDATE ICDCodes SET Description = ?, Chronic = ? WHERE Code = ?\");\n\t\t\tps.setString(1, diag.getDescription());\n\t\t\tps.setString(2, diag.getClassification());\n\t\t\tps.setString(3, diag.getICDCode());\n\t\t\trows = ps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t\treturn rows;\n\t}\n\n}", "LabProcedureDAO.java": "package edu.ncsu.csc.itrust.dao.mysql;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.DBUtil;\nimport edu.ncsu.csc.itrust.beans.LabProcedureBean;\nimport edu.ncsu.csc.itrust.beans.loaders.LabProcedureBeanLoader;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\n\n/**\n * A DAO for managing lab procedure codes. Database Access Object. All info coming into a DAO is already validated. \n * Just worry about DB stuff here. Note that all DAOs need to have a DAOFactory with which to access other \n * DAOs and to get connections. Also, every DAO must have a constructor with a DAOFactory as a parameter.\n */\npublic class LabProcedureDAO {\n\tprivate DAOFactory factory;\n\tprivate LabProcedureBeanLoader labProcedureLoader;\n\n\t/**\n\t * The typical constructor.\n\t * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.\n\t */\n\tpublic LabProcedureDAO(DAOFactory factory) {\n\t\tthis.factory = factory;\n\t\tlabProcedureLoader = new LabProcedureBeanLoader();\n\t}\n\t\n\t/**\n\t * Get a list of the lab procedures associated with a given patient.\n\t * @param id The MID of the patient as a long.\n\t * @return A java.util.List of LabProcedureBeans\n\t * @throws DBException\n\t */\n\tpublic List<LabProcedureBean> getLabProceduresForPatient(long id) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\n\t\ttry {\n\t\t\tif (id == 0L) throw new SQLException(\"PatientMID cannot be null\");\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM LabProcedure WHERE PatientMID = ? AND Rights = ? ORDER BY UpdatedDate DESC\");\n\t\t\tps.setLong(1, id);\n\t\t\tps.setString(2, LabProcedureBean.Allow);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn labProcedureLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * Gets all the lab procedures for a given patient that occur within the next month.\n\t * @param id The MID of the patient as a long.\n\t * @return A java.util.List of LabProcedureBeans.\n\t * @throws DBException\n\t */\n\tpublic List<LabProcedureBean> getLabProceduresForPatientForNextMonth(long id) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\n\t\ttry {\n\t\t\tif (id == 0L) throw new SQLException(\"PatientMID cannot be null\");\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM LabProcedure WHERE PatientMID = ? AND Rights = ? AND Status = ? AND (DateDiff(SYSDATE(),UpdatedDate) <= 30) ORDER BY UpdatedDate DESC\");\n\t\t\tps.setLong(1, id);\n\t\t\tps.setString(2, LabProcedureBean.Allow);\n\t\t\tps.setString(3, LabProcedureBean.Completed);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn labProcedureLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * Gets an individual lab procedure.\n\t * @param id The ID of the lab procedure.\n\t * @return A LabProcedureBean representing the procedure.\n\t * @throws DBException\n\t */\n\tpublic LabProcedureBean getLabProcedure(long id) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM LabProcedure WHERE LaboratoryProcedureID = ?\");\n\t\t\tps.setLong(1, id);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\trs.next();\n\t\t\treturn labProcedureLoader.loadSingle(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t/**\n\t * Gets all procedures for Patient\n\t * @param mid patient id\n\t * @return A java.util.List of LabProcedureBeans.\n\t * @throws DBException\n\t */\n\tpublic List<LabProcedureBean> getAllLabProceduresDate(long mid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\n\t\ttry {\n\t\t\tif (mid == 0L) throw new SQLException(\"PatientMID cannot be null\");\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM LabProcedure WHERE PatientMID = ? ORDER BY UpdatedDate DESC\");\n\t\t\tps.setLong(1, mid);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn labProcedureLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t/**\n\t * This gets all the procedures for a particular patient on a particular office visit\n\t * @param mid The MID of the patient.\n\t * @param ovid The Office Visit ID.\n\t * @return A java.util.List of LabProcedureBeans.\n\t * @throws DBException\n\t */\n\tpublic List<LabProcedureBean> getAllLabProceduresForDocOV(long mid, long ovid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\n\t\ttry {\n\t\t\tif (mid == 0L) throw new SQLException(\"PatientMID cannot be null\");\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM LabProcedure WHERE PatientMID = ? AND OfficeVisitID = ? ORDER BY UpdatedDate DESC\");\n\t\t\tps.setLong(1, mid);\n\t\t\tps.setLong(2, ovid);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn labProcedureLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * This gets all the procedures for a particular patient on a particular office visit\n\t * @param mid The MID of the patient.\n\t * @param ovid The Office Visit ID.\n\t * @return A java.util.List of LabProcedureBeans\n\t * @throws DBException\n\t */\n\tpublic List<LabProcedureBean> getAllLabProceduresForDocOV(long ovid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM LabProcedure WHERE OfficeVisitID = ? \");\n\t\t\tps.setLong(1, ovid);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn labProcedureLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * Gets all lab procedures, period.\n\t * @return A java.util.List of LabProcedureBeans.\n\t * @throws DBException\n\t */\n\tpublic List<LabProcedureBean> getAllLabProcedures() throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM LabProcedure ORDER BY UpdatedDate ASC\");\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn labProcedureLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * Gets the lab procedures for a given LHCP that occur within the next month.\n\t * @param ovid The Office Visit ID conducted by the LHCP in question.\n\t * @return A java.util.List of LabProcedureBeans.\n\t * @throws DBException\n\t */\n\tpublic List<LabProcedureBean> getLabProceduresForLHCPForNextMonth(long ovid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tif (ovid == 0L) throw new SQLException(\"OfficeVisitID cannot be null\");\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM LabProcedure WHERE OfficeVisitID = ? AND Status = ? AND (DateDiff(SYSDATE(),UpdatedDate) <= 30) ORDER BY UpdatedDate DESC\");\n\t\t\tps.setLong(1, ovid);\n\t\t\tps.setString(2, LabProcedureBean.Completed);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn labProcedureLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * Inserts a lab procedure into the database.\n\t * @param b The LabProcedureBean to be inserted.\n\t * @return A long containing the ID of the newly inserted lab procedure bean.\n\t * @throws DBException\n\t */\n\tpublic long addLabProcedure(LabProcedureBean b) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tif (b.getPid() == 0L) throw new SQLException(\"PatientMID cannot be null\");\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"INSERT INTO LabProcedure (PatientMID, LaboratoryProcedureCode, Status, Commentary, Results, OfficeVisitID, Rights) VALUES (?,?,?,?,?,?,?)\");\n\t\t\tps.setLong(1, b.getPid());\n\t\t\tps.setString(2, b.getLoinc());\n\t\t\tps.setString(3, b.getStatus());\n\t\t\tps.setString(4, b.getCommentary());\n\t\t\tps.setString(5, b.getResults());\n\t\t\tps.setLong(6, b.getOvID());\n\t\t\tps.setString(7, b.getRights());\n\t\t\tps.executeUpdate();\n\t\t\treturn DBUtil.getLastInsert(conn);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * Updates an existing lab procedure.\n\t * @param b The LabProcedureBean representing the procedure to be updated.\n\t * @throws DBException\n\t */\n\tpublic void updateLabProcedure(LabProcedureBean b) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tif (b.getPid() == 0L) throw new SQLException(\"PatientMID cannot be null\");\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"UPDATE LabProcedure SET Status = ?, Commentary = ?, Results = ?, UpdatedDate = ? WHERE LaboratoryProcedureID=?\");\n\t\t\tps.setString(1, b.getStatus());\n\t\t\tps.setString(2, b.getCommentary());\n\t\t\tps.setString(3, b.getResults());\n\t\t\tps.setTimestamp(4, new java.sql.Timestamp(System.currentTimeMillis()));\n\t\t\tps.setLong(5, b.getProcedureID());\n\t\t\tps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * Gets all the lab procedures that correspond to a particular LOINC.\n\t * @param id The LOINC in question.\n\t * @return A java.util.List of LabProcedureBeans.\n\t * @throws DBException\n\t */\n\tpublic List<LabProcedureBean> getAllLabProceduresLOINC(long id) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\n\t\ttry {\n\t\t\tif (id == 0L) throw new SQLException(\"PatientMID cannot be null\");\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM LabProcedure WHERE PatientMID = ? ORDER BY LaboratoryProcedureCode ASC\");\n\t\t\tps.setLong(1, id);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn labProcedureLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * Updates the rights of a user on a given lab procedure.\n\t * @param b The LabProcedureBean in question.\n\t * @throws DBException\n\t */\n\tpublic void updateRights(LabProcedureBean b) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tif (b.getPid() == 0L) throw new SQLException(\"PatientMID cannot be null\");\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"UPDATE LabProcedure SET Rights = ?, UpdatedDate = ? WHERE LaboratoryProcedureID=?\");\n\t\t\tps.setString(1, b.getRights());\n\t\t\tps.setTimestamp(2, new java.sql.Timestamp(System.currentTimeMillis()));\n\t\t\tps.setLong(3, b.getProcedureID());\n\t\t\tps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\n\n}", "LOINCDAO.java": "package edu.ncsu.csc.itrust.dao.mysql;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.DBUtil;\nimport edu.ncsu.csc.itrust.beans.LOINCbean;\nimport edu.ncsu.csc.itrust.beans.loaders.LOINCBeanLoader;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\n\n/**\n * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,\n * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are\n * added. DAOs can assume that all data has been validated and is correct.\n * \n * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be\n * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC\n * connections and/or accessing other DAOs.\n * \n * Logical Observation Identifiers Names and Codes (LOINC) is a database and universal\n *  standard for identifying medical laboratory observations. \n *  \n * @see http://loinc.org/\n * @author Ben Smith\n */\npublic class LOINCDAO {\n\tprivate DAOFactory factory;\n\tprivate LOINCBeanLoader LOINCLoader;\n\n\t/**\n\t * The typical constructor.\n\t * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.\n\t */\n\tpublic LOINCDAO(DAOFactory factory) {\n\t\tthis.factory = factory;\n\t\tLOINCLoader = new LOINCBeanLoader();\n\t}\n\t\n\t/**\n\t * Adds a LOINC\n\t * \n\t * @param hosp The LOINCbean representing the new code to be added.\n\t * @throws DBException\n\t * @throws iTrustException\n\t */\n\tpublic void addLOINC(LOINCbean hosp) throws DBException, iTrustException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"INSERT INTO LOINC (LaboratoryProcedureCode, Component, KindOfProperty, TimeAspect, System, ScaleType, MethodType) \" + \"VALUES (?,?,?,?,?,?,?)\");\n\t\t\tps.setString(1, hosp.getLabProcedureCode());\n\t\t\tps.setString(2, hosp.getComponent());\n\t\t\tps.setString(3, hosp.getKindOfProperty());\n\t\t\tps.setString(4, hosp.getTimeAspect());\n\t\t\tps.setString(5, hosp.getSystem());\n\t\t\tps.setString(6, hosp.getScaleType());\n\t\t\tps.setString(7, hosp.getMethodType());\n\t\t\tps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tif (1062 == e.getErrorCode())\n\t\t\t\tthrow new iTrustException(\"Error: LOINC already exists.\");\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\t\n\n\t/**\n\t * Returns all LOINCs associated with LaboratoryProcedureCode\n\t * \n\t * @param visitID The code of the Laboratory Procedure Code as a String.\n\t * @return A java.util.List of LOINCBeans matching the Laboratory Procedure Code.\n\t * @throws DBException\n\t */\n\tpublic List<LOINCbean> getProcedures(String visitID) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"Select * From LOINC Where LaboratoryProcedureCode = ? \");\n\t\t\tps.setString(1, visitID);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn LOINCLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t * Updates the information in LOINC.\n\t * \n\t * @param ov\n\t * @throws DBException\n\t */\n\tpublic int update(LOINCbean ov) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"UPDATE LOINC SET Component=?, KindOfProperty=?, TimeAspect=?, System=?, ScaleType=?, MethodType=? WHERE LaboratoryProcedureCode=?\");\n\t\t\tps.setString(1, ov.getComponent());\n\t\t\tps.setString(2, ov.getKindOfProperty());\n\t\t\tps.setString(3, ov.getTimeAspect());\n\t\t\tps.setString(4, ov.getSystem());\n\t\t\tps.setString(5, ov.getScaleType());\n\t\t\tps.setString(6, ov.getMethodType());\n\t\t\tps.setString(7, ov.getLabProcedureCode());\n\t\t\treturn ps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * Returns all LOINCs as a list.\n\t * \n\t * @return A java.util.List of LOINCbeans.\n\t * @throws DBException\n\t */\n\tpublic List<LOINCbean> getAllLOINC() throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM LOINC\");\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn LOINCLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\n}", "MessageDAO.java": "package edu.ncsu.csc.itrust.dao.mysql;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.DBUtil;\nimport edu.ncsu.csc.itrust.beans.MessageBean;\nimport edu.ncsu.csc.itrust.beans.loaders.MessageBeanLoader;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\n\n/**\n * Used for the logging mechanism.\n * \n * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,\n * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are\n * added. DAOs can assume that all data has been validated and is correct.\n * \n * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be\n * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC\n * connections and/or accessing other DAOs.\n * \n * @author Andy\n * \n */\npublic class MessageDAO {\n\tprivate DAOFactory factory;\n\tprivate MessageBeanLoader mbLoader;\n\n\t/**\n\t * The typical constructor.\n\t * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.\n\t */\n\tpublic MessageDAO(DAOFactory factory) {\n\t\tthis.factory = factory;\n\t\tthis.mbLoader = new MessageBeanLoader();\n\t}\n\n\t/**\n\t * Gets all the messages for a certain user MID.\n\t * @param mid The MID of the user to be looked up.\n\t * @return A java.util.List of MessageBeans.\n\t * @throws SQLException\n\t */\n\t\n\tpublic List<MessageBean> getMessagesFor(long mid) throws SQLException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\n\t\tconn = factory.getConnection();\n\t\tps = conn.prepareStatement(\"SELECT * FROM message WHERE to_id = ? ORDER BY sent_date DESC\");\n\t\tps.setLong(1, mid);\n\t\tResultSet rs = ps.executeQuery();\n\n\t\tList<MessageBean> mbList = this.mbLoader.loadList(rs);\n\n\t\tDBUtil.closeConnection(conn, ps);\n\n\t\treturn mbList;\n\t}\n\n\t/**\n\t * Gets all the messages for a certain user MID sorted by ascending time.\n\t * @param mid The MID of the user to be looked up.\n\t * @return A java.util.List of MessageBeans.\n\t * @throws SQLException\n\t */\n\tpublic List<MessageBean> getMessagesTimeAscending(long mid) throws SQLException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\n\t\tconn = factory.getConnection();\n\t\tps = conn.prepareStatement(\"SELECT * FROM message WHERE to_id = ? ORDER BY sent_date ASC\");\n\t\tps.setLong(1, mid);\n\t\tResultSet rs = ps.executeQuery();\n\n\t\tList<MessageBean> mbList = this.mbLoader.loadList(rs);\n\n\t\tDBUtil.closeConnection(conn, ps);\n\n\t\treturn mbList;\n\t}\n\t\n\t/**\n\t * Gets all the messages for a certain user MID sorted by name ascending.\n\t * @param mid The MID of the user to be looked up.\n\t * @return A java.util.List of MessageBeans.\n\t * @throws SQLException\n\t */\n\tpublic List<MessageBean> getMessagesNameAscending(long mid) throws SQLException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs;\n\n\t\tconn = factory.getConnection();\n\t\tif(mid >= (long) 999999999){\n\t\t\tps = conn.prepareStatement(\"SELECT message.* FROM message, patients WHERE message.from_id=patients.mid AND message.to_id=? ORDER BY patients.lastName ASC, patients.firstName ASC, message.sent_date ASC\");\n\t\t\tps.setLong(1, mid);\n\t\t\trs = ps.executeQuery();\n\t\t}\n\t\telse{\n\t\t\tps = conn.prepareStatement(\"SELECT message.* FROM message, personnel WHERE message.from_id=personnel.mid AND message.to_id=? ORDER BY personnel.lastName ASC, personnel.firstName ASC, message.sent_date ASC\");\n\t\t\tps.setLong(1, mid);\n\t\t\trs = ps.executeQuery();\n\t\t}\n\n\t\tList<MessageBean> mbList = this.mbLoader.loadList(rs);\n\n\t\tDBUtil.closeConnection(conn, ps);\n\n\t\treturn mbList;\n\t}\n\t\n\t/**\n\t * Gets all the messages for a certain user MID sorted by name descending.\n\t * @param mid The MID of the user to be looked up.\n\t * @return A java.util.List of MessageBeans.\n\t * @throws SQLException\n\t */\n\tpublic List<MessageBean> getMessagesNameDescending(long mid) throws SQLException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs;\n\n\t\tconn = factory.getConnection();\n\t\tif(mid >= (long) 999999999){\n\t\t\tps = conn.prepareStatement(\"SELECT message.* FROM message, patients WHERE message.from_id=patients.mid AND message.to_id=? ORDER BY patients.lastName DESC, patients.firstName DESC, message.sent_date DESC\");\n\t\t\tps.setLong(1, mid);\n\t\t\trs = ps.executeQuery();\n\t\t}\n\t\telse{\n\t\t\tps = conn.prepareStatement(\"SELECT message.* FROM message, personnel WHERE message.from_id=personnel.mid AND message.to_id=? ORDER BY personnel.lastName DESC, personnel.firstName DESC, message.sent_date DESC\");\n\t\t\tps.setLong(1, mid);\n\t\t\trs = ps.executeQuery();\n\t\t}\n\n\t\tList<MessageBean> mbList = this.mbLoader.loadList(rs);\n\n\t\tDBUtil.closeConnection(conn, ps);\n\n\t\treturn mbList;\n\t}\n\t\n\t/**\n\t * Gets all the messages from a certain user MID.\n\t * @param mid The MID of the user to be looked up.\n\t * @return A java.util.List of MessageBeans.\n\t * @throws SQLException\n\t */\n\t\n\tpublic List<MessageBean> getMessagesFrom(long mid) throws SQLException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\n\t\tconn = factory.getConnection();\n\t\tps = conn.prepareStatement(\"SELECT * FROM message WHERE from_id = ? ORDER BY sent_date DESC\");\n\t\tps.setLong(1, mid);\n\t\tResultSet rs = ps.executeQuery();\n\n\t\tList<MessageBean> mbList = this.mbLoader.loadList(rs);\n\n\t\tDBUtil.closeConnection(conn, ps);\n\n\t\treturn mbList;\n\t}\n\t\n\t/**\n\t * Gets all the messages for a certain user MID sorted by ascending time.\n\t * @param mid The MID of the user to be looked up.\n\t * @return A java.util.List of MessageBeans.\n\t * @throws SQLException\n\t */\n\tpublic List<MessageBean> getMessagesFromTimeAscending(long mid) throws SQLException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\n\t\tconn = factory.getConnection();\n\t\tps = conn.prepareStatement(\"SELECT * FROM message WHERE from_id = ? ORDER BY sent_date ASC\");\n\t\tps.setLong(1, mid);\n\t\tResultSet rs = ps.executeQuery();\n\n\t\tList<MessageBean> mbList = this.mbLoader.loadList(rs);\n\n\t\tDBUtil.closeConnection(conn, ps);\n\n\t\treturn mbList;\n\t}\n\t\n\t/**\n\t * Gets all the messages for a certain user MID sorted by name ascending.\n\t * @param mid The MID of the user to be looked up.\n\t * @return A java.util.List of MessageBeans.\n\t * @throws SQLException\n\t */\n\tpublic List<MessageBean> getMessagesFromNameAscending(long mid) throws SQLException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs;\n\n\t\tconn = factory.getConnection();\n\t\tif(mid >= (long) 999999999){\n\t\t\tps = conn.prepareStatement(\"SELECT message.* FROM message, patients WHERE message.to_id=patients.mid AND message.from_id=? ORDER BY patients.lastName ASC, patients.firstName ASC, message.sent_date ASC\");\n\t\t\tps.setLong(1, mid);\n\t\t\trs = ps.executeQuery();\n\t\t}\n\t\telse{\n\t\t\tps = conn.prepareStatement(\"SELECT message.* FROM message, personnel WHERE message.to_id=personnel.mid AND message.from_id=? ORDER BY personnel.lastName ASC, personnel.firstName ASC, message.sent_date ASC\");\n\t\t\tps.setLong(1, mid);\n\t\t\trs = ps.executeQuery();\n\t\t}\n\n\t\tList<MessageBean> mbList = this.mbLoader.loadList(rs);\n\n\t\tDBUtil.closeConnection(conn, ps);\n\n\t\treturn mbList;\n\t}\n\t\n\t/**\n\t * Gets all the messages for a certain user MID sorted by name descending.\n\t * @param mid The MID of the user to be looked up.\n\t * @return A java.util.List of MessageBeans.\n\t * @throws SQLException\n\t */\n\tpublic List<MessageBean> getMessagesFromNameDescending(long mid) throws SQLException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs;\n\n\t\tconn = factory.getConnection();\n\t\tif(mid >= (long) 999999999){\n\t\t\tps = conn.prepareStatement(\"SELECT message.* FROM message, patients WHERE message.to_id=patients.mid AND message.from_id=? ORDER BY patients.lastName DESC, patients.firstName DESC, message.sent_date DESC\");\n\t\t\tps.setLong(1, mid);\n\t\t\trs = ps.executeQuery();\n\t\t}\n\t\telse{\n\t\t\tps = conn.prepareStatement(\"SELECT message.* FROM message, personnel WHERE message.to_id=personnel.mid AND message.from_id=? ORDER BY personnel.lastName DESC, personnel.firstName DESC, message.sent_date DESC\");\n\t\t\tps.setLong(1, mid);\n\t\t\trs = ps.executeQuery();\n\t\t}\n\n\t\tList<MessageBean> mbList = this.mbLoader.loadList(rs);\n\n\t\tDBUtil.closeConnection(conn, ps);\n\n\t\treturn mbList;\n\t}\n\n\t/**\n\t * Adds a message to the database.\n\t * @param mBean A bean representing the message to be added.\n\t * @throws SQLException\n\t */\n\tpublic void addMessage(MessageBean mBean) throws SQLException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\n\t\tconn = factory.getConnection();\n\t\tif (mBean.getParentMessageId() == 0L) {\n\t\t\tps = conn.prepareStatement(\n\t\t\t\t\t\"INSERT INTO message (from_id, to_id, sent_date, message, subject, been_read) \"\n\t\t\t\t  + \"VALUES (?, ?, NOW(), ?, ?, ?)\");\n\t\t\tthis.mbLoader.loadParameters(ps, mBean);\n\t\t} else {\n\t\t\tps = conn.prepareStatement(\n\t\t\t\t\t\"INSERT INTO message (from_id, to_id, sent_date, message, subject, been_read, parent_msg_id) \"\n\t\t\t\t  + \"  VALUES (?, ?, NOW(), ?, ?, ?, ?)\");\n\t\t\tthis.mbLoader.loadParameters(ps, mBean);\n\t\t}\n\n\t\tps.executeUpdate();\n\n\t\tDBUtil.closeConnection(conn, ps);\n\t}\n\t\n\tpublic void updateRead(MessageBean mBean) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"UPDATE message SET been_read=1 WHERE message_id=?\");\n\t\t\tps.setLong(1, mBean.getMessageId());\n\t\t\tps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n}", "NDCodesDAO.java": "package edu.ncsu.csc.itrust.dao.mysql;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.DBUtil;\nimport edu.ncsu.csc.itrust.beans.MedicationBean;\nimport edu.ncsu.csc.itrust.beans.loaders.MedicationBeanLoader;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\n\n/**\n * Used for managing the ND Codes.\n * \n * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,\n * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are\n * added. DAOs can assume that all data has been validated and is correct.\n * \n * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be\n * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC\n * connections and/or accessing other DAOs.\n * \n * The National Drug Code (NDC) is a universal product identifier used in the\n * United States for drugs intended for human use.\n * \n * @see http://www.fda.gov/Drugs/InformationOnDrugs/ucm142438.htm\n * @author Andy\n * \n */\npublic class NDCodesDAO {\n\tprivate DAOFactory factory;\n\tprivate MedicationBeanLoader medicationLoader = new MedicationBeanLoader();\n\n\t/**\n\t * The typical constructor.\n\t * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.\n\t */\n\tpublic NDCodesDAO(DAOFactory factory) {\n\t\tthis.factory = factory;\n\t}\n\n\t/**\n\t * Returns a list of all ND codes\n\t * \n\t * @return A java.util.List of MedicationBeans.\n\t * @throws DBException\n\t */\n\tpublic List<MedicationBean> getAllNDCodes() throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM NDCodes ORDER BY CODE\");\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn medicationLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Returns a particular description for a given code.\n\t * \n\t * @param code The ND code to be looked up.\n\t * @return A bean representing the Medication that was looked up.\n\t * @throws DBException\n\t */\n\tpublic MedicationBean getNDCode(String code) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM NDCodes WHERE Code = ?\");\n\t\t\tps.setString(1, code);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\tif (rs.next())\n\t\t\t\treturn medicationLoader.loadSingle(rs);\n\t\t\treturn null;\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Adds a new ND code, returns whether or not the change was made. If the code already exists, an\n\t * iTrustException is thrown.\n\t * \n\t * @param med The medication bean to be added.\n\t * @return A boolean indicating success or failure.\n\t * @throws DBException\n\t * @throws iTrustException\n\t */\n\tpublic boolean addNDCode(MedicationBean med) throws DBException, iTrustException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"INSERT INTO NDCodes (Code, Description) \" + \"VALUES (?,?)\");\n\t\t\tps.setString(1, med.getNDCode());\n\t\t\tps.setString(2, med.getDescription());\n\t\t\treturn (1 == ps.executeUpdate());\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tif (1062 == e.getErrorCode())\n\t\t\t\tthrow new iTrustException(\"Error: Code already exists.\");\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Updates a particular code's description\n\t * \n\t * @param med A bean representing the particular medication to be updated.\n\t * @return An int representing the number of updated rows.\n\t * @throws DBException\n\t */\n\tpublic int updateCode(MedicationBean med) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"UPDATE NDCodes SET Description = ? \" + \"WHERE Code = ?\");\n\t\t\tps.setString(1, med.getDescription());\n\t\t\tps.setString(2, med.getNDCode());\n\t\t\treturn ps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n}", "OfficeVisitDAO.java": "package edu.ncsu.csc.itrust.dao.mysql;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.ArrayList;\nimport edu.ncsu.csc.itrust.DBUtil;\nimport edu.ncsu.csc.itrust.beans.DiagnosisBean;\nimport edu.ncsu.csc.itrust.beans.LabProcedureBean;\nimport edu.ncsu.csc.itrust.beans.OfficeVisitBean;\nimport edu.ncsu.csc.itrust.beans.PrescriptionBean;\nimport edu.ncsu.csc.itrust.beans.PrescriptionReportBean;\nimport edu.ncsu.csc.itrust.beans.ProcedureBean;\nimport edu.ncsu.csc.itrust.beans.loaders.DiagnosisBeanLoader;\nimport edu.ncsu.csc.itrust.beans.loaders.OfficeVisitLoader;\nimport edu.ncsu.csc.itrust.beans.loaders.PrescriptionBeanLoader;\nimport edu.ncsu.csc.itrust.beans.loaders.PrescriptionReportBeanLoader;\nimport edu.ncsu.csc.itrust.beans.loaders.ProcedureBeanLoader;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\n\n/**\n * Used for doing tasks related to office visits. Use this for linking diagnoses to office visits, and similar\n * tasks.\n * \n * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,\n * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are\n * added. DAOs can assume that all data has been validated and is correct.\n * \n * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be\n * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC\n * connections and/or accessing other DAOs.\n * \n * @author Andy\n * \n */\npublic class OfficeVisitDAO {\n\tprivate DAOFactory factory;\n\tprivate OfficeVisitLoader officeVisitLoader = new OfficeVisitLoader();\n\tprivate DiagnosisBeanLoader diagnosisLoader = new DiagnosisBeanLoader(true);\n\tprivate PrescriptionBeanLoader prescriptionLoader = new PrescriptionBeanLoader();\n\tprivate PrescriptionReportBeanLoader prescriptionReportBeanLoader = new PrescriptionReportBeanLoader();\n\tprivate ProcedureBeanLoader procedureBeanLoader = new ProcedureBeanLoader(true);\n\n\t/**\n\t * The typical constructor.\n\t * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.\n\t */\n\tpublic OfficeVisitDAO(DAOFactory factory) {\n\t\tthis.factory = factory;\n\t}\n\n\t/**\n\t * Adds an visit and return its ID\n\t * \n\t * @param ov The OfficeVisitBean to be added.\n\t * @return A long indicating the unique ID for the office visit.\n\t * @throws DBException\n\t */\n\tpublic long add(OfficeVisitBean ov) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn\n\t\t\t\t\t.prepareStatement(\"INSERT INTO OfficeVisits (VisitDate, Notes, HCPID, PatientID, HospitalID) VALUES (?,?,?,?,?)\");\n\t\t\tsetValues(ps, ov);\n\t\t\tps.executeUpdate();\n\t\t\treturn DBUtil.getLastInsert(conn);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\tprivate void setValues(PreparedStatement ps, OfficeVisitBean ov) throws SQLException {\n\t\tps.setDate(1, new java.sql.Date(ov.getVisitDate().getTime()));\n\t\tps.setString(2, ov.getNotes());\n\t\tps.setLong(3, ov.getHcpID());\n\t\tps.setLong(4, ov.getPatientID());\n\t\tps.setString(5, ov.getHospitalID());\n\t}\n\n\t/**\n\t * Updates the information in a particular office visit.\n\t * \n\t * @param ov The Office Visit bean representing the changes.\n\t * @throws DBException\n\t */\n\tpublic void update(OfficeVisitBean ov) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"UPDATE OfficeVisits SET VisitDate=?, Notes=?, HCPID=?, \"\n\t\t\t\t\t+ \"PatientID=?, HospitalID=? WHERE ID=?\");\n\t\t\tsetValues(ps, ov);\n\t\t\tps.setLong(6, ov.getID());\n\t\t\tps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Returns a particular office visit given an ID\n\t * \n\t * @param visitID The unique ID of the office visit.\n\t * @return An OfficeVisitBean with the specifics for that office visit.\n\t * @throws DBException\n\t */\n\tpublic OfficeVisitBean getOfficeVisit(long visitID) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"Select * From OfficeVisits Where ID = ?\");\n\t\t\tps.setLong(1, visitID);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\tif (rs.next())\n\t\t\t\treturn loadFullOfficeVist(rs, visitID);\n\t\t\telse\n\t\t\t\treturn null;\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\tprivate OfficeVisitBean loadFullOfficeVist(ResultSet rs, long visitID) throws SQLException, DBException {\n\t\tOfficeVisitBean ov = new OfficeVisitBean(visitID);\n\t\tov.setVisitDateStr(new SimpleDateFormat(\"MM/dd/yyyy\").format(new Date(rs.getDate(\"VisitDate\")\n\t\t\t\t.getTime())));\n\t\tov.setHcpID(rs.getLong(\"HCPID\"));\n\t\tov.setNotes(rs.getString(\"notes\"));\n\t\tov.setPatientID(rs.getLong(\"PatientID\"));\n\t\tov.setHospitalID(rs.getString(\"HospitalID\"));\n\t\tov.setDiagnoses(getDiagnoses(visitID));\n\t\tov.setPrescriptions(getPrescriptions(visitID));\n\t\tov.setProcedures(getProcedures(visitID));\n\n\t\treturn ov;\n\t}\n\n\t/**\n\t * Returns all of the procedures associated with the given office visit\n\t * \n\t * @param visitID The unique ID of the office visit.\n\t * @return A java.util.List of procedures.\n\t * @throws DBException\n\t */\n\tpublic List<ProcedureBean> getProcedures(long visitID) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\tList<ProcedureBean> procs;\n\t\t\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"select * from ovprocedure ovp, officevisits ov, cptcodes cpt where ov.id=? and ovp.visitid=? and cpt.code=ovp.cptcode\");\n\t\t\tps.setLong(1, visitID);\n\t\t\tps.setLong(2, visitID);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\tprocs = procedureBeanLoader.loadList(rs);\n\t\t} \n\t\tcatch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} \n\t\tfinally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t\t\n\t\treturn procs;\n\t}\n\n\t\n\t/**\n\t * Returns all of the prescriptions associated with the given office visit\n\t * \n\t * @param visitID The ID of the office visit.\n\t * @return A java.util.List of prescriptions.\n\t * @throws DBException\n\t */\n\tpublic List<PrescriptionBean> getPrescriptions(long visitID) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"Select * From OVMedication,NDCodes Where OVMedication.VisitID = ? \"\n\t\t\t\t\t+ \"AND NDCodes.Code=OVMedication.NDCode\");\n\t\t\tps.setLong(1, visitID);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn prescriptionLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Returns all of the diagnoses associated with the given office visit\n\t * \n\t * @param visitID The unique ID of the office visit.\n\t * @return A java.util.List of diagnoses.\n\t * @throws DBException\n\t */\n\tpublic List<DiagnosisBean> getDiagnoses(long visitID) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"Select * From OVDiagnosis,ICDCodes Where OVDiagnosis.VisitID = ? \"\n\t\t\t\t\t+ \"AND ICDCodes.Code=OVDiagnosis.ICDCode\");\n\t\t\tps.setLong(1, visitID);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn diagnosisLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Adds the given CPT codes to the given office visit\n\t * \n\t * @param cptCode\n\t * @param visitID\n\t * @return\n\t * @throws DBException\n\t */\n\tpublic long addProcedureToOfficeVisit (String cptCode, long visitID, String hcpid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"INSERT INTO OVProcedure (CPTCode,VisitID,HCPID) VALUES (?,?,?)\");\n\t\t\tps.setString(1, cptCode);\n\t\t\tps.setLong(2, visitID);\n\t\t\tps.setString(3, hcpid);\n\t\t\tps.executeUpdate();\n\t\t\treturn DBUtil.getLastInsert(conn);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Removes the given procedure from its office visit\n\t * \n\t * @param ovProcedureID The unique ID of the office visit procedure.\n\t * @throws DBException\n\t */\n\tpublic void removeProcedureFromOfficeVisit(long ovProcedureID) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"DELETE FROM OVProcedure WHERE ID=? \");\n\t\t\tps.setLong(1, ovProcedureID);\n\t\t\tps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Adds a prescription bean to the database.\n\t * @param pres The prescription bean to be added.\n\t * @return The unique ID of the newly added bean.\n\t * @throws DBException\n\t */\n\tpublic long addPrescription(PrescriptionBean pres) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn\n\t\t\t\t\t.prepareStatement(\"INSERT INTO OVMedication (VisitID,NDCode,StartDate,EndDate,Dosage,Instructions) VALUES (?,?,?,?,?,?)\");\n\t\t\tprescriptionLoader.loadParameters(ps, pres);\n\t\t\tps.executeUpdate();\n\t\t\treturn DBUtil.getLastInsert(conn);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t * Edits an existing prescription bean.\n\t * \n\t * @param pres The newly updated prescription bean.\n\t * @return A long indicating the ID of the newly updated prescription bean.\n\t * @throws DBException\n\t */\n\tpublic long editPrescription(PrescriptionBean pres) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\t//ps = conn.prepareStatement(\"UPDATE OVMedication (VisitID,NDCode,StartDate,EndDate,Dosage,Instructions) VALUES (?,?,?,?,?,?)\");\n\t\t\tString statement = \"UPDATE OVMedication \" +\n\t\t\t\t\"SET VisitID=?, NDCode=?, StartDate=?, EndDate=?, Dosage=?, Instructions=? \" +\n\t\t\t\t\"WHERE ID=?\";\n\t\t\tps = conn.prepareStatement(statement);\n\t\t\tprescriptionLoader.loadParameters(ps, pres);\n\t\t\tps.setLong(7, pres.getId());\n\t\t\tps.executeUpdate();\n\t\t\treturn DBUtil.getLastInsert(conn);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Removes the given medication from its office visit\n\t * \n\t * @param ovMedicationID The unique ID of the medication to be removed.\n\t * @throws DBException\n\t */\n\tpublic void removePrescription(long ovMedicationID) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"DELETE FROM OVMedication WHERE ID=? \");\n\t\t\tps.setLong(1, ovMedicationID);\n\t\t\tps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Adds the given CPT codes to the given office visit\n\t * @param icd A double representing the ICD code to be added.\n\t * @param visitID The ID of the office visit we are adding the code to.\n\t * @return A long for the new ICD code's ID.\n\t * @throws DBException\n\t */\n\tpublic long addDiagnosisToOfficeVisit(double icd, long visitID) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"INSERT INTO OVDiagnosis (ICDCode,VisitID) VALUES (?,?)\");\n\t\t\tps.setDouble(1, icd);\n\t\t\tps.setLong(2, visitID);\n\t\t\tps.executeUpdate();\n\t\t\treturn DBUtil.getLastInsert(conn);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\n\t/**\n\t * Removes a particular diagnosis from its office visit\n\t * \n\t * @param ovDiagnosisID The ID for the office visit diagnosis to be removed. \n\t * @throws DBException\n\t */\n\tpublic void removeDiagnosisFromOfficeVisit(long ovDiagnosisID) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"DELETE FROM OVDiagnosis WHERE ID=? \");\n\t\t\tps.setLong(1, ovDiagnosisID);\n\t\t\tps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * Adds a LOINCCode to an office visit.\n\t * \n\t * @param LOINCCode A string of the code being added.\n\t * @param visitID The ID of the office visit the code is being added to.\n\t * @param pid The patient's MID associated with this transaction.\n\t * @return The unique ID of the code that was added.\n\t * @throws DBException\n\t */\n\tpublic long addLabProcedureToOfficeVisit(String LOINCCode, long visitID, long pid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"INSERT INTO LabProcedure (LaboratoryProcedureCode,OfficeVisitID,\" +\n\t\t\t\t\t\"Commentary, Results, PatientMID, Status, Rights) VALUES (?,?,?,?,?,?,?)\");\n\t\t\tps.setString(1, LOINCCode);\n\t\t\tps.setLong(2, visitID);\n\t\t\tps.setString(3, \"\");\n\t\t\tps.setString(4, \"\");\n\t\t\tps.setLong(5, pid);\n\t\t\tps.setString(6, LabProcedureBean.Not_Received);\n\t\t\tps.setString(7, \"ALLOWED\");\n\t\t\tps.executeUpdate();\n\t\t\treturn DBUtil.getLastInsert(conn);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Removes a given lab procedure.\n\t * \n\t * @param labProcedureID The unique ID of the lab procedure.\n\t * @throws DBException\n\t */\n\tpublic void removeLabProcedureFromOfficeVisit(long labProcedureID) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"DELETE FROM LabProcedure WHERE LaboratoryProcedureID=?\");\n\t\t\tps.setLong(1, labProcedureID);\n\t\t\tps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * Returns whether or not an office visit actually exists\n\t * \n\t * @param ovID The ID of the office visit to be checked.\n\t * @param pid The MID of the patient associated with this transaction.\n\t * @return A boolean indicating its existence.\n\t * @throws DBException\n\t */\n\tpublic boolean checkOfficeVisitExists(long ovID, long pid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM OfficeVisits WHERE ID=? AND PatientID=?\");\n\t\t\tps.setLong(1, ovID);\n\t\t\tps.setLong(2, pid);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn rs.next();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Returns a list of all office visits for a given patient\n\t * \n\t * @param pid The MID of the patient in question.\n\t * @return A java.util.List of OfficeVisitBeans.\n\t * @throws DBException\n\t */\n\tpublic List<OfficeVisitBean> getAllOfficeVisits(long pid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn\n\t\t\t\t\t.prepareStatement(\"SELECT * FROM OfficeVisits WHERE PatientID=? ORDER BY VisitDate DESC\");\n\t\t\tps.setLong(1, pid);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn officeVisitLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * Returns a list of all office visits for a given patient\n\t * \n\t * @param mid The MID of the LHCP you are looking up.\n\t * @return A java.util.List of Office Visits.\n\t * @throws DBException\n\t */\n\tpublic List<OfficeVisitBean> getAllOfficeVisitsForLHCP(long mid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tif (mid == 0L) throw new SQLException(\"HCPID cannot be null\");\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn\n\t\t\t\t\t.prepareStatement(\"SELECT * FROM OfficeVisits WHERE HCPID=? ORDER BY VisitDate DESC\");\n\t\t\tps.setLong(1, mid);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn officeVisitLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Returns a list of all office visits for a given patient\n\t * \n\t * @param pid The MID of the patient.\n\t * @return A java.util.List of Office Visits.\n\t * @throws DBException\n\t */\n\tpublic List<OfficeVisitBean> getOfficeVisitsWithNoSurvey(long pid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn\n\t\t\t\t\t.prepareStatement(\"SELECT * FROM OfficeVisits where id not in (select visitid from OVSurvey) and PatientID = ? ORDER BY VisitDate DESC\");\n\t\t\tps.setLong(1, pid);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn officeVisitLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Returns a list of information related to prescription reports given all of the office visits and the\n\t * patient ID. The patient ID is necessary in case the office visit IDs are for different patients (the\n\t * disambiguation is for security reasons).\n\t * \n\t * @param ovIDs A java.util.List of Longs for the office visits.\n\t * @param patientID A long representing the MID of the patient in question.\n\t * @return A java.util.List of prescription reports.\n\t * @throws DBException\n\t */\n\tpublic List<PrescriptionReportBean> getPrescriptionReportsByDate(long patientID, String startDate, String endDate)\n\t\t\tthrows DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM NDCodes, OVMedication, OfficeVisits \"\n\t\t\t\t\t+ \"WHERE NDCodes.Code=OVMedication.NDCode AND OVMedication.VisitID=OfficeVisits.ID \"\n\t\t\t\t\t+ \"AND PatientID=? AND ((DATE(?) < OVMedication.EndDate AND DATE(?) > OVMedication.StartDate)\"\n\t\t\t\t\t+ \"OR (DATE(?) > OVMedication.StartDate  AND DATE(?) < OVMedication.EndDate ) OR \"\n\t\t\t\t\t+ \"(DATE(?) <= OVMedication.StartDate AND DATE(?) >= OVMedication.StartDate)) \"\n\t\t\t\t\t+ \"ORDER BY VisitDate DESC\");\n\t\t\tps.setLong(1, patientID);\n\t\t\tps.setString(2, startDate);\n\t\t\tps.setString(3, startDate);\n\t\t\tps.setString(4, endDate);\n\t\t\tps.setString(5, endDate);\n\t\t\tps.setString(6, startDate);\n\t\t\tps.setString(7, endDate);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn prescriptionReportBeanLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Returns a list of information related to prescription reports given all of the office visits and the\n\t * patient ID. The patient ID is necessary in case the office visit IDs are for different patients (the\n\t * disambiguation is for security reasons).\n\t * \n\t * @param ovIDs A java.util.List of Longs for the office visits.\n\t * @param patientID A long representing the MID of the patient in question.\n\t * @return A java.util.List of prescription reports.\n\t * @throws DBException\n\t */\n\tpublic List<PrescriptionReportBean> getPrescriptionReports(List<Long> ovIDs, long patientID)\n\t\t\tthrows DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tString preps = buildPreps(ovIDs.size());\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM NDCodes, OVMedication, OfficeVisits \"\n\t\t\t\t\t+ \"WHERE NDCodes.Code=OVMedication.NDCode AND OVMedication.VisitID=OfficeVisits.ID \"\n\t\t\t\t\t+ \"AND PatientID=? AND VisitID IN(\" + preps + \") ORDER BY VisitDate DESC\");\n\t\t\tps.setLong(1, patientID);\n\t\t\tprepareOVIDs(ps, ovIDs);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn prescriptionReportBeanLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\tprivate void prepareOVIDs(PreparedStatement ps, List<Long> ovIDs) throws SQLException {\n\t\tfor (int i = 0; i < ovIDs.size(); i++) {\n\t\t\tps.setLong(i + 2, ovIDs.get(i));\n\t\t}\n\t}\n\n\tprivate String buildPreps(int size) {\n\t\tString prep = \"\";\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tprep += \"?,\";\n\t\t}\n\t\tif (prep.length() > 0)\n\t\t\treturn prep.substring(0, prep.length() - 1);\n\t\telse\n\t\t\treturn prep;\n\t}\n\t\n\t/**\n\t * Returns a list of all office visits at a given hospital\n\t * @param hospitalID the id of the hospital\n\t * @return a list of the OfficeVisitBeans that hold the office visits\n\t * @throws DBException in the event of a database error\n\t */\n\tpublic List<OfficeVisitBean> getOfficeVisitsFromHospital(String hospitalID) throws DBException{\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM officevisits WHERE hospitalID = ? ORDER BY ID DESC\");\n\t\t\tps.setString(1, hospitalID);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn officeVisitLoader.loadList(rs);\n\t\t} catch (SQLException e){\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t\t\n\t}\n\t\n\t/**\n\t * Gets all office visits corresponding to a particular ICD diagnosis.\n\t * \n\t * @param icdcode A string represnting the ICD diagnosis to look up.\n\t * @return A java.util.List of Office visits.\n\t * @throws DBException\n\t */\n\tpublic List<OfficeVisitBean> getAllOfficeVisitsForDiagnosis(String icdcode) throws DBException {\n\t\t\n\t\tList<DiagnosisBean> diags = null;\n\t\tList<OfficeVisitBean> ovs = new ArrayList<OfficeVisitBean>();\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs= null;\n\t\t\n\t\ttry {\n\t\t\tif (icdcode == null) \n\t\t\t\tthrow new SQLException(\"icdcode cannot be null\");\n\t\t\t\n\t\t\tconn = factory.getConnection();\n\t\t\t\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM ovdiagnosis ovd, icdcodes icd WHERE ovd.ICDCode=? and icd.Code=?\");\n\t\t\tps.setString(1, icdcode);\n\t\t\tps.setString(2, icdcode);\n\t\t\trs = ps.executeQuery();\n\t\t\tdiags = diagnosisLoader.loadList(rs);\n\t\t\trs.close();\n\t\t\tps.close();\n\t\t\tps = null;\n\t\t\trs = null;\n\t\t\t\n\t\t\tfor (DiagnosisBean bean: diags) {\n\t\t\t\tps = conn.prepareStatement(\"SELECT * FROM officevisits ov WHERE ov.ID=?\");\n\t\t\t\tps.setInt(1, (int)bean.getVisitID());\n\t\t\t\trs = ps.executeQuery();\n\t\t\t\t\n\t\t\t\tif (rs.next()) {\n\t\t\t\t\tovs.add(loadFullOfficeVist(rs, bean.getVisitID()));\n\t\t\t\t}\n\t\t\t\trs.close();\n\t\t\t\tps.close();\n\t\t\t}\n\t\t\t\n\t\t\treturn ovs;\n\t\t\n\t\t}\n\t\tcatch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\t\n}", "PatientDAO.java": "package edu.ncsu.csc.itrust.dao.mysql;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.List;\nimport java.util.Vector;\nimport edu.ncsu.csc.itrust.DBUtil;\nimport edu.ncsu.csc.itrust.beans.DiagnosisBean;\nimport edu.ncsu.csc.itrust.beans.PatientBean;\nimport edu.ncsu.csc.itrust.beans.PersonnelBean;\nimport edu.ncsu.csc.itrust.beans.PrescriptionBean;\nimport edu.ncsu.csc.itrust.beans.ProcedureBean;\nimport edu.ncsu.csc.itrust.beans.loaders.DiagnosisBeanLoader;\nimport edu.ncsu.csc.itrust.beans.loaders.PatientLoader;\nimport edu.ncsu.csc.itrust.beans.loaders.PersonnelLoader;\nimport edu.ncsu.csc.itrust.beans.loaders.PrescriptionBeanLoader;\nimport edu.ncsu.csc.itrust.beans.loaders.ProcedureBeanLoader;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\nimport edu.ncsu.csc.itrust.DateUtil;\n\n/**\n * Used for managing all static information related to a patient. For other information related to all aspects\n * of patient care, see the other DAOs.\n * \n * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,\n * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are\n * added. DAOs can assume that all data has been validated and is correct.\n * \n * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be\n * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC\n * connections and/or accessing other DAOs.\n * \n * @author Andy\n * \n */\npublic class PatientDAO {\n\tprivate DAOFactory factory;\n\tprivate PatientLoader patientLoader;\n\tprivate PersonnelLoader personnelLoader;\n\tprivate DiagnosisBeanLoader diagnosisLoader;\n\tprivate PrescriptionBeanLoader prescriptionLoader;\n\tprivate ProcedureBeanLoader procedureLoader;\n\n\t/**\n\t * The typical constructor.\n\t * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.\n\t */\n\tpublic PatientDAO(DAOFactory factory) {\n\t\tthis.factory = factory;\n\t\tthis.patientLoader = new PatientLoader();\n\t\tthis.personnelLoader = new PersonnelLoader();\n\t\tthis.diagnosisLoader = new DiagnosisBeanLoader(true);\n\t\tthis.prescriptionLoader = new PrescriptionBeanLoader();\n\t\tthis.procedureLoader = new ProcedureBeanLoader(true);\n\t}\n\n\t/**\n\t * Returns the name for the given MID\n\t * \n\t * @param mid The MID of the patient in question.\n\t * @return A String representing the patient's first name and last name.\n\t * @throws iTrustException\n\t * @throws DBException\n\t */\n\tpublic String getName(long mid) throws iTrustException, DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT firstName, lastName FROM Patients WHERE MID=?\");\n\t\t\tps.setLong(1, mid);\n\t\t\tResultSet rs;\n\t\t\trs = ps.executeQuery();\n\t\t\tif (rs.next()) {\n\t\t\t\treturn rs.getString(\"firstName\") + \" \" + rs.getString(\"lastName\");\n\t\t\t} else {\n\t\t\t\tthrow new iTrustException(\"User does not exist\");\n\t\t\t}\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the role of a particular patient - why is this in PatientDAO? It should be in AuthDAO\n\t * \n\t * @param mid The MID of the patient in question.\n\t * @param role A String representing the role of the patient.\n\t * @return A String representing the patient's role.\n\t * @throws iTrustException\n\t * @throws DBException\n\t */\n\tpublic String getRole(long mid, String role) throws iTrustException, DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT role FROM Users WHERE MID=? AND Role=?\");\n\t\t\tps.setLong(1, mid);\n\t\t\tps.setString(2, role);\n\t\t\tResultSet rs;\n\t\t\trs = ps.executeQuery();\n\t\t\tif (rs.next()) {\n\t\t\t\treturn rs.getString(\"role\");\n\t\t\t} else {\n\t\t\t\tthrow new iTrustException(\"User does not exist with the designated role\");\n\t\t\t}\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Adds an empty patient to the table, returns the new MID\n\t * \n\t * @return The MID of the patient as a long.\n\t * @throws DBException\n\t */\n\tpublic long addEmptyPatient() throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"INSERT INTO Patients(MID) VALUES(NULL)\");\n\t\t\tps.executeUpdate();\n\t\t\treturn DBUtil.getLastInsert(conn);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the patient's information for a given ID\n\t * \n\t * @param mid The MID of the patient to retrieve.\n\t * @return A PatientBean representing the patient.\n\t * @throws DBException\n\t */\n\tpublic PatientBean getPatient(long mid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM Patients WHERE MID = ?\");\n\t\t\tps.setLong(1, mid);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\t// pdao.logTransaction(type, loggedInMID, secondaryMID, addedInfo)\n\t\t\tif (rs.next()) {\n\t\t\t\treturn patientLoader.loadSingle(rs);\n\t\t\t} else\n\t\t\t\treturn null;\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Updates a patient's information for the given MID\n\t * \n\t * @param p The patient bean representing the new information for the patient.\n\t * @throws DBException\n\t */\n\tpublic void editPatient(PatientBean p) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"UPDATE Patients SET firstName=?,lastName=?,email=?,\"\n\t\t\t\t\t+ \"address1=?,address2=?,city=?,state=?,zip1=?, zip2=?,phone1=?,phone2=?,phone3=?,\"\n\t\t\t\t\t+ \"eName=?,ePhone1=?,ePhone2=?,ePhone3=?,iCName=?,iCAddress1=?,iCAddress2=?,iCCity=?,\"\n\t\t\t\t\t+ \"ICState=?,iCZip1=?, iCZip2=?, iCPhone1=?,iCPhone2=?,iCPhone3=?,iCID=?,DateOfBirth=?,\"\n\t\t\t\t\t+ \"DateOfDeath=?,CauseOfDeath=?,MotherMID=?,FatherMID=?,\"\n\t\t\t\t\t+ \"BloodType=?,Ethnicity=?,Gender=?,TopicalNotes=?, CreditCardType=?, CreditCardNumber=?, MessageFilter=? WHERE MID=?\");\n\t\t\tpatientLoader.loadParameters(ps, p);\n\t\t\tps.setLong(40, p.getMID());\n\t\t\tps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Returns whether or not the patient exists\n\t * \n\t * @param pid The MID of the patient in question.\n\t * @return A boolean indicating whether the patient exists.\n\t * @throws DBException\n\t */\n\tpublic boolean checkPatientExists(long pid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM Patients WHERE MID=?\");\n\t\t\tps.setLong(1, pid);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn rs.next();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Returns a list of HCPs who are declared by the given patient\n\t * \n\t * @param pid The MID of the patient in question.\n\t * @return A java.util.List of Personnel Beans.\n\t * @throws DBException\n\t */\n\tpublic List<PersonnelBean> getDeclaredHCPs(long pid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tif (pid == 0L) throw new SQLException(\"pid cannot be 0\");\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM DeclaredHCP, Personnel \"\n\t\t\t\t\t+ \"WHERE PatientID=? AND Personnel.MID=DeclaredHCP.HCPID\");\n\t\t\tps.setLong(1, pid);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn personnelLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Declares an HCP for a particular patient\n\t * \n\t * @param pid The MID of the patient in question.\n\t * @param hcpID The HCP's MID.\n\t * @return A boolean as to whether the insertion was successful.\n\t * @throws DBException\n\t * @throws iTrustException\n\t */\n\tpublic boolean declareHCP(long pid, long hcpID) throws DBException, iTrustException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"INSERT INTO DeclaredHCP(PatientID, HCPID) VALUES(?,?)\");\n\t\t\tps.setLong(1, pid);\n\t\t\tps.setLong(2, hcpID);\n\t\t\treturn 1 == ps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\tif (1062 == e.getErrorCode())\n\t\t\t\tthrow new iTrustException(\"HCP \" + hcpID + \" has already been declared for patient \" + pid);\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Undeclare an HCP for a given patient\n\t * \n\t * @param pid The MID of the patient in question.\n\t * @param hcpID The MID of the HCP in question.\n\t * @return A boolean indicating whether the action was successful.\n\t * @throws DBException\n\t */\n\tpublic boolean undeclareHCP(long pid, long hcpID) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"DELETE FROM DeclaredHCP WHERE PatientID=? AND HCPID=?\");\n\t\t\tps.setLong(1, pid);\n\t\t\tps.setLong(2, hcpID);\n\t\t\treturn 1 == ps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Check if a patient has declared the given HCP\n\t * \n\t * @param pid The MID of the patient in question as a long.\n\t * @param hcpid The MID of the HCP in question as a long.\n\t * @return\n\t * @throws DBException\n\t */\n\tpublic boolean checkDeclaredHCP(long pid, long hcpid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM DeclaredHCP WHERE PatientID=? AND HCPID=?\");\n\t\t\tps.setLong(1, pid);\n\t\t\tps.setLong(2, hcpid);\n\t\t\treturn ps.executeQuery().next();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Return a list of patients that the given patient represents\n\t * \n\t * @param pid The MID of the patient in question.\n\t * @return A java.util.List of PatientBeans\n\t * @throws DBException\n\t */\n\tpublic List<PatientBean> getRepresented(long pid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT Patients.* FROM Representatives, Patients \"\n\t\t\t\t\t+ \"WHERE RepresenterMID=? AND RepresenteeMID=Patients.MID\");\n\t\t\tps.setLong(1, pid);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn patientLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Return a list of patients that the given patient is represented by\n\t * \n\t * @param pid The MID of the patient in question.\n\t * @return A java.util.List of PatientBeans.\n\t * @throws DBException\n\t */\n\tpublic List<PatientBean> getRepresenting(long pid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT Patients.* FROM Representatives, Patients \"\n\t\t\t\t\t+ \"WHERE RepresenteeMID=? AND RepresenterMID=Patients.MID\");\n\t\t\tps.setLong(1, pid);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn patientLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Check if the given representer represents the representee\n\t * \n\t * @param representer The MID of the representer in question.\n\t * @param representee The MID of the representee in question.\n\t * @return A boolean indicating whether represenation is in place.\n\t * @throws DBException\n\t */\n\tpublic boolean represents(long representer, long representee) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn\n\t\t\t\t\t.prepareStatement(\"SELECT * FROM Representatives WHERE RepresenterMID=? AND RepresenteeMID=?\");\n\t\t\tps.setLong(1, representer);\n\t\t\tps.setLong(2, representee);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn rs.next();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Assign a representer to the representee\n\t * \n\t * @param representer The MID of the representer as a long.\n\t * @param representee The MID of the representee as a long.\n\t * @return A boolean as to whether the insertion was correct.\n\t * @throws DBException\n\t * @throws iTrustException\n\t */\n\tpublic boolean addRepresentative(long representer, long representee) throws DBException, iTrustException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn\n\t\t\t\t\t.prepareStatement(\"INSERT INTO Representatives(RepresenterMID,RepresenteeMID) VALUES (?,?)\");\n\t\t\tps.setLong(1, representer);\n\t\t\tps.setLong(2, representee);\n\t\t\treturn 1 == ps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\tif (1062 == e.getErrorCode())\n\t\t\t\tthrow new iTrustException(\"Patient \" + representer + \" already represents patient \"\n\t\t\t\t\t\t+ representee);\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Unassign the representation\n\t * \n\t * @param representer The MID of the representer in question.\n\t * @param representee The MID of the representee in question.\n\t * @return A boolean indicating whether the unassignment was sucessful.\n\t * @throws DBException\n\t */\n\tpublic boolean removeRepresentative(long representer, long representee) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn\n\t\t\t\t\t.prepareStatement(\"DELETE FROM Representatives WHERE RepresenterMID=? AND RepresenteeMID=?\");\n\t\t\tps.setLong(1, representer);\n\t\t\tps.setLong(2, representee);\n\t\t\treturn 1 == ps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Return a list of all diagnoses for a given patient\n\t * \n\t * @param pid The MID of the patient in question.\n\t * @return A java.util.List of Diagnoses.\n\t * @throws DBException\n\t */\n\tpublic List<DiagnosisBean> getDiagnoses(long pid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tif (pid == 0L) throw new SQLException(\"pid cannot be 0\");\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM OVDiagnosis ovd, OfficeVisits ov, ICDCodes icd \"\n\t\t\t\t\t+ \"WHERE ovd.VisitID=ov.ID and icd.Code=ovd.ICDCode and ov.PatientID=? \"\n\t\t\t\t\t+ \"ORDER BY ov.visitDate DESC\");\n\t\t\tps.setLong(1, pid);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn diagnosisLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n \n\t/**\n\t * Return a list of all procedures for a given patient\n\t * \n\t * @param pid The MID of the patient in question.\n\t * @return A java.util.List of all the procedures.\n\t * @throws DBException\n\t */\n\tpublic List<ProcedureBean> getProcedures(long pid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tif (pid == 0L) throw new SQLException(\"pid cannot be 0\");\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"Select * From OVProcedure ovp, OfficeVisits ov, CPTCodes cpt \"\n\t\t\t\t\t+ \"Where ovp.VisitID=ov.ID and cpt.code=ovp.cptcode and ov.patientID=? \"\n\t\t\t\t\t+ \"ORDER BY ov.visitDate desc\");\n\t\t\tps.setLong(1, pid);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn procedureLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Return a list of all immunization procedures for a given patient\n\t * \n\t * @param pid The MID of the patient in question.\n\t * @return A java.util.List of the procedures.\n\t * @throws DBException\n\t */\n\tpublic List<ProcedureBean> getImmunizationProcedures(long pid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tif (pid == 0L) throw new SQLException(\"pid cannot be 0\");\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"Select * From OVProcedure ovp, OfficeVisits ov, CPTCodes cpt \"\n\t\t\t\t\t+ \"Where ovp.VisitID=ov.ID and cpt.code=ovp.cptcode and ov.patientID=? and cpt.attribute='immunization'\"\n\t\t\t\t\t+ \"ORDER BY ov.visitDate desc\");\n\t\t\tps.setLong(1, pid);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn procedureLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t\n\t/**\n\t * Return a list of all prescriptions for a patient\n\t * \n\t * @param patientID The MID of the patient in question.\n\t * @return A java.util.List of prescriptions.\n\t * @throws DBException\n\t */\n\tpublic List<PrescriptionBean> getPrescriptions(long patientID) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tif (patientID == 0L) throw new SQLException(\"pid cannot be 0\");\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"Select * From OVMedication,NDCodes,OfficeVisits \"\n\t\t\t\t\t+ \"Where OfficeVisits.PatientID = ? AND OVMedication.VisitID = \"\n\t\t\t\t\t+ \"OfficeVisits.ID AND NDCodes.Code=OVMedication.NDCode \"\n\t\t\t\t\t+ \"ORDER BY OfficeVisits.visitDate DESC, OVMedication.NDCode ASC;\");\n\t\t\tps.setLong(1, patientID);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn prescriptionLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Return a list of prescriptions which are currently prescribed for a patient\n\t * \n\t * @param patientID The MID of the patient in question.\n\t * @return A java.util.List of prescription beans.\n\t * @throws DBException\n\t */\n\tpublic List<PrescriptionBean> getCurrentPrescriptions(long patientID) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tif (patientID == 0L) throw new SQLException(\"pid cannot be 0\");\n\t\t\tconn = factory.getConnection();\n\t\t\t\n\t\t\tps = conn.prepareStatement(\"Select * From OVMedication,NDCodes,OfficeVisits \"\n\t\t\t\t\t+ \"Where OfficeVisits.PatientID = ? AND OVMedication.VisitID = \"\n\t\t\t\t\t+ \"OfficeVisits.ID AND NDCodes.Code=OVMedication.NDCode AND \"\n\t\t\t\t\t+ \"OVMedication.EndDate >= ?\" + \"ORDER BY OVMedication.ID DESC;\");\n\t\t\tps.setLong(1, patientID);\n\t\t\tps.setDate(2, DateUtil.getSQLdateXDaysAgoFromNow(91));\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn prescriptionLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * Return a list of prescriptions which are expired prescription for a patient\n\t * \n\t * @param patientID The MID of the patient in question.\n\t * @return A java.util.List of prescriptions.\n\t * @throws DBException\n\t **/\n\t \n\tpublic List<PrescriptionBean> getExpiredPrescriptions (long patientID) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tif (patientID == 0L) throw new SQLException(\"pid cannot be 0\");\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"Select * From OVMedication,NDCodes,OfficeVisits \"\n\t\t\t\t\t+ \"Where OfficeVisits.PatientID = ? AND OVMedication.VisitID = \"\n\t\t\t\t\t+ \"OfficeVisits.ID AND NDCodes.Code=OVMedication.NDCode AND \"\n\t\t\t\t\t+ \"OVMedication.EndDate < ?\" + \"ORDER BY OVMedication.ID DESC;\");\n\t\t\tps.setLong(1, patientID);\n\t\t\tps.setDate(2, DateUtil.getSQLdateXDaysAgoFromNow(0));\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn prescriptionLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * Lists every patient in the database.\n\t * \n\t * @return A java.util.List of PatientBeans representing the patients.\n\t * @throws DBException\n\t */\n\tpublic List<PatientBean> getAllPatients() throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM patients \");\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn patientLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * Return a list of patients with a special-diagnosis-history who\n\t * have the logged in HCP as a DHCP and whose medications are going to\n\t * expire within seven days.\n\t * \n\t * @param hcpMID The MID of the logged in HCP\n\t * @return A list of patients satisfying the conditions.\n\t * @throws DBException\n\t */\n\tpublic List<PatientBean> getRenewalNeedsPatients(long hcpMID) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\t\n\t\t\t\t\n\t\t\t\tps = conn.prepareStatement(\"SELECT * FROM ( \" + \n\n\t\t\t\t\"SELECT DISTINCT patients.* From patients, declaredhcp, ovdiagnosis, officevisits, ovmedication \" + \n\t\t\t\t\"Where \" + \n\t\t\t\t\n\t\t\t\t\"declaredHCP.HCPID = ? AND \" + \n\t\t\t\t\"patients.MID = declaredhcp.PatientID AND \" + \n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\"( \" + \n\t\t\t\t\"ovdiagnosis.VisitID = officevisits.ID AND officevisits.PatientID = declaredhcp.PatientID \" + \n\t\t\t\t\"AND \" + \n\t\t\t\t\n\t\t\t\t\"((ovdiagnosis.ICDCode >= ? AND ovdiagnosis.ICDCode < ?) \" + \n\t\t\t\t\"OR (ovdiagnosis.ICDCode >= ? AND ovdiagnosis.ICDCode < ?) \" + \n\t\t\t\t\"OR (ovdiagnosis.ICDCode >= ? AND ovdiagnosis.ICDCode < ?)) \" + \n\t\t\t\t\") \" + \n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\"UNION ALL \" + \n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\"SELECT DISTINCT patients.* From patients, declaredhcp, ovdiagnosis, officevisits, ovmedication \" + \n\t\t\t\t\"Where \" + \n\t\t\t\t\n\t\t\t\t\"declaredHCP.HCPID = ? AND \" + \n\t\t\t\t\"patients.MID = declaredhcp.PatientID AND \" + \n\t\t\t\t\n\t\t\t\t\"( \" + \n\t\t\t\t\"declaredhcp.PatientID = officevisits.PatientID AND officevisits.ID = ovmedication.VisitID \" + \n\t\t\t\t\"AND \" + \n\t\t\t\t\"ovmedication.EndDate BETWEEN CURDATE() AND DATE_ADD(CURDATE(), INTERVAL 7 DAY) \" + \n\t\t\t\t\") \" + \n\t\t\t\t\n\t\t\t\t\") AS final \" + \n\t\t\t\t\n\t\t\t\t\"GROUP BY final.MID HAVING COUNT(*) = 2 \" + \n\t\t\t\t\n\t\t\t\t\"ORDER BY final.lastname ASC, final.firstname ASC\"); \n\t\t\t\n\t\t\tps.setLong(1, hcpMID);\n\t\t\t\n\t\t\tps.setFloat(2, 250.0f);\n\t\t\tps.setFloat(3, 251.0f);\n\t\t\t\t\n\t\t\tps.setFloat(4, 493.0f);\n\t\t\tps.setFloat(5, 494.0f);\n\t\t\t\n\t\t\tps.setFloat(6, 390.0f);\n\t\t\tps.setFloat(7, 460.99f);\n\n\t\t\tps.setLong(8, hcpMID);\n\t\t\t\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn patientLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * Returns all patients with names \"LIKE\" (as in SQL) the passed in parameters.\n\t * \n\t * @param first The patient's first name.\n\t * @param last The patient's last name.\n\t * @return A java.util.List of PatientBeans.\n\t * @throws DBException\n\t */\n\tpublic List<PatientBean> searchForPatientsWithName(String first, String last) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\t\n\t\tif (first.equals(\"%\") && last.equals(\"%\")) return new Vector<PatientBean>();\n\t\t\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\t\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM patients WHERE firstName LIKE ? AND lastName LIKE ?\");\n\t\t\tps.setString(1, first);\n\t\t\tps.setString(2, last);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn patientLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t\n}", "PersonnelDAO.java": "package edu.ncsu.csc.itrust.dao.mysql;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Vector;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.DBUtil;\nimport edu.ncsu.csc.itrust.beans.HospitalBean;\nimport edu.ncsu.csc.itrust.beans.PersonnelBean;\nimport edu.ncsu.csc.itrust.beans.PrescriptionBean;\nimport edu.ncsu.csc.itrust.beans.loaders.HospitalBeanLoader;\nimport edu.ncsu.csc.itrust.beans.loaders.PersonnelLoader;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\nimport edu.ncsu.csc.itrust.enums.Role;\n\n\n/**\n * Used for managing information related to personnel: HCPs, UAPs, Admins\n * \n * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,\n * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are\n * added. DAOs can assume that all data has been validated and is correct.\n * \n * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be\n * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC\n * connections and/or accessing other DAOs.\n * \n * @author Andy\n * \n */\npublic class PersonnelDAO {\n\tprivate DAOFactory factory;\n\tprivate PersonnelLoader personnelLoader;\n\tprivate HospitalBeanLoader hospitalBeanLoader;\n\n\t/**\n\t * The typical constructor.\n\t * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.\n\t */\n\tpublic PersonnelDAO(DAOFactory factory) {\n\t\tthis.factory = factory;\n\t\tpersonnelLoader = new PersonnelLoader();\n\t\thospitalBeanLoader = new HospitalBeanLoader();\n\t}\n\n\t/**\n\t * Returns the name for a given MID\n\t * \n\t * @param mid The MID of the personnel in question.\n\t * @return A String representing the name of the personnel.\n\t * @throws iTrustException\n\t * @throws DBException\n\t */\n\tpublic String getName(long mid) throws iTrustException, DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement pstmt = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tpstmt = conn.prepareStatement(\"SELECT firstName, lastName FROM Personnel WHERE MID=?\");\n\t\t\tpstmt.setLong(1, mid);\n\t\t\tResultSet rs;\n\n\t\t\trs = pstmt.executeQuery();\n\t\t\tif (rs.next()) {\n\t\t\t\treturn rs.getString(\"firstName\") + \" \" + rs.getString(\"lastName\");\n\t\t\t} else {\n\t\t\t\tthrow new iTrustException(\"User does not exist\");\n\t\t\t}\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, pstmt);\n\t\t}\n\t}\n\n\t/**\n\t * Adds an empty personnel, and returns the MID.\n\t * \n\t * @return A long indicating the new MID.\n\t * @param role A {@link Role} enum indicating the personnel's specific role.\n\t * @throws DBException\n\t * @throws iTrustException\n\t */\n\tpublic long addEmptyPersonnel(Role role) throws DBException, iTrustException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\tlong newID;\n\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"INSERT INTO Personnel(Role) VALUES(?)\");\n\t\t\tps.setString(1, role.name());\n\t\t\tps.executeUpdate();\n\t\t\tnewID = DBUtil.getLastInsert(conn);\n\t\t\treturn newID;\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Retrieves a PersonnelBean with all of the specific information for a given employee.\n\t * \n\t * @param mid The MID of the personnel in question.\n\t * @return A PersonnelBean representing the employee.\n\t * @throws DBException\n\t */\n\tpublic PersonnelBean getPersonnel(long mid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM Personnel WHERE MID = ?\");\n\t\t\tps.setLong(1, mid);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\tif (rs.next()) {\n\t\t\t\treturn personnelLoader.loadSingle(rs);\n\t\t\t} else\n\t\t\t\treturn null;\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Updates the demographics for a personnel.\n\t * \n\t * @param p The personnel bean with the updated information.\n\t * @throws DBException\n\t */\n\tpublic void editPersonnel(PersonnelBean p) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"UPDATE Personnel SET AMID=?,firstName=?,lastName=?,\"\n\t\t\t\t\t+ \"phone1=?,phone2=?,phone3=?, address1=?,address2=?,city=?, state=?, zip=?, zip1=?, zip2=?, email=?, MessageFilter=?\"\n\t\t\t\t\t+ \" WHERE MID=?\");\n\t\t\tpersonnelLoader.loadParameters(ps, p);\n\t\t\tps.setLong(16, p.getMID());\n\t\t\tps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Indicates whether a certain personnel is in the database.\n\t * \n\t * @param pid The MID of the personnel in question.\n\t * @return A boolean indicating whether this personnel exists.\n\t * @throws DBException\n\t */\n\tpublic boolean checkPersonnelExists(long pid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM Personnel WHERE MID=?\");\n\t\t\tps.setLong(1, pid);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn rs.next();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Returns all of the hospitals this LHCP is associated with.\n\t * \n\t * @param mid The MID of the personnel in question.\n\t * @return A java.util.List of HospitalBeans.\n\t * @throws DBException\n\t */\n\tpublic List<HospitalBean> getHospitals(long mid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM HCPAssignedHos hah,Hospitals h \"\n\t\t\t\t\t+ \"WHERE hah.HCPID=? AND hah.HosID=h.HospitalID ORDER BY HospitalName ASC\");\n\t\t\tps.setLong(1, mid);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn hospitalBeanLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t\n\t\n\t/**\n\t * Returns all personnel in the database.\n\t * \n\t * @return A java.util.List of personnel.\n\t * @throws DBException\n\t */\n\tpublic List<PersonnelBean> getAllPersonnel() throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM personnel where role in ('hcp','uap','er') \");\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn personnelLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Returns a list of UAPs who work for this LHCP.\n\t * \n\t * @param hcpid The MID of the personnel in question.\n\t * @return A java.util.List of UAPs.\n\t * @throws DBException\n\t */\n\tpublic List<PersonnelBean> getUAPsForHCP(long hcpid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM Personnel WHERE MID IN (SELECT UAP FROM HCPRelations WHERE HCP=?)\");\n\t\t\tps.setLong(1, hcpid);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn personnelLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * Given a prescription that has been given, this method returns all the information for the\n\t * doctor who authorized that prescription.\n\t * \n\t * @param prescription The PrescriptionBean describing the prescription in question.\n\t * @return The PersonnelBean describing the doctor who authorized it.\n\t * @throws DBException\n\t */\n\tpublic PersonnelBean getPrescribingDoctor(PrescriptionBean prescription) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM Personnel WHERE MID IN (SELECT HCPID FROM OfficeVisits WHERE ID=?)\");\n\t\t\tps.setLong(1, prescription.getVisitID());\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn personnelLoader.loadList(rs).get(0);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * Matches all personnel who have names LIKE (as in SQL) the first and last names passed in.\n\t * \n\t * @param first The first name to be searched for.\n\t * @param last The last name to be searched for.\n\t * @return A java.util.List of personnel who match these names.\n\t * @throws DBException\n\t */\n\tpublic List<PersonnelBean> searchForPersonnelWithName(String first, String last) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\t\n\t\tif (first.equals(\"%\") && last.equals(\"%\")) return new Vector<PersonnelBean>();\n\t\t\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\t\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM personnel WHERE firstName LIKE ? AND lastName LIKE ?\");\n\t\t\tps.setString(1, first);\n\t\t\tps.setString(2, last);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn personnelLoader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n}", "ReferralDAO.java": "package edu.ncsu.csc.itrust.dao.mysql;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.DBUtil;\nimport edu.ncsu.csc.itrust.beans.ReferralBean;\nimport edu.ncsu.csc.itrust.beans.loaders.ReferralBeanLoader;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\n\n/**\n * Used to update referrals, and fetch lists of referrals sent to and\n * from HCPs.\n *\n * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,\n * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are\n * added. DAOs can assume that all data has been validated and is correct.\n * \n * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be\n * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC\n * connections and/or accessing other DAOs.\n * \n */\npublic class ReferralDAO {\n\tprivate DAOFactory factory;\n\tprivate ReferralBeanLoader referralLoader;\n\n\t/**\n\t * The typical constructor.\n\t * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.\n\t */\n\tpublic ReferralDAO(DAOFactory factory) {\n\t\tthis.factory = factory;\n\t\treferralLoader = new ReferralBeanLoader();\n\t}\n\n\t\n\n\t/**\n\t * Gets a list of all referrals sent from an HCP\n\t * @param mid The HCP's mid.\n\t * @return The list of the referrals they sent.\n\t * @throws DBException\n\t */\n\tpublic List<ReferralBean> getReferralsSentFrom(long mid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM referrals WHERE SenderID = ?\");\n\t\t\tps.setLong(1, mid);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\t\n\t\t\t\n\t\t\treturn referralLoader.loadList(rs);\n\t\t\t\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t * Gets a list of all referrals sent to an HCP\n\t * @param mid The HCP's mid.\n\t * @return The list of the referrals sent to them.\n\t * @throws DBException\n\t */\n\tpublic List<ReferralBean> getReferralsSentTo(long mid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM referrals WHERE ReceiverID = ?\");\n\t\t\tps.setLong(1, mid);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\t\n\t\t\t\n\t\t\treturn referralLoader.loadList(rs);\n\t\t\t\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\n\t/**\n\t * Updates a given referral in the database.\n\t * @param r The referral to update.\n\t * @throws DBException\n\t */\n\tpublic void editReferral(ReferralBean r) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"UPDATE referrals SET PatientID=?,SenderID=?,ReceiverID=?,\"\n\t\t\t\t\t+ \"ReferralDetails=?,ConsultationDetails=?,Status=?  WHERE ID=?\");\n\t\t\treferralLoader.loadParameters(ps, r);\n\t\t\tps.setLong(7, r.getId());\n\t\t\tps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * Adds a given referral to the database.\n\t * @param r The referral to add.\n\t * @throws DBException\n\t */\n\tpublic void addReferral(ReferralBean r) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"INSERT INTO referrals (PatientID,SenderID,ReceiverID,\"\n\t\t\t\t\t+ \"ReferralDetails,ConsultationDetails,Status)  \"\n\t\t\t\t\t+ \"VALUES (?,?,?,?,?,?)\");\n\t\t\treferralLoader.loadParameters(ps, r);\n\t\t\tps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n}", "RemoteMonitoringDAO.java": "package edu.ncsu.csc.itrust.dao.mysql;\n\nimport java.sql.Connection;\nimport java.util.Date;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.DBUtil;\nimport edu.ncsu.csc.itrust.beans.RemoteMonitoringDataBean;\nimport edu.ncsu.csc.itrust.beans.loaders.RemoteMonitoringDataBeanLoader;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.iTrustException;\n\n/**\n * Used for the keeping track of remote monitoring data.\n * \n * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,\n * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are\n * added. DAOs can assume that all data has been validated and is correct.\n * \n * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be\n * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC\n * connections and/or accessing other DAOs.\n * \n */\npublic class RemoteMonitoringDAO {\n\tprivate DAOFactory factory;\n\tprivate RemoteMonitoringDataBeanLoader loader = new RemoteMonitoringDataBeanLoader();\n\n\t/**\n\t * The typical constructor.\n\t * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.\n\t */\n\tpublic RemoteMonitoringDAO(DAOFactory factory) {\n\t\tthis.factory = factory;\n\t}\n\n\t/**\n\t * Returns patient data for a given HCP\n\t * \n\t * @return\n\t * @throws DBException\n\t */\n\tpublic List<RemoteMonitoringDataBean> getPatientsData(long loggedInMID) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM RemoteMonitoringLists WHERE HCPMID=? ORDER BY PatientMID\");\n\t\t\tps.setLong(1, loggedInMID);\n\t\t\tResultSet patientRS = ps.executeQuery();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM RemoteMonitoringData WHERE timelogged >= CURRENT_DATE ORDER BY PatientID, timeLogged DESC\");\n\t\t\tResultSet dataRS = ps.executeQuery();\n\t\t\t\n\t\t\tList<String> patientList = new ArrayList<String>();\n\t\t\twhile(patientRS.next()) {\n\t\t\t\tpatientList.add(patientRS.getLong(\"PatientMID\") + \"\");\n\t\t\t}\n\t\t\tList<RemoteMonitoringDataBean> dataList = loader.loadList(dataRS);\t\t\t\n\t\t\t\n\t\t\tint i, j;\n\t\t\t//Go through all patients and remove any that aren't monitored by this HCP\n\t\t\tfor(i = 0; i < dataList.size(); i++) {\n\t\t\t\tif(!patientList.contains(dataList.get(i).getPatientMID() + \"\")) {\n\t\t\t\t\tdataList.remove(i);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//Add values in patient list with no data for today to list.\n\t\t\tboolean itsThere;\n\t\t\tfor(i = 0; i < patientList.size(); i++) {\n\t\t\t\titsThere = false;\n\t\t\t\tfor(j = 0; j < dataList.size(); j++) {\n\t\t\t\t\tif((dataList.get(j).getPatientMID() + \"\").equals(patientList.get(i))) {\n\t\t\t\t\t\titsThere = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!itsThere) {\n\t\t\t\t\tdataList.add(new RemoteMonitoringDataBean(Long.parseLong(patientList.get(i))));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn dataList;\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\tpublic List<RemoteMonitoringDataBean> getPatientDataByDate(long patientMID, Date lower, Date upper) throws DBException{\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry{\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM remotemonitoringdata WHERE PatientID=? AND timeLogged >= ? AND timeLogged <= ? ORDER BY timeLogged DESC\");\n\t\t\tps.setLong(1, patientMID);\n\t\t\tps.setTimestamp(2, new Timestamp(lower.getTime()));\n\t\t\t// add 1 day's worth to include the upper\n\t\t\tps.setTimestamp(3, new Timestamp(upper.getTime() + 1000L * 60L * 60 * 24L));\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\tList<RemoteMonitoringDataBean> dataList = loader.loadList(rs);\n\t\t\treturn dataList;\n\t\t}catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Store data for a given patient in the RemoteMonitoringData table\n\t * \n\t * @param patientMID The MID of the patient\n\t * @param systolicBloodPressure The systolic blood pressure of the patient\n\t * @param diastolicBloodPressure The diastolic blood pressure of the patient\n\t * @param glucoseLevel The glucose level of the patient\n\t * @param reporterRole  The role of the person that reported these monitoring stats\n\t * @param reporterMID  The MID of the person that reported these monitoring stats\n\t * @throws DBException\n\t */\n\tpublic void storePatientData(long patientMID, int systolicBloodPressure, int diastolicBloodPressure, int glucoseLevel, String reporterRole, long reporterMID)\n\t\t\tthrows DBException, iTrustException {\n\t\tif(getNumberOfDailyEntries(patientMID) >= 10)\n\t\t\tthrow new iTrustException(\"Patient entries for today cannot exceed 10.\");\n\t\t\n\t\tif(reporterRole.equals(\"patient representative\"))\n\t\t\tvalidatePR(reporterMID, patientMID);\n\t\t\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"INSERT INTO RemoteMonitoringData(PatientID, systolicBloodPressure, \"\n\t\t\t\t\t+ \"diastolicBloodPressure, glucoseLevel, ReporterRole, ReporterID) VALUES(?,?,?,?,?,?)\");\n\t\t\tps.setLong(1, patientMID);\n\t\t\tps.setLong(2, systolicBloodPressure);\n\t\t\tps.setInt(3, diastolicBloodPressure);\n\t\t\tps.setInt(4, glucoseLevel);\n\t\t\tps.setString(5, reporterRole);\n\t\t\tps.setLong(6, reporterMID);\n\t\t\tps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * Store data for a given patient in the RemoteMonitoringData table\n\t * \n\t * @param patientMID The MID of the patient\n\t * @param systolicBloodPressure The systolic blood pressure of the patient\n\t * @param diastolicBloodPressure The diastolic blood pressure of the patient\n\t * @param glucoseLevel The glucose level of the patient\n\t * @param reporterRole  The role of the person that reported these monitoring stats\n\t * @param reporterMID  The MID of the person that reported these monitoring stats\n\t * @throws DBException\n\t */\n\tpublic void storePatientData(long patientMID, int glucoseLevel, String reporterRole, long reporterMID)\n\t\t\tthrows DBException, iTrustException {\n\t\tif(getNumberOfDailyEntries(patientMID) >= 10)\n\t\t\tthrow new iTrustException(\"Patient entries for today cannot exceed 10.\");\n\t\t\n\t\tif(reporterRole.equals(\"patient representative\"))\n\t\t\tvalidatePR(reporterMID, patientMID);\n\t\t\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"INSERT INTO RemoteMonitoringData(PatientID, glucoseLevel, ReporterRole, ReporterID) VALUES(?,?,?,?)\");\n\t\t\tps.setLong(1, patientMID);\n\t\t\tps.setInt(2, glucoseLevel);\n\t\t\tps.setString(3, reporterRole);\n\t\t\tps.setLong(4, reporterMID);\n\t\t\tps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Store data for a given patient in the RemoteMonitoringData table\n\t * \n\t * @param patientMID The MID of the patient\n\t * @param systolicBloodPressure The systolic blood pressure of the patient\n\t * @param diastolicBloodPressure The diastolic blood pressure of the patient\n\t * @param glucoseLevel The glucose level of the patient\n\t * @param reporterRole  The role of the person that reported these monitoring stats\n\t * @param reporterMID  The MID of the person that reported these monitoring stats\n\t * @throws DBException\n\t */\n\tpublic void storePatientData(long patientMID, int systolicBloodPressure, int diastolicBloodPressure, String reporterRole, long reporterMID)\n\t\t\tthrows DBException, iTrustException {\n\t\tif(getNumberOfDailyEntries(patientMID) >= 10)\n\t\t\tthrow new iTrustException(\"Patient entries for today cannot exceed 10.\");\n\t\t\n\t\tif(reporterRole.equals(\"patient representative\"))\n\t\t\tvalidatePR(reporterMID, patientMID);\n\t\t\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"INSERT INTO RemoteMonitoringData(PatientID, systolicBloodPressure, \"\n\t\t\t\t\t+ \"diastolicBloodPressure, ReporterRole, ReporterID) VALUES(?,?,?,?,?)\");\n\t\t\tps.setLong(1, patientMID);\n\t\t\tps.setLong(2, systolicBloodPressure);\n\t\t\tps.setInt(3, diastolicBloodPressure);\n\t\t\tps.setString(4, reporterRole);\n\t\t\tps.setLong(5, reporterMID);\n\t\t\tps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Private method to get the number of entries for a certain patientID for today.\n\t * @param patientMID\n\t * @return the number of entries\n\t * @throws DBException\n\t */\n\tprivate int getNumberOfDailyEntries(long patientMID) throws DBException{\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM RemoteMonitoringData WHERE PatientID=? AND DATE(timeLogged)=CURRENT_DATE\");\n\t\t\tps.setLong(1, patientMID);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\tList<RemoteMonitoringDataBean> patients = loader.loadList(rs);\n\t\t\treturn patients.size();\n\t\t\t\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\tpublic void validatePR(long representativeMID, long patientMID)\n\t\t\tthrows iTrustException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM Representatives WHERE RepresenterMID=? AND RepresenteeMID=?\");\n\t\t\tps.setLong(1, representativeMID);\n\t\t\tps.setLong(2, patientMID);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\tif(!rs.next()) //no rows\n\t\t\t\tthrow new iTrustException(\"Representer is not valid for patient \" + patientMID);\n\t\t\t\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * Add a patient to the list of HCPs' monitoring lists of Patients\n\t * \n\t * @param patientMID The MID of the patient\n\t * @param HCPMID The MID of the HCP\n\t * @return true if added successfully, false if already in list\n\t */\n\tpublic boolean addPatientToList(long patientMID, long HCPMID) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM RemoteMonitoringLists WHERE PatientMID = ? AND HCPMID = ?\");\n\t\t\tps.setLong(1, patientMID);\n\t\t\tps.setLong(2, HCPMID);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\tif(rs.next())\n\t\t\t\treturn false;\n\t\t\tps = conn.prepareStatement(\"INSERT INTO RemoteMonitoringLists(PatientMID, HCPMID) VALUES(?,?)\");\n\t\t\tps.setLong(1, patientMID);\n\t\t\tps.setLong(2, HCPMID);\n\t\t\tps.executeUpdate();\n\t\t\treturn true;\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * Remove a patient from the list of HCPs' monitoring lists of Patients\n\t * \n\t * @param patientMID The MID of the patient\n\t * @param HCPMID The MID of the HCP\n\t * @return true if removed successfully, false if not in list\n\t */\n\tpublic boolean removePatientFromList(long patientMID, long HCPMID) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\t/*ps = conn.prepareStatement(\"SELECT * FROM RemoteMonitoringList WHERE PatientMID = ? AND HCPMID = ?\");\n\t\t\tps.setLong(1, patientMID);\n\t\t\tps.setLong(2, HCPMID);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\tif(!rs.next())\n\t\t\t\treturn false;*/\n\t\t\tps = conn.prepareStatement(\"DELETE FROM RemoteMonitoringLists WHERE PatientMID = ? AND HCPMID = ?\");\n\t\t\tps.setLong(1, patientMID);\n\t\t\tps.setLong(2, HCPMID);\n\t\t\tif(ps.executeUpdate() == 0)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n}", "ReportRequestDAO.java": "package edu.ncsu.csc.itrust.dao.mysql;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Date;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.DBUtil;\nimport edu.ncsu.csc.itrust.beans.ReportRequestBean;\nimport edu.ncsu.csc.itrust.beans.loaders.ReportRequestBeanLoader;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\n\n/**\n * Used for handling data related to report requests.\n * \n * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,\n * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are\n * added. DAOs can assume that all data has been validated and is correct.\n * \n * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be\n * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC\n * connections and/or accessing other DAOs.\n * \n */\npublic class ReportRequestDAO {\n\tprivate DAOFactory factory;\n\tprivate ReportRequestBeanLoader loader;\n\n\t/**\n\t * The typical constructor.\n\t * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.\n\t */\n\tpublic ReportRequestDAO(DAOFactory factory) {\n\t\tthis.factory = factory;\n\t\tloader = new ReportRequestBeanLoader();\n\t}\n\t\n\t/**\n\t * Returns a full bean describing a given report request.\n\t * \n\t * @param id The unique ID of the bean in the database.\n\t * @return The bean describing this report request.\n\t * @throws DBException\n\t */\n\tpublic ReportRequestBean getReportRequest(long id) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tif (id == 0L) throw new SQLException(\"ID cannot be null\");\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM ReportRequests WHERE ID = ?\");\n\t\t\tps.setLong(1, id);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\trs.next();\n\t\t\treturn loader.loadSingle(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * Returns all report requests associated with a given requester.\n\t * \n\t * @param mid The MID of the personnel in question.\n\t * @return A java.util.List of report requests.\n\t * @throws DBException\n\t */\n\tpublic List<ReportRequestBean> getAllReportRequestsForRequester(long mid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\n\t\ttry {\n\t\t\tif (mid == 0L) throw new SQLException(\"RequesterMID cannot be null\");\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM ReportRequests WHERE RequesterMID = ?\");\n\t\t\tps.setLong(1, mid);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn loader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Returns all of the report requests associated with a specific patient.\n\t * \n\t * @param pid The MID of the patient in question.\n\t * @return A java.util.List of report requests.\n\t * @throws DBException\n\t */\n\tpublic List<ReportRequestBean> getAllReportRequestsForPatient(long pid) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\n\t\ttry {\n\t\t\tif (pid == 0L) throw new SQLException(\"PatientMID cannot be null\");\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM ReportRequests WHERE PatientMID = ?\");\n\t\t\tps.setLong(1, pid);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn loader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n//\t/**\n//\t * Returns every report request in the database.\n//\t * @return A java.util.List of report requests.\n//\t * @throws DBException\n//\t */\n//\tpublic List<ReportRequestBean> getAllReportRequests() throws DBException {\n//\t\tConnection conn = null;\n//\t\tPreparedStatement ps = null;\n//\n//\t\ttry {\n//\t\t\tconn = factory.getConnection();\n//\t\t\tps = conn.prepareStatement(\"SELECT * FROM ReportRequests\");\n//\t\t\tResultSet rs = ps.executeQuery();\n//\t\t\treturn loader.loadList(rs);\n//\t\t} catch (SQLException e) {\n//\t\t\te.printStackTrace();\n//\t\t\tthrow new DBException(e);\n//\t\t} finally {\n//\t\t\tDBUtil.closeConnection(conn, ps);\n//\t\t}\n//\t}\n\t\n\t/**\n\t * Adds a request for a report.\n\t * \n\t * @param requesterMID The MID of the requester.\n\t * @param patientMID The MID of the patient in question.\n\t * @param date The date the request was made.\n\t * @return A long of the unique ID of the report request.\n\t * @throws DBException\n\t */\n\tpublic long addReportRequest(long requesterMID, long patientMID, Date date) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tif (requesterMID == 0L) throw new SQLException(\"RequesterMID cannot be null\");\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"INSERT INTO ReportRequests (ID, RequesterMID, PatientMID, RequestedDate, Status) VALUES (null,?,?,?,'Requested')\");\n\t\t\tps.setLong(1, requesterMID);\n\t\t\tps.setLong(2, patientMID);\n\t\t\tps.setTimestamp(3, new java.sql.Timestamp(date.getTime()));\n\t\t\tps.executeUpdate();\n\t\t\treturn DBUtil.getLastInsert(conn);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n//\t/**\n//\t * Sets the status of a request to 'Approved'\n//\t * \n//\t * @param ID The unique ID of the report.\n//\t * @param approverMID The MID of the person approving the request.\n//\t * @param date The date the approval was made.\n//\t * @throws DBException\n//\t */\n//\tpublic void approveReportRequest(long ID, long approverMID, Date date) throws DBException {\n//\t\tConnection conn = null;\n//\t\tPreparedStatement ps = null;\n//\t\ttry {\n//\t\t\tif (ID == 0L) throw new SQLException(\"ID cannot be null\");\n//\t\t\tconn = factory.getConnection();\n//\t\t\tps = conn.prepareStatement(\"UPDATE ReportRequests set ApproverMID = ?, ApprovedDate = ?, Status = 'Approved' where ID = ?\");\n//\t\t\tps.setLong(1, approverMID);\n//\t\t\tps.setTimestamp(2, new java.sql.Timestamp(date.getTime()));\n//\t\t\tps.setLong(3, ID);\n//\t\t\tps.executeUpdate();\n//\t\t} catch (SQLException e) {\n//\t\t\te.printStackTrace();\n//\t\t\tthrow new DBException(e);\n//\t\t} finally {\n//\t\t\tDBUtil.closeConnection(conn, ps);\n//\t\t}\n//\t}\n//\n//\t/**\n//\t * Sets the status of a report request to 'Rejected'\n//\t * \n//\t * @param ID The unique ID of the request in question.\n//\t * @param approverMID The MID of the rejecter in question.\n//\t * @param date The date the rejection was made.\n//\t * @param comment A comment describing why the request was rejected.\n//\t * @throws DBException\n//\t */\n//\tpublic void rejectReportRequest(long ID, long approverMID, Date date, String comment) throws DBException {\n//\t\tConnection conn = null;\n//\t\tPreparedStatement ps = null;\n//\t\ttry {\n//\t\t\tif (ID == 0L) throw new SQLException(\"ID cannot be null\");\n//\t\t\tconn = factory.getConnection();\n//\t\t\tps = conn.prepareStatement(\"UPDATE ReportRequests set ApproverMID = ?, ApprovedDate = ?, Status = 'Rejected', comment = ? where ID = ?\");\n//\t\t\tps.setLong(1, approverMID);\n//\t\t\tps.setTimestamp(2, new java.sql.Timestamp(date.getTime()));\n//\t\t\tps.setString(3, comment);\n//\t\t\tps.setLong(4, ID);\n//\t\t\tps.executeUpdate();\n//\t\t} catch (SQLException e) {\n//\t\t\te.printStackTrace();\n//\t\t\tthrow new DBException(e);\n//\t\t} finally {\n//\t\t\tDBUtil.closeConnection(conn, ps);\n//\t\t}\n//\t}\n\t\n\t/**\n\t * Sets the status of a report request to 'Viewed'\n\t * \n\t * @param ID The unique ID of the request in question.\n\t * @param date The date the request was viewed.\n\t * @throws DBException\n\t */\n\tpublic void setViewed(long ID, Date date) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tif (ID == 0L) throw new SQLException(\"ID cannot be null\");\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"UPDATE ReportRequests set ViewedDate = ?, Status = 'Viewed' where ID = ?\");\n\t\t\tps.setTimestamp(1, new java.sql.Timestamp(date.getTime()));\n\t\t\tps.setLong(2, ID);\n\t\t\tps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t\t\n\t}\n\n}", "RiskDAO.java": "package edu.ncsu.csc.itrust.dao.mysql;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.DBUtil;\nimport edu.ncsu.csc.itrust.beans.FamilyMemberBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\n\n/**\n * Used for finding risk factors for a given patient.\n * \n * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,\n * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are\n * added. DAOs can assume that all data has been validated and is correct.\n * \n * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be\n * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC\n * connections and/or accessing other DAOs.\n * \n * @author Andy\n * \n */\npublic class RiskDAO {\n\tprivate DAOFactory factory;\n\n\t/**\n\t * The typical constructor.\n\t * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.\n\t */\n\tpublic RiskDAO(DAOFactory factory) {\n\t\tthis.factory = factory;\n\t}\n\n\t/**\n\t * This method is implemented using {@link FamilyDAO} for 2 reasons: (a) definitions of family members\n\t * might change, so it's better to centralize that code and (2) to make this code a little bit \"nicer\"\n\t * even though it executes one query per family member. If this method gets slow, then you will need to\n\t * refactor. Otherwise, let's just keep it simple...\n\t * \n\t * @param patientID The MID of the patient in question.\n\t * @param icdLower A double of the lower bound for the codes.\n\t * @param icdUpper A double of the upper bound for the codes.\n\t * @return A boolean indicating whether a family member had a match in this range.\n\t * @throws DBException\n\t */\n\tpublic boolean hasFamilyHistory(long patientID, double icdLower, double icdUpper) throws DBException {\n\t\tList<FamilyMemberBean> familyMembers = getFamilyMembers(patientID);\n\t\tfor (FamilyMemberBean famMember : familyMembers) {\n\t\t\tif (hadPriorDiagnoses(famMember.getMid(), icdLower, icdUpper))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate List<FamilyMemberBean> getFamilyMembers(long patientID) throws DBException {\n\t\tFamilyDAO famDAO = factory.getFamilyDAO();\n\t\tList<FamilyMemberBean> familyMembers = famDAO.getParents(patientID);\n\t\tfamilyMembers.addAll(famDAO.getSiblings(patientID));\n\t\treturn familyMembers;\n\t}\n\n\t/**\n\t * Returns whether or not a patient had a childhood infection for the exact, given ICD codes.\n\t * \n\t * @param patientID The MID of the patient in question.\n\t * @param icdCodes A parameter list of the ICD codes to match.\n\t * @return A boolean indicating whether this patient had all the listed ICD codes.\n\t * @throws DBException\n\t */\n\tpublic boolean hadChildhoodInfection(long patientID, double... icdCodes) throws DBException {\n\t\t// Note the datediff call - this is a MySQL function that takes the difference between two\n\t\t// dates and returns that value in terms of days. 6570 days is 18 years (not counting leap years)\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM OVDiagnosis ovd, OfficeVisits ov, Patients p \"\n\t\t\t\t\t+ \"WHERE ovd.visitID=ov.id AND ov.patientid=p.mid AND p.mid=? \"\n\t\t\t\t\t+ \"AND datediff(ov.visitdate,p.dateofbirth) < 6570 AND ovd.icdcode IN (\"\n\t\t\t\t\t+ createPrepared(icdCodes.length) + \")\");\n\t\t\tps.setLong(1, patientID);\n\t\t\tsetICDs(2, ps, icdCodes);\n\t\t\treturn ps.executeQuery().next(); // if this query has ANY rows, then yes\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\tprivate String createPrepared(int length) {\n\t\tString str = \"\";\n\t\tfor (int i = 0; i < length; i++)\n\t\t\tstr += \"?,\";\n\t\treturn str.substring(0, str.length() - 1);\n\t}\n\n\tprivate void setICDs(int start, PreparedStatement ps, double[] icdCodes) throws SQLException {\n\t\tfor (double icdCode : icdCodes) {\n\t\t\tps.setDouble(start++, icdCode);\n\t\t}\n\t}\n\n\t/**\n\t * Returns if the patient has ever smoked in their life\n\t * \n\t * @param patientID The MID of the patient in question.\n\t * @return A boolean indicating whether the patient smoked.\n\t * @throws DBException\n\t */\n\tpublic boolean hasSmoked(long patientID) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn\n\t\t\t\t\t.prepareStatement(\"SELECT * FROM PersonalHealthInformation WHERE PatientID=? AND Smoker=1\");\n\t\t\tps.setLong(1, patientID);\n\t\t\treturn ps.executeQuery().next(); // if this query has ANY rows, then yes\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Returns if a patient has ever been diagnosed with the given ICD code, in the range [lower,upper)\n\t * \n\t * @param patientID The MID of the patient in question.\n\t * @param lowerICDCode A double of the lower ICD code.\n\t * @param upperICDCode A double of the upper ICD code.\n\t * @return A boolean indicating whether there was a match in the given range.\n\t * @throws DBException\n\t */\n\tpublic boolean hadPriorDiagnoses(long patientID, double lowerICDCode, double upperICDCode)\n\t\t\tthrows DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM OVDiagnosis ovd, OfficeVisits ov, Patients p \"\n\t\t\t\t\t+ \"WHERE ovd.visitID=ov.id AND ov.patientid=p.mid AND p.mid=? \"\n\t\t\t\t\t+ \"AND ovd.icdcode>=? AND ovd.icdcode<?\");\n\t\t\tps.setLong(1, patientID);\n\t\t\tps.setDouble(2, lowerICDCode);\n\t\t\tps.setDouble(3, upperICDCode);\n\t\t\treturn ps.executeQuery().next(); // if this query has ANY rows, then yes\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n}", "SurveyDAO.java": "package edu.ncsu.csc.itrust.dao.mysql;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Date;\nimport edu.ncsu.csc.itrust.DBUtil;\nimport edu.ncsu.csc.itrust.beans.SurveyBean;\nimport edu.ncsu.csc.itrust.beans.loaders.SurveyLoader;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\n\n/**\n * A DAO for handling all Survey data.\n * \n * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,\n * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are\n * added. DAOs can assume that all data has been validated and is correct.\n * \n * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be\n * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC\n * connections and/or accessing other DAOs.\n */\npublic class SurveyDAO {\n\tprivate DAOFactory factory;\n\tprivate SurveyLoader surveyLoader;\n\n\t/**\n\t * The typical constructor.\n\t * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.\n\t */\n\tpublic SurveyDAO(DAOFactory factory) {\n\t\tthis.factory = factory;\n\t\tthis.surveyLoader = new SurveyLoader();\n\t}\n\t\n\t/**\n\t * Insert survey data into database.\n\t * @param surveyBean The Bean representing the user's responses which will be inserted.\n\t * @param date The date the survey was completed.\n\t */\n\tpublic void addCompletedSurvey(SurveyBean surveyBean, Date date) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"INSERT INTO OVSurvey (VisitID, SurveyDate) VALUES (?,?)\");\n\t\t\tps.setLong(1, surveyBean.getVisitID());\n\t\t\tps.setTimestamp(2, new java.sql.Timestamp(date.getTime()));\n\t\t\tps.executeUpdate();\n\t\t\tif (surveyBean.getWaitingRoomMinutes() > 0) {\n\t\t\t\tps = conn.prepareStatement(\"update OVSurvey set WaitingRoomMinutes = ? where VisitID = ?\");\n\t\t\t\tps.setFloat(1, surveyBean.getWaitingRoomMinutes());\n\t\t\t\tps.setLong(2, surveyBean.getVisitID());\n\t\t\t\tps.executeUpdate();\n\t\t\t}\n\t\t\tif (surveyBean.getExamRoomMinutes() > 0) {\n\t\t\t\tps = conn.prepareStatement(\"update OVSurvey set ExamRoomMinutes = ? where VisitID = ?\");\n\t\t\t\tps.setFloat(1, surveyBean.getExamRoomMinutes());\n\t\t\t\tps.setLong(2, surveyBean.getVisitID());\n\t\t\t\tps.executeUpdate();\n\t\t\t}\n\t\t\tif (surveyBean.getVisitSatisfaction() > 0) {\n\t\t\t\tps = conn.prepareStatement(\"update OVSurvey set VisitSatisfaction = ? where VisitID = ?\");\n\t\t\t\tps.setFloat(1, surveyBean.getVisitSatisfaction());\n\t\t\t\tps.setLong(2, surveyBean.getVisitID());\n\t\t\t\tps.executeUpdate();\n\t\t\t}\n\t\t\tif (surveyBean.getTreatmentSatisfaction() > 0) {\n\t\t\t\tps = conn.prepareStatement(\"update OVSurvey set TreatmentSatisfaction = ? where VisitID = ?\");\n\t\t\t\tps.setFloat(1, surveyBean.getTreatmentSatisfaction());\n\t\t\t\tps.setLong(2, surveyBean.getVisitID());\n\t\t\t\tps.executeUpdate();\n\t\t\t}\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * Gets survey data from the database by the office visit id. Creates an instance of an\n\t * SurveyBean with data and returns it.\n\t * \n\t * @param id The unique ID of the survey in question.\n\t * @return A bean containing the SurveyBean.\n\t * @throws DBException\n\t */\n\tpublic SurveyBean getSurveyData(long id) throws DBException {\n\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM OVSurvey WHERE VisitID = ?\");\n\t\t\tps.setLong(1, id);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\trs.next();\n\t\t\treturn surveyLoader.loadSingle(rs);\n\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * Has this survey been completed?\n\t * \n\t * @param visitID The unique ID of the office visit we are wondering about.\n\t * @return boolean indicating whether this survey is completed.\n\t * @throws DBException\n\t */\n\tpublic boolean isSurveyCompleted(long visitID) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\t\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT count(*) FROM OVSurvey WHERE VisitID = ?\");\n\t\t\tps.setLong(1, visitID);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\trs.next();\n\t\t\treturn (rs.getInt(1) == 0) ? false : true;\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n}", "SurveyResultDAO.java": "package edu.ncsu.csc.itrust.dao.mysql;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.DBUtil;\nimport edu.ncsu.csc.itrust.beans.SurveyResultBean;\nimport edu.ncsu.csc.itrust.beans.loaders.SurveyResultBeanLoader;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\n\n/**\n * A DAO for handling all Survey results.\n * \n * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,\n * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are\n * added. DAOs can assume that all data has been validated and is correct.\n * \n * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be\n * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC\n * connections and/or accessing other DAOs.\n */\npublic class SurveyResultDAO {\n\tprivate DAOFactory factory;\n\tprivate SurveyResultBeanLoader loader;\n\t\n\t/**\n\t * The typical constructor.\n\t * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.\n\t */\n\tpublic SurveyResultDAO(DAOFactory factory) {\n\t\tthis.factory = factory;\n\t\tthis.loader = new SurveyResultBeanLoader();\n\t}\n\t\n\t/**\n\t * Returns all the survey results in the database that correspond to a particular zip code.\n\t * \n\t * @param zip The zipcode we are interested in as a String.\n\t * @param specialty The specialty we are interested in as a String.\n\t * @return A java.util.List of SurveyResultBeans.\n\t * @throws DBException\n\t */\n\tpublic List<SurveyResultBean> getSurveyResultsForZip(String zip, String specialty) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\n\t\tStringBuffer sql = new StringBuffer();\n\t\tsql.append(\"select p.mid, p.firstname, p.lastname, p.address1, p.address2, p.city, p.state, p.zip, p.specialty, \");\n\t\tsql.append(\"'na' hospitalID, \");\n\t\tsql.append(\"avg(s.WaitingRoomMinutes) AvgWaitingRoomMinutes, \");\n\t\tsql.append(\"avg(s.ExamRoomMinutes) AvgExamRoomMinutes, \");\n\t\tsql.append(\"avg(s.VisitSatisfaction) AvgVisitSatisfaction, \");\n\t\tsql.append(\"avg(s.TreatmentSatisfaction) AvgTreatmentSatisfation, \");\n\t\tsql.append(\"count(*) / \");\n\t\tsql.append(\"\t(select count(*) from personnel p1, officevisits v1 \");\n\t\tsql.append(\"\t where v1.hcpid = p1.mid \");\n\t\tsql.append(\"\t and substr(p1.zip,1,3) = ? \");\n\t\tsql.append(\"\t and p1.mid = p.mid) * 100 PercentSatisfactionResults \");\n\t\tsql.append(\"from ovsurvey s, personnel p, officevisits v \");\n\t\tsql.append(\"where s.visitid = v.id \");\n\t\tsql.append(\"and v.hcpid = p.mid \");\n\t\tsql.append(\"and substr(p.zip,1,3) = ? \");\n\t\tif (!specialty.equals(SurveyResultBean.ANY_SPECIALTY))\n\t\t\tsql.append(\"and specialty = ?\");\n\t\tsql.append(\"group by p.mid, p.firstname, p.lastname, p.address1, p.address2, p.city, p.state, p.zip, hospitalID \");\n\t\tif (!specialty.equals(SurveyResultBean.ANY_SPECIALTY))\n\t\t\tsql.append(\", p.specialty \");\n\t\tsql.append(\"order by p.mid \");\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(sql.toString());\n\t\t\tps.setString(1, zip.substring(0, 3));\n\t\t\tps.setString(2, zip.substring(0, 3));\n\t\t\tif (!specialty.equals(SurveyResultBean.ANY_SPECIALTY))\n\t\t\t\tps.setString(3, specialty);\n\t\t\treturn loader.loadList(ps.executeQuery());\n\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * Returns all the survey data associated with a given hospital and a certain specialty.\n\t * \n\t * @param hospitalID The unique ID of the iTrust hospital we are querying about.\n\t * @param specialty A string representing the specialty we are interested in.\n\t * @return A java.util.List of SurveyResultBeans.\n\t * @throws DBException\n\t */\n\tpublic List<SurveyResultBean> getSurveyResultsForHospital(String hospitalID, String specialty) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\n\t\tStringBuffer sql = new StringBuffer();\n\t\tsql.append(\"select p.mid, p.firstname, p.lastname, p.address1, p.address2, p.city, p.state, p.zip, p.specialty, \");\n\t\tsql.append(\"h.hosid hospitalID, \");\n\t\tsql.append(\"avg(s.WaitingRoomMinutes) AvgWaitingRoomMinutes, \");\n\t\tsql.append(\"avg(s.ExamRoomMinutes) AvgExamRoomMinutes, \");\n\t\tsql.append(\"avg(s.VisitSatisfaction) AvgVisitSatisfaction, \");\n\t\tsql.append(\"avg(s.TreatmentSatisfaction) AvgTreatmentSatisfation, \");\n\t\tsql.append(\"count(*) / \");\n\t\tsql.append(\"\t(select count(*) from personnel p1, officevisits v1, HCPAssignedHos h1 \");\n\t\tsql.append(\"\t where v1.hcpid = p1.mid \");\n\t\tsql.append(\"\t and v1.hcpid = h1.hcpid \");\n\t\tsql.append(\"\t and h1.hosid = ? \");\n\t\tsql.append(\"\t and p1.mid = p.mid) * 100 PercentSatisfactionResults \");\n\t\tsql.append(\"from ovsurvey s, personnel p, officevisits v, HCPAssignedHos h \");\n\t\tsql.append(\"where s.visitid = v.id \");\n\t\tsql.append(\"and v.hcpid = p.mid \");\n\t\tsql.append(\"and v.hcpid = h.hcpid \");\n\t\tsql.append(\"and h.hosid = ? \");\n\t\tif (!specialty.equals(SurveyResultBean.ANY_SPECIALTY))\n\t\t\tsql.append(\"and p.specialty = ?\");\n\t\tsql.append(\"group by p.mid, p.firstname, p.lastname, p.address1, p.address2, p.city, p.state, p.zip, hospitalID \");\n\t\tif (!specialty.equals(SurveyResultBean.ANY_SPECIALTY))\n\t\t\tsql.append(\", p.specialty \");\n\t\tsql.append(\"order by p.mid \");\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(sql.toString());\n\t\t\tps.setString(1, hospitalID);\n\t\t\tps.setString(2, hospitalID);\n\t\t\tif (!specialty.equals(SurveyResultBean.ANY_SPECIALTY)) {\n\t\t\t\tps.setString(3, specialty);\n\t\t\t}\n\t\t\treturn loader.loadList(ps.executeQuery());\n\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t\t\n\t}\n}", "TransactionDAO.java": "package edu.ncsu.csc.itrust.dao.mysql;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.sql.Date;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.DBUtil;\nimport edu.ncsu.csc.itrust.beans.OperationalProfile;\nimport edu.ncsu.csc.itrust.beans.TransactionBean;\nimport edu.ncsu.csc.itrust.beans.loaders.OperationalProfileLoader;\nimport edu.ncsu.csc.itrust.beans.loaders.TransactionBeanLoader;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.enums.TransactionType;\nimport edu.ncsu.csc.itrust.exception.DBException;\n\n/**\n * Used for the logging mechanism.\n * \n * DAO stands for Database Access Object. All DAOs are intended to be reflections of the database, that is,\n * one DAO per table in the database (most of the time). For more complex sets of queries, extra DAOs are\n * added. DAOs can assume that all data has been validated and is correct.\n * \n * DAOs should never have setters or any other parameter to the constructor than a factory. All DAOs should be\n * accessed by DAOFactory (@see {@link DAOFactory}) and every DAO should have a factory - for obtaining JDBC\n * connections and/or accessing other DAOs.\n * \n * @author Andy\n * \n */\npublic class TransactionDAO {\n\tprivate DAOFactory factory;\n\tprivate TransactionBeanLoader loader = new TransactionBeanLoader();\n\tprivate OperationalProfileLoader operationalProfileLoader = new OperationalProfileLoader();\n\n\t/**\n\t * The typical constructor.\n\t * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.\n\t */\n\tpublic TransactionDAO(DAOFactory factory) {\n\t\tthis.factory = factory;\n\t}\n\n\t/**\n\t * Returns the whole transaction log\n\t * \n\t * @return\n\t * @throws DBException\n\t */\n\tpublic List<TransactionBean> getAllTransactions() throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT * FROM TransactionLog ORDER BY timeLogged DESC\");\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn loader.loadList(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Log a transaction, just giving it the person who is logged in and the type\n\t * \n\t * @param type The {@link TransactionType} enum representing the type this transaction is.\n\t * @param loggedInMID The MID of the user who is logged in.\n\t * @throws DBException\n\t */\n\tpublic void logTransaction(TransactionType type, long loggedInMID) throws DBException {\n\t\tlogTransaction(type, loggedInMID, 0L, \"\");\n\t}\n\n\t/**\n\t * Log a transaction, with all of the info. The meaning of secondaryMID and addedInfo changes depending on\n\t * the transaction type.\n\t * \n\t * @param type The {@link TransactionType} enum representing the type this transaction is.\n\t * @param loggedInMID The MID of the user who is logged in.\n\t * @param secondaryMID Typically, the MID of the user who is being acted upon.\n\t * @param addedInfo A note about a subtransaction, or specifics of this transaction (for posterity).\n\t * @throws DBException\n\t */\n\tpublic void logTransaction(TransactionType type, long loggedInMID, long secondaryMID, String addedInfo)\n\t\t\tthrows DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"INSERT INTO TransactionLog(loggedInMID, secondaryMID, \"\n\t\t\t\t\t+ \"transactionCode, addedInfo) VALUES(?,?,?,?)\");\n\t\t\tps.setLong(1, loggedInMID);\n\t\t\tps.setLong(2, secondaryMID);\n\t\t\tps.setInt(3, type.getCode());\n\t\t\tps.setString(4, addedInfo);\n\t\t\tps.executeUpdate();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Return a list of all transactions in which an HCP accessed the given patient's record\n\t * \n\t * @param patientID The MID of the patient in question.\n\t * @return A java.util.List of transactions.\n\t * @throws DBException\n\t */\n\tpublic List<TransactionBean> getAllRecordAccesses(long patientID, boolean getByRole) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn\n\t\t\t\t\t.prepareStatement(\"SELECT * FROM TransactionLog WHERE secondaryMID=? AND transactionCode \"\n\t\t\t\t\t\t\t+ \"IN(\" + TransactionType.patientViewableStr + \") ORDER BY timeLogged DESC\");\n\t\t\tps.setLong(1, patientID);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\tList<TransactionBean> tbList = loader.loadList(rs);\n\n\t\t\ttbList = addAndSortRoles(tbList, patientID, getByRole);\n\t\t\t\n\t\t\treturn tbList;\n\t\t\t\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * The Most Thorough Fetch \n\t * @param loggedInRole Role of loggedIn\n\t * @param secondaryRole Role of secondary\n\t * @param begin Beginning of date range\n\t * @param end End of date range\n\t * @param type Type of transaction\n\t * @return\n\t * @throws DBException\n\t */\n\tpublic List<TransactionBean> getTransactionsFor(String loggedInRole, String secondaryRole, Date begin, Date end, TransactionType type) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tif(loggedInRole.compareTo(\"any\") == 0) {\n\t\t\t\tloggedInRole = \"*\";\n\t\t\t}\n\t\t\tif(secondaryRole.compareTo(\"any\") == 0) {\n\t\t\t\tsecondaryRole = \"*\";\n\t\t\t}\n\t\t\t\n\t\t\tps = conn\n\t\t\t\t\t.prepareStatement(\"SELECT * FROM TransactionLog, Users  WHERE (MID=loggedInMID OR MID=secondaryMID) AND (Role=? OR Role=?) \"\n\t\t\t\t\t\t\t+ \" AND transactionCode=? AND timeLogged >= ? AND timeLogged <= ?\" + \" ORDER BY timeLogged DESC\");\n\t\t\tps.setString(1, loggedInRole);\n\t\t\tps.setString(2, secondaryRole);\n\t\t\tps.setInt(3, type.getCode());\n\t\t\tps.setDate(4, begin);\n\t\t\tps.setDate(5, end);\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\tList<TransactionBean> tbList = loader.loadList(rs);\n\n\t\t\t//tbList = addAndSortRoles(tbList, patientID, getByRole);\n\t\t\t\n\t\t\treturn tbList;\n\t\t\t\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Return a list of all transactions in which an HCP accessed the given patient's record, within the dates\n\t * \n\t * @param patientID The MID of the patient in question.\n\t * @param lower The starting date as a java.util.Date\n\t * @param upper The ending date as a java.util.Date\n\t * @return A java.util.List of transactions.\n\t * @throws DBException\n\t */\n\tpublic List<TransactionBean> getRecordAccesses(long patientID, java.util.Date lower, java.util.Date upper, boolean getByRole) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn\n\t\t\t\t\t.prepareStatement(\"SELECT * FROM TransactionLog WHERE secondaryMID=? AND transactionCode IN (\"\n\t\t\t\t\t\t\t+ TransactionType.patientViewableStr\n\t\t\t\t\t\t\t+ \") \"\n\t\t\t\t\t\t\t+ \"AND timeLogged >= ? AND timeLogged <= ? ORDER BY timeLogged DESC\");\n\t\t\tps.setLong(1, patientID);\n\t\t\tps.setTimestamp(2, new Timestamp(lower.getTime()));\n\t\t\t// add 1 day's worth to include the upper\n\t\t\tps.setTimestamp(3, new Timestamp(upper.getTime() + 1000L * 60L * 60 * 24L));\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\tList<TransactionBean> tbList = loader.loadList(rs);\n\n\t\t\ttbList = addAndSortRoles(tbList, patientID, getByRole);\n\t\t\t\n\t\t\treturn tbList;\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the operation profile\n\t * \n\t * @return The OperationalProfile as a bean.\n\t * @throws DBException\n\t */\n\tpublic OperationalProfile getOperationalProfile() throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\tps = conn.prepareStatement(\"SELECT TransactionCode, count(transactionID) as TotalCount, \"\n\t\t\t\t\t+ \"count(if(loggedInMID<9000000000, transactionID, null)) as PatientCount, \"\n\t\t\t\t\t+ \"count(if(loggedInMID>=9000000000, transactionID, null)) as PersonnelCount \"\n\t\t\t\t\t+ \"FROM TransactionLog GROUP BY transactionCode ORDER BY transactionCode ASC\");\n\t\t\tResultSet rs = ps.executeQuery();\n\t\t\treturn operationalProfileLoader.loadSingle(rs);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t/**\n\t * \n\t * @param tbList\n\t * @param patientID\n\t * @param sortByRole\n\t * @return\n\t * @throws DBException\n\t */\n\tprivate List<TransactionBean> addAndSortRoles(List<TransactionBean> tbList, long patientID, boolean sortByRole) throws DBException {\n\t\tConnection conn = null;\n\t\tPreparedStatement ps = null;\n\t\t\n\t\ttry {\n\t\t\tconn = factory.getConnection();\n\t\t\t\n\t\t\tfor(TransactionBean t : tbList) {\n\t\t\t\t\n\t\t\t\tps = conn\n\t\t\t\t\t\t.prepareStatement(\"SELECT Role FROM Users WHERE MID=?\");\n\t\t\t\tps.setLong(1, t.getLoggedInMID());\n\t\t\t\tResultSet rs = ps.executeQuery();\n\t\t\t\tString role = \"\";\n\t\t\t\tif(rs.next())\n\t\t\t\t\trole = rs.getString(\"Role\");\n\t\t\t\tif(role.equals(\"er\"))\n\t\t\t\t\trole = \"Emergency Responder\";\n\t\t\t\telse if(role.equals(\"uap\"))\n\t\t\t\t\trole = \"UAP\";\n\t\t\t\telse if(role.equals(\"hcp\")) {\n\t\t\t\t\trole = \"LHCP\";\n\t\t\t\t\tps = conn\n\t\t\t\t\t\t\t.prepareStatement(\"SELECT PatientID FROM DeclaredHCP WHERE HCPID=?\");\n\t\t\t\t\tps.setLong(1, t.getLoggedInMID());\n\t\t\t\t\tResultSet rs2 = ps.executeQuery();\n\t\t\t\t\twhile(rs2.next()) {\n\t\t\t\t\t\tif (rs2.getLong(\"PatientID\") == patientID){\n\t\t\t\t\t\t\trole = \"DLHCP\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(role.equals(\"patient\")){\n\t\t\t\t\trole = \"Patient\";\n\t\t\t\t\tps = conn\n\t\t\t\t\t\t\t.prepareStatement(\"SELECT representeeMID FROM Representatives WHERE representerMID=?\");\n\t\t\t\t\tps.setLong(1, t.getLoggedInMID());\n\t\t\t\t\tResultSet rs2 = ps.executeQuery();\n\t\t\t\t\twhile(rs2.next()) {\n\t\t\t\t\t\tif (rs2.getLong(\"representeeMID\") == patientID){\n\t\t\t\t\t\t\trole = \"Personal Health Representative\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\tt.setRole(role);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(sortByRole){\n\t\t\t\tTransactionBean[] array = new TransactionBean[tbList.size()];\n\t\t\t\tarray[0] = tbList.get(0);\n\t\t\t\tTransactionBean t;\n\t\t\t\tfor(int i = 1; i < tbList.size(); i++) {\n\t\t\t\t\tt = tbList.get(i);\n\t\t\t\t\tString role = t.getRole();\n\t\t\t\t\tint j = 0;\n\t\t\t\t\twhile(array[j] != null && role.compareToIgnoreCase(array[j].getRole()) >= 0)\n\t\t\t\t\t\tj++;\n\t\t\t\t\tfor(int k = i; k > j; k--) {\n\t\t\t\t\t\tarray[k] = array[k-1];\n\t\t\t\t\t}\n\t\t\t\t\tarray[j] = t;\n\t\t\t\t}\n\t\t\t\tint size = tbList.size();\n\t\t\t\tfor(int i = 0; i < size; i++)\n\t\t\t\t\ttbList.set(i, array[i]);\n\t\t\t\t\n\t\t\t}\n\t\t\n\t\t\treturn tbList;\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DBException(e);\n\t\t} finally {\n\t\t\tDBUtil.closeConnection(conn, ps);\n\t\t}\n\t}\n\t\n\t\n}", "BloodType.java": "package edu.ncsu.csc.itrust.enums;\n\n/**\n * All possible blood types\n * \n * @author Andy\n * \n */\npublic enum BloodType {\n\tAPos(\"A+\"), ANeg(\"A-\"), BPos(\"B+\"), BNeg(\"B-\"), ABPos(\"AB+\"), ABNeg(\"AB-\"), OPos(\"O+\"), ONeg(\"O-\"), NS(\n\t\t\t\"N/S\");\n\tprivate String name;\n\n\tprivate BloodType(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getName();\n\t}\n\n\tpublic static BloodType parse(String bloodTypeStr) {\n\t\tfor (BloodType type : BloodType.values()) {\n\t\t\tif (type.getName().equals(bloodTypeStr)) {\n\t\t\t\treturn type;\n\t\t\t}\n\t\t}\n\t\treturn NS;\n\t}\n}", "Ethnicity.java": "package edu.ncsu.csc.itrust.enums;\n\n/**\n * All possible ethnicities represented in iTrust.\n */\npublic enum Ethnicity {\n\tCaucasian(\"Caucasian\"), AfricanAmerican(\"African American\"), Hispanic(\"Hispanic\"), AmericanIndian(\n\t\t\t\"American Indian\"), Asian(\"Asian\"), NotSpecified(\"Not Specified\");\n\tprivate String name;\n\n\tprivate Ethnicity(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getName();\n\t}\n\n\tpublic static Ethnicity parse(String input) {\n\t\tfor (Ethnicity ethnicity : Ethnicity.values()) {\n\t\t\tif (ethnicity.name.equals(input))\n\t\t\t\treturn ethnicity;\n\t\t}\n\t\treturn NotSpecified;\n\t}\n}", "Gender.java": "package edu.ncsu.csc.itrust.enums;\n\n/**\n * Male or Female.  Not specified is provided as well, for incomplete forms or patient's discretion.\n */\npublic enum Gender {\n\tMale(\"Male\"), Female(\"Female\"), NotSpecified(\"Not Specified\");\n\tprivate String name;\n\n\tprivate Gender(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getName();\n\t}\n\n\tpublic static Gender parse(String input) {\n\t\tfor (Gender gender : Gender.values()) {\n\t\t\tif (gender.name.equals(input))\n\t\t\t\treturn gender;\n\t\t}\n\t\treturn NotSpecified;\n\t}\n}", "PrescriptionAlerts.java": "package edu.ncsu.csc.itrust.enums;\n\n/**\n * Every prescription that should be alerted for emergency reports - in the future, this should be abstracted\n * out to a database table so it can be changed at runtime.\n * \n * @author Andy\n * \n */\npublic enum PrescriptionAlerts {\n\tTetracycline(\"Tetracycline\", \"009042407\"), Prioglitazone(\"Prioglitazone\", \"647641512\");\n\n\tprivate String name;\n\tprivate String NDCode;\n\n\tprivate PrescriptionAlerts(String rName, String rNDCode) {\n\t\tthis.name = rName;\n\t\tthis.NDCode = rNDCode;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic String getNDCode() {\n\t\treturn this.NDCode;\n\t}\n\n\tpublic static boolean isAlert(String code) {\n\t\tfor (PrescriptionAlerts thisone : values()) {\n\t\t\tif (thisone.getNDCode().equals(code))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}", "Role.java": "package edu.ncsu.csc.itrust.enums;\n\n/**\n * The iTrust user roles: Patient, ER, HCP, UAP, PHA, Administrator and Tester.\n * Consult the requirements for the contextual meanings of these individual choices.\n */\npublic enum Role {\n\tPATIENT(\"patient\", \"Patients\"), \n\tER(\"er\", \"Personnel\"), \n\tHCP(\"hcp\", \"Personnel\"), \n\tUAP(\"uap\", \"Personnel\"), \n\tADMIN(\"admin\", \"Personnel\"),\n\tPHA(\"pha\", \"Personnel\"),\n\tTESTER(\"tester\", \"\");\n\t\n\tprivate String userRolesString;\n\tprivate String dbTable;\n\n\tRole(String userRolesString, String dbTable) {\n\t\tthis.userRolesString = userRolesString;\n\t\tthis.dbTable = dbTable;\n\t}\n\n\tpublic String getDBTable() {\n\t\treturn dbTable;\n\t}\n\n\tpublic String getUserRolesString() {\n\t\treturn userRolesString;\n\t}\n\n\tpublic static Role parse(String str) {\n\t\tfor (Role role : values()) {\n\t\t\tif (role.userRolesString.equals(str))\n\t\t\t\treturn role;\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Role \" + str + \" does not exist\");\n\t}\n}", "State.java": "package edu.ncsu.csc.itrust.enums;\n\n/**\n * All of our wonderful states.\n * \n * @author Andy\n * \n */\npublic enum State {\n\tAL(\"Alabama\"), AK(\"Alaska\"), AZ(\"Arizona\"), AR(\"Arkansas\"), CA(\"California\"), CO(\"Colorado\"), CT(\n\t\t\t\"Connecticut\"), DE(\"Delaware\"), DC(\"District of Columbia\"), FL(\"Florida\"), GA(\"Georgia\"), HI(\n\t\t\t\"Hawaii\"), ID(\"Idaho\"), IL(\"Illinois\"), IN(\"Indiana\"), IA(\"Iowa\"), KS(\"Kansas\"), KY(\"Kentucky\"), LA(\n\t\t\t\"Louisiana\"), ME(\"Maine\"), MD(\"Maryland\"), MA(\"Massachusetts\"), MI(\"Michigan\"), MN(\"Minnesota\"), MS(\n\t\t\t\"Mississippi\"), MO(\"Missouri\"), MT(\"Montana\"), NE(\"Nebraska\"), NV(\"Nevada\"), NH(\"New Hampshire\"), NJ(\n\t\t\t\"New Jersey\"), NM(\"New Mexico\"), NY(\"New York\"), NC(\"North Carolina\"), ND(\"North Dakota\"), OH(\n\t\t\t\"Ohio\"), OK(\"Oklahoma\"), OR(\"Oregon\"), PA(\"Pennsylvania\"), RI(\"Rhode Island\"), SC(\n\t\t\t\"South Carolina\"), SD(\"South Dakota\"), TN(\"Tennessee\"), TX(\"Texas\"), UT(\"Utah\"), VT(\"Vermont\"), VA(\n\t\t\t\"Virginia\"), WA(\"Washington\"), WV(\"West Virginia\"), WI(\"Wisconsin\"), WY(\"Wyoming\");\n\tprivate String name;\n\n\tprivate State(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic String getAbbrev() {\n\t\treturn toString();\n\t}\n\n\t// Just to show that this is intentional\n\t@Override\n\tpublic String toString() {\n\t\treturn super.toString();\n\t}\n\n\tpublic static State parse(String state) {\n\t\tState[] values = State.values();\n\t\tfor (State myState : values) {\n\t\t\tif (myState.getName().equals(state) || myState.getAbbrev().equals(state))\n\t\t\t\treturn myState;\n\t\t}\n\t\treturn State.NC;\n\t}\n}", "TransactionType.java": "package edu.ncsu.csc.itrust.enums;\n\n/**\n * All of the possible transaction types, in no particular order, used in producing the operational profile.\n */\npublic enum TransactionType {\n\tENTER_EDIT_DEMOGRAPHICS(1, \"Enter/Edit patient/personnel demographics\"),\n\tDECLARE_HCP(2, \"View HCP / Change designation\"),\n\tALLOW_DISALLOW_ACCESS(3, \"Allow/Disallow access to patient diagnosis\"),\n\tVIEW_ACCESS_LOG(4, \"View patient's record access log\"),\n\tVIEW_RECORDS(5, \"View patient's medical records\"),\n\tAUTHENTICATE_USER(6, \"Authenticate user\"),\n\tENTER_EDIT_PHR(7, \"Enter/Edit Personal Health Information\"),\n\tDOCUMENT_OFFICE_VISIT(8, \"Document an office visit\"),\n\tCREATE_DISABLE_PATIENT_HCP(9, \"Create or disable a patient or hcp\"),\n\tMANAGE_DIAGNOSIS_CODE(10, \"Manage ICD9CM diagnosis codes\"),\n\tREQUEST_BIOSURVEILLANCE(11, \"Request biosurveillance\"),\n\tMANAGE_PROCEDURE_CODE(12, \"Manage CPT Procedure Codes\"),\n\tMANAGE_DRUG_CODE(13, \"Manage ND Drug Codes\"),\n\tIDENTIFY_RISK_FACTORS(14, \"Identify risk factors for chronic diseases\"),\n\tCAUSE_OF_DEATH(15, \"Examine cause-of-death trends\"),\n\tDECLARE_REPRESENTATIVE(16, \"Declare Personal Health Representative\"),\n\tPATIENT_REMINDERS(17, \"Proactively determine necessary patient care\"),\n\tMAINTAIN_HOSPITALS(18, \"Maintain hospital listing\"),\n\tVIEW_PRESCRIPTION_REPORT(19, \"View prescription report\"),\n\tVIEW_HOSPITAL_STATS(20, \"View hospital statistics\"),\n\tVIEW_COMPREHENSIVE_RECORD(21, \"View comprehensive patient report\"),\n\tVIEW_EMERGENCY_REPORT(22, \"View emergency patient report\"),\n\tCOMPREHENSIVE_REPORT_REQUEST(28, \"Comprehensive patient report\"),\n\tVIEW_LAB_PROCEDURE(29, \"View lab procedure\"),\n\tENTER_EDIT_LAB_PROCEDURE(30, \"Enter/Edit lab procedure\"),\n\tMANAGE_LOINC(31, \"Enter/Edit LOINC Code\"),\n\tADD_PATIENT_SURVEY(32, \"Added Patient Survey\"),\n\tView_HCP_SURVEY_RESULTS(33, \"View HCP survey results\"),\n\tVIEW_PATIENT_LIST(34, \"View Patient List\"),\n\tFIND_HCPS_WITH_EXP(35, \"Find LHCPs with experience with a diagnosis\"),\n\tVIEW_HEALTH_RECORDS(36, \"View Patient Health Records\"),\n\tVIEW_OFFICE_VISIT(37, \"View Office Visit\"),\n\tADD_PRESCRIPTION(38, \"Add Prescription\"),\n\tUPDATE_OFFICE_VISIT(39, \"Update an Office Visit\"),\n\tSEND_MESSAGE(40, \"Send a Message\"),\n\tVIEW_RENEWAL_NEEDS_PATIENTS(41, \"View renewal needs patients\"),\n\tSEND_REFERRAL(42, \"Refer patient to hcp\"),\n\tCREATE_DISABLE_ER(43, \"Create/disable emergency responder\"),\n\tTELEMEDICINE_MONITORING(45, \"Telemedicine monitoring\"),\n\tCREATE_DISABLE_PHA(47, \"Create/disable public health agent\"),\n\tDRUG_INTERACTION(48, \"Drug Interaction\"),\n\tADVERSE_EVENT(49, \"Adverse Event Report\"),\n\tLOGIN_FAILURE(50, \"Login Failure\"),\n\tUPDATE_APPT_TYPE(51, \"Update an Appointment Type\"),\n\tADD_APPT_TYPE(52, \"Add an Appointment Type\"),\n\tADD_APPT(53, \"Appointment Added\"),\n\tSEND_REMINDERS(54, \"Reminders Sent\");\n\n\n\t\n\t// S1, S3, S5, S7, S8, S14, S16, S19, S21, S22.\n\tpublic static final String patientViewableStr = \"1,3,5,7,8,14,16,19,21,22,30,39,45\";\n\tpublic static final int[] patientViewable = { 1, 3, 5, 7, 8, 14, 16, 19, 21, 22, 30, 39, 45 };\n\n\tprivate TransactionType(int code, String description) {\n\t\tthis.code = code;\n\t\tthis.description = description;\n\t}\n\n\tprivate int code;\n\tprivate String description;\n\n\tpublic int getCode() {\n\t\treturn code;\n\t}\n\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\n\tpublic static TransactionType parse(int code) {\n\n\t\tfor (TransactionType type : TransactionType.values()) {\n\t\t\tif (type.code == code)\n\t\t\t\treturn type;\n\t\t}\n\t\tthrow new IllegalArgumentException(\"No transaction type exists for code \" + code);\n\t}\n}", "DBException.java": "package edu.ncsu.csc.itrust.exception;\n\nimport java.sql.SQLException;\n\n/**\n * The reasoning behind this wrapper exception is security. When an SQL Exception gets thrown all the way back\n * to the JSP, we begin to reveal details about our database (even knowing that it's MySQL is bad!) So, we\n * make a wrapper exception with a vague description, but we also keep track of the SQL Exception for\n * debugging and testing purposes.\n * \n * @author Andy\n * \n */\npublic class DBException extends iTrustException {\n\tprivate static final long serialVersionUID = -6554118510590118376L;\n\tprivate SQLException sqlException = null;\n\n\tpublic DBException(SQLException e) {\n\t\tsuper(\"A database exception has occurred. Please see the log in the console for stacktrace\");\n\t\tthis.sqlException = e;\n\t}\n\n\t/**\n\t * @return The SQL Exception that was responsible for this error.\n\t */\n\tpublic SQLException getSQLException() {\n\t\treturn sqlException;\n\t}\n\n\t@Override\n\tpublic String getExtendedMessage() {\n\t\tif (sqlException != null)\n\t\t\treturn sqlException.getMessage();\n\t\telse\n\t\t\treturn super.getExtendedMessage();\n\t}\n}", "ErrorList.java": "package edu.ncsu.csc.itrust.exception;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * Used by the validators to create a list of error messages.\n * \n * @author Andy\n * \n */\npublic class ErrorList implements Iterable<String> {\n\tprivate List<String> errorList;\n\n\tpublic ErrorList() {\n\t\terrorList = new ArrayList<String>();\n\t}\n\n\t/**\n\t * Adds a message to the list if it's not a Java null or empty string.\n\t * \n\t * @param errorMessage\n\t */\n\tpublic void addIfNotNull(String errorMessage) {\n\t\tif (errorMessage != null && !\"\".equals(errorMessage))\n\t\t\terrorList.add(errorMessage);\n\t}\n\n\t/**\n\t * Returns the list of error messages\n\t * \n\t * @return\n\t */\n\tpublic List<String> getMessageList() {\n\t\treturn errorList;\n\t}\n\n\t/**\n\t * Returns true if the list has any errors\n\t * \n\t * @return\n\t */\n\tpublic boolean hasErrors() {\n\t\treturn errorList.size() != 0;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn errorList.toString();\n\t}\n\n\tpublic Iterator<String> iterator() {\n\t\treturn errorList.iterator();\n\t}\n}", "FormValidationException.java": "package edu.ncsu.csc.itrust.exception;\n\nimport java.io.IOException;\nimport java.util.List;\nimport javax.servlet.jsp.JspWriter;\n\n/**\n * This exception is used specifically for when an action involves the correct\n * and proper submission of a web form.  Form Validation is handled by a series of\n * other classes, but when form validation is incorrect or incomplete, this exception\n * is thrown. \n */\npublic class FormValidationException extends Exception {\n\tprivate static final long serialVersionUID = 1L;\n\tprivate ErrorList errorList;\n\n\t/**\n\t * Constructor with error messages passed as a list of parameters to the method.\n\t * @param errorMessages The list of error messages to be returned in the special form validation box.\n\t */\n\tpublic FormValidationException(String... errorMessages) {\n\t\terrorList = new ErrorList();\n\t\tfor (String msg : errorMessages) {\n\t\t\terrorList.addIfNotNull(msg);\n\t\t}\n\t}\n\n\t/**\n\t * Constructor with error messages as a special ErrorList data type.\n\t * @param errorList An ErrorList object which contains the list of error messages.\n\t */\n\tpublic FormValidationException(ErrorList errorList) {\n\t\tthis.errorList = errorList;\n\t}\n\n\t/**\n\t * Returns the error list as a java.util.List of Strings.\n\t * @return The error list\n\t */\n\tpublic List<String> getErrorList() {\n\t\treturn errorList.getMessageList();\n\t}\n\n\t/**\n\t * The error message will be displayed at the top of the iTrust page as in other iTrust Exceptions.\n\t */\n\t@Override\n\tpublic String getMessage() {\n\t\treturn \"This form has not been validated correctly. The following field are not properly filled in: \"\n\t\t\t\t+ errorList.toString();\n\t}\n\n\t/**\n\t * The special formatting for error messages is then kept in one place.\n\t * @param out The output writer (in this case a JSPWriter) where the formatted list will go.\n\t * @throws IOException If the writer is incorrect.\n\t */\n\tpublic void printHTML(JspWriter out) throws IOException {\n\t\tout.print(\"<h2>Information not valid</h2><div class=\\\"errorList\\\">\");\n\t\tfor (String errorMessage : errorList) {\n\t\t\tout.print(errorMessage + \"<br />\");\n\t\t}\n\t\tout.print(\"</div>\");\n\t}\n}", "iTrustException.java": "package edu.ncsu.csc.itrust.exception;\n\n/**\n * A specialized exception class for displaying iTrust error messages.\n * This exception is handled by the default iTrust exception handler.\n */\npublic class iTrustException extends Exception {\n\tprivate static final long serialVersionUID = 1L;\n\tString message = null;\n\n\t/**\n\t * The typical constructor.\n\t * @param message A message to be displayed to the screen.\n\t */\n\tpublic iTrustException(String message) {\n\t\tthis.message = message;\n\t}\n\n\t/**\n\t * For messages which are displayed to the user. Usually, this is a very general message for security\n\t * reasons.\n\t */\n\t@Override\n\tpublic String getMessage() {\n\t\tif (message == null)\n\t\t\treturn \"An error has occurred. Please see log for details.\";\n\t\treturn message;\n\t}\n\n\t/**\n\t * For exceptions which show a lot of technical detail, usually delegated to a subclass\n\t * \n\t * @return\n\t */\n\tpublic String getExtendedMessage() {\n\t\treturn \"No extended information.\";\n\t}\n}", "NoHealthRecordsException.java": "package edu.ncsu.csc.itrust.exception;\n\n/**\n * This error message is thrown when checking for health risk indicators and the\n * patient has had no health records entered.  It is a separate case than an iTrustException\n * because the error handling is slightly different. \n */\npublic class NoHealthRecordsException extends iTrustException {\n\n\tpublic static final String MESSAGE = \"The patient did not have any health records recorded. \"\n\t\t\t+ \"No risks can be calculated if no records exist\";\n\n\tprivate static final long serialVersionUID = 7082694071460355325L;\n\n\t/**\n\t * The default constructor, which just passes a pre-specified message to an iTrustException.\n\t */\n\tpublic NoHealthRecordsException() {\n\t\tsuper(MESSAGE);\n\t}\n}", "ChronicDiseaseMediator.java": "package edu.ncsu.csc.itrust.risk;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.NoHealthRecordsException;\n\n/**\n * Figures out which risk checker strategy to use\n * \n * @author Andy\n * \n */\npublic class ChronicDiseaseMediator {\n\tprivate List<RiskChecker> riskCheckers;\n\n\t/**\n\t * Given a factory and patient ID, and sets up a list of all risk checkers\n\t * \n\t * @param factory The DAOFactory to be used in creating the necessary DAOs to perform the checks.\n\t * @param pid The MID of the patient in question.\n\t * @throws DBException\n\t * @throws NoHealthRecordsException\n\t */\n\tpublic ChronicDiseaseMediator(DAOFactory factory, long pid) throws DBException, NoHealthRecordsException {\n\t\triskCheckers = new ArrayList<RiskChecker>();\n\t\triskCheckers.add(new HeartDiseaseRisks(factory, pid));\n\t\triskCheckers.add(new Type1DiabetesRisks(factory, pid));\n\t\triskCheckers.add(new Type2DiabetesRisks(factory, pid));\n\t}\n\n\t/**\n\t * @return A list of diseases that this patient is at risk for\n\t */\n\tpublic List<RiskChecker> getDiseaseAtRisk() {\n\t\tList<RiskChecker> diseases = new ArrayList<RiskChecker>();\n\t\tfor (RiskChecker diseaseChecker : riskCheckers) {\n\t\t\tif (diseaseChecker.isAtRisk())\n\t\t\t\tdiseases.add(diseaseChecker);\n\t\t}\n\t\treturn diseases;\n\t}\n}", "HeartDiseaseRisks.java": "package edu.ncsu.csc.itrust.risk;\n\nimport static edu.ncsu.csc.itrust.enums.Ethnicity.AfricanAmerican;\nimport static edu.ncsu.csc.itrust.enums.Ethnicity.AmericanIndian;\nimport static edu.ncsu.csc.itrust.enums.Ethnicity.Hispanic;\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.enums.Gender;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.NoHealthRecordsException;\nimport edu.ncsu.csc.itrust.risk.factors.AgeFactor;\nimport edu.ncsu.csc.itrust.risk.factors.CholesterolFactor;\nimport edu.ncsu.csc.itrust.risk.factors.EthnicityFactor;\nimport edu.ncsu.csc.itrust.risk.factors.FamilyHistoryFactor;\nimport edu.ncsu.csc.itrust.risk.factors.GenderFactor;\nimport edu.ncsu.csc.itrust.risk.factors.HypertensionFactor;\nimport edu.ncsu.csc.itrust.risk.factors.PatientRiskFactor;\nimport edu.ncsu.csc.itrust.risk.factors.PriorDiagnosisFactor;\nimport edu.ncsu.csc.itrust.risk.factors.SmokingFactor;\nimport edu.ncsu.csc.itrust.risk.factors.WeightFactor;\n\n/**\n * Checks to see if the given patient is at risk for Heart Disease\n * For details on what each method does, see {@link RiskChecker}\n * @author Andy\n * \n */\npublic class HeartDiseaseRisks extends RiskChecker {\n\tpublic HeartDiseaseRisks(DAOFactory factory, long patientID) throws DBException, NoHealthRecordsException {\n\t\tsuper(factory, patientID);\n\t}\n\n\t@Override\n\tpublic boolean qualifiesForDisease() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tprotected List<PatientRiskFactor> getDiseaseRiskFactors() {\n\t\tList<PatientRiskFactor> factors = new ArrayList<PatientRiskFactor>();\n\t\tfactors.add(new GenderFactor(patient, Gender.Male));\n\t\tfactors.add(new AgeFactor(patient, 45));\n\t\tfactors.add(new EthnicityFactor(patient, Hispanic, AfricanAmerican, AmericanIndian));\n\t\tfactors.add(new WeightFactor(currentHealthRecord, 30));\n\t\tfactors.add(new HypertensionFactor(currentHealthRecord));\n\t\tfactors.add(new CholesterolFactor(currentHealthRecord));\n\t\tfactors.add(new SmokingFactor(factory, patient.getMID()));\n\t\tfactors.add(new PriorDiagnosisFactor(factory, patient.getMID(), 250.0, 251.0));\n\t\tfactors.add(new FamilyHistoryFactor(factory, patient.getMID(), 350.0, 460.0));\n\t\treturn factors;\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn \"Heart Disease\";\n\t}\n}", "RiskChecker.java": "package edu.ncsu.csc.itrust.risk;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.beans.HealthRecord;\nimport edu.ncsu.csc.itrust.beans.PatientBean;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.dao.mysql.HealthRecordsDAO;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.NoHealthRecordsException;\nimport edu.ncsu.csc.itrust.risk.factors.PatientRiskFactor;\n\n/**\n * An abstract class which has a number of utlity methods for checking risks.\n * \n * When extending this class, use the methods to fill in all of the necessary information. Then use isAtRisk\n * and getPatientRiskFactors to get the actual risks. See the known subclasses for an example\n * \n * @author Andy\n * \n */\nabstract public class RiskChecker {\n\tprivate static final int RISK_THRESHOLD = 3;\n\tprotected PatientBean patient;\n\tprotected HealthRecord currentHealthRecord;\n\tprotected DAOFactory factory;\n\n\tpublic RiskChecker(DAOFactory factory, long patientID) throws DBException, NoHealthRecordsException {\n\t\tthis.factory = factory;\n\t\tHealthRecordsDAO hrDAO = factory.getHealthRecordsDAO();\n\t\tList<HealthRecord> records = hrDAO.getAllHealthRecords(patientID);\n\t\tif (records.size() > 0)\n\t\t\tcurrentHealthRecord = records.get(0);\n\t\telse\n\t\t\tthrow new NoHealthRecordsException();\n\n\t\tpatient = factory.getPatientDAO().getPatient(patientID);\n\t}\n\n\t/**\n\t * @return The name of the disease being checked.\n\t */\n\tabstract public String getName();\n\n\t/**\n\t * @return A java.util.List of the risk factors increasing this patients disease risk.\n\t */\n\tabstract protected List<PatientRiskFactor> getDiseaseRiskFactors();\n\n\t/**\n\t * @return A boolean indicating whether the patient is at increased risk.\n\t */\n\tabstract public boolean qualifiesForDisease();\n\n\t/**\n\t * This method exists purely for performance - just stop once you hit the threshold. <br />\n\t * <br />\n\t * Also, the risk factors should be cached in the RiskFactor implementors - in getPatientRiskFactors there\n\t * should be no double-querying\n\t * \n\t * @return isAtRisk\n\t */\n\tpublic boolean isAtRisk() {\n\t\tif (qualifiesForDisease()) {\n\t\t\tint numRisks = 0;\n\t\t\tList<PatientRiskFactor> diseaseRiskFactors = getDiseaseRiskFactors();\n\t\t\tfor (PatientRiskFactor factor : diseaseRiskFactors) {\n\t\t\t\tif (factor.hasRiskFactor())\n\t\t\t\t\tnumRisks++;\n\t\t\t\tif (numRisks >= RISK_THRESHOLD)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false; // both an else from qualifies or NOT over the threshold\n\t}\n\n\t/**\n\t * @return A java.util.List of patient risk factors associated with this disease.\n\t */\n\tpublic List<PatientRiskFactor> getPatientRiskFactors() {\n\t\tList<PatientRiskFactor> patientRiskFactors = new ArrayList<PatientRiskFactor>();\n\t\tList<PatientRiskFactor> diseaseRiskFactors = getDiseaseRiskFactors();\n\t\tfor (PatientRiskFactor factor : diseaseRiskFactors) {\n\t\t\tif (factor.hasRiskFactor()) {\n\t\t\t\tpatientRiskFactors.add(factor);\n\t\t\t}\n\t\t}\n\t\treturn patientRiskFactors;\n\t}\n}", "Type1DiabetesRisks.java": "package edu.ncsu.csc.itrust.risk;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.enums.Ethnicity;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.NoHealthRecordsException;\nimport edu.ncsu.csc.itrust.risk.factors.ChildhoodInfectionFactor;\nimport edu.ncsu.csc.itrust.risk.factors.EthnicityFactor;\nimport edu.ncsu.csc.itrust.risk.factors.FamilyHistoryFactor;\nimport edu.ncsu.csc.itrust.risk.factors.PatientRiskFactor;\n\n/**\n * Checks to see if the given patient is at risk for Type 1 Diabetes.\n * For details on what each method does, see {@link RiskChecker}\n * \n * @author Andy\n * \n */\npublic class Type1DiabetesRisks extends RiskChecker {\n\tpublic Type1DiabetesRisks(DAOFactory factory, long patientID) throws DBException,\n\t\t\tNoHealthRecordsException {\n\t\tsuper(factory, patientID);\n\t}\n\n\t@Override\n\tpublic boolean qualifiesForDisease() {\n\t\treturn patient.getAge() < 12;\n\t}\n\n\t@Override\n\tprotected List<PatientRiskFactor> getDiseaseRiskFactors() {\n\t\tList<PatientRiskFactor> factors = new ArrayList<PatientRiskFactor>();\n\t\tfactors.add(new EthnicityFactor(patient, Ethnicity.Caucasian));\n\t\tfactors.add(new FamilyHistoryFactor(factory, patient.getMID(), 250.0, 251.0));\n\t\tfactors.add(new ChildhoodInfectionFactor(factory, patient.getMID(), 79.30));\n\t\treturn factors;\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn \"Type 1 Diabetes\";\n\t}\n}", "Type2DiabetesRisks.java": "package edu.ncsu.csc.itrust.risk;\n\nimport static edu.ncsu.csc.itrust.enums.Ethnicity.AfricanAmerican;\nimport static edu.ncsu.csc.itrust.enums.Ethnicity.AmericanIndian;\nimport static edu.ncsu.csc.itrust.enums.Ethnicity.Asian;\nimport static edu.ncsu.csc.itrust.enums.Ethnicity.Hispanic;\nimport java.util.ArrayList;\nimport java.util.List;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\nimport edu.ncsu.csc.itrust.exception.NoHealthRecordsException;\nimport edu.ncsu.csc.itrust.risk.factors.AgeFactor;\nimport edu.ncsu.csc.itrust.risk.factors.CholesterolFactor;\nimport edu.ncsu.csc.itrust.risk.factors.EthnicityFactor;\nimport edu.ncsu.csc.itrust.risk.factors.FamilyHistoryFactor;\nimport edu.ncsu.csc.itrust.risk.factors.HypertensionFactor;\nimport edu.ncsu.csc.itrust.risk.factors.PatientRiskFactor;\nimport edu.ncsu.csc.itrust.risk.factors.PriorDiagnosisFactor;\nimport edu.ncsu.csc.itrust.risk.factors.WeightFactor;\n\n/**\n * Checks to see if the given patient is at risk for Type II Diabetes.\n * For details on what each method does, see {@link RiskChecker}\n * \n * @author Andy\n * \n */\npublic class Type2DiabetesRisks extends RiskChecker {\n\tpublic Type2DiabetesRisks(DAOFactory factory, long patientID) throws DBException,\n\t\t\tNoHealthRecordsException {\n\t\tsuper(factory, patientID);\n\t}\n\n\t@Override\n\tpublic boolean qualifiesForDisease() {\n\t\treturn patient.getAge() >= 12;\n\t}\n\n\t@Override\n\tprotected List<PatientRiskFactor> getDiseaseRiskFactors() {\n\t\tList<PatientRiskFactor> factors = new ArrayList<PatientRiskFactor>();\n\t\tfactors.add(new AgeFactor(patient, 45));\n\t\tfactors.add(new EthnicityFactor(patient, Hispanic, AfricanAmerican, AmericanIndian, Asian));\n\t\tfactors.add(new WeightFactor(currentHealthRecord, 25));\n\t\tfactors.add(new HypertensionFactor(currentHealthRecord));\n\t\tfactors.add(new CholesterolFactor(currentHealthRecord));\n\t\tfactors.add(new PriorDiagnosisFactor(factory, patient.getMID(), 250.0, 251.0));\n\t\tfactors.add(new FamilyHistoryFactor(factory, patient.getMID(), 250.0, 251.0));\n\t\treturn factors;\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn \"Type 2 Diabetes\";\n\t}\n}", "AgeFactor.java": "package edu.ncsu.csc.itrust.risk.factors;\n\nimport edu.ncsu.csc.itrust.beans.PatientBean;\n\n/**\n * The risk factor associated with checking if a person is over a particular age\n * See {@link PatientRiskFactor} for details on what each method typically does.\n * @author Andy\n */\npublic class AgeFactor extends PatientRiskFactor {\n\tprivate PatientBean patient;\n\tprivate int age;\n\n\tpublic AgeFactor(PatientBean patient, int age) {\n\t\tthis.age = age;\n\t\tthis.patient = patient;\n\t}\n\n\tpublic String getDescription() {\n\t\treturn \"Patient is over \" + age;\n\t}\n\n\tpublic boolean hasFactor() {\n\t\treturn patient.getAge() > age;\n\t}\n}", "ChildhoodInfectionFactor.java": "package edu.ncsu.csc.itrust.risk.factors;\n\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\n\n/**\n * Checks if the patient had the given diagnoses during childhood.\n * See {@link PatientRiskFactor} for details on what each method typically does.\n * \n * @author Andy\n * \n */\npublic class ChildhoodInfectionFactor extends PatientRiskFactor {\n\tprivate final double[] icdCodes;\n\tprivate final long patientID;\n\tprivate final DAOFactory factory;\n\n\tpublic ChildhoodInfectionFactor(DAOFactory factory, long mid, double... icdCodes) {\n\t\tthis.factory = factory;\n\t\tthis.patientID = mid;\n\t\tthis.icdCodes = icdCodes.clone();\n\t}\n\n\tpublic String getDescription() {\n\t\treturn \"This patient had a viral infection during their childhood that would increase the risk for this diesease\";\n\t}\n\n\tpublic boolean hasFactor() {\n\t\ttry {\n\t\t\treturn factory.getRiskDAO().hadChildhoodInfection(patientID, icdCodes);\n\t\t} catch (DBException e) {\n\t\t\tSystem.err.println(\"DBException on Childhood Infection Risk, giving no risk\");\n\t\t\treturn false;\n\t\t}\n\t}\n}", "CholesterolFactor.java": "package edu.ncsu.csc.itrust.risk.factors;\n\nimport edu.ncsu.csc.itrust.beans.HealthRecord;\n\n/**\n * Checks if cholesterol is over a given threshold for a given patient\n * See {@link PatientRiskFactor} for details on what each method typically does.\n * \n * @author Andy\n * \n */\npublic class CholesterolFactor extends PatientRiskFactor {\n\tprivate static final int hdlThreshold = 35;\n\tprivate static final int ldlThreshold = 240;\n\tprivate static final int triThreshold = 250;\n\tprivate HealthRecord record;\n\n\tpublic CholesterolFactor(HealthRecord currentHealthRecord) {\n\t\tthis.record = currentHealthRecord;\n\t}\n\n\tpublic String getDescription() {\n\t\treturn \"Patient has bad cholesterol\";\n\t}\n\n\tpublic boolean hasFactor() {\n\t\treturn (record.getCholesterolHDL() < hdlThreshold) || (record.getCholesterolLDL() > ldlThreshold)\n\t\t\t\t|| (record.getCholesterolTri() > triThreshold);\n\t}\n}", "EthnicityFactor.java": "package edu.ncsu.csc.itrust.risk.factors;\n\nimport edu.ncsu.csc.itrust.beans.PatientBean;\nimport edu.ncsu.csc.itrust.enums.Ethnicity;\n\n/**\n * Checks if the ethnicity of a patient matches the one at risk\n * See {@link PatientRiskFactor} for details on what each method typically does.\n * \n * @author Andy\n * \n */\npublic class EthnicityFactor extends PatientRiskFactor {\n\tprivate Ethnicity[] atRisk;\n\tprivate PatientBean patient;\n\n\tpublic EthnicityFactor(PatientBean patient, Ethnicity... atRisks) {\n\t\tthis.atRisk = atRisks.clone();\n\t\tthis.patient = patient;\n\t}\n\n\tpublic String getDescription() {\n\t\treturn \"Patient's ethnicity is \" + patient.getEthnicity();\n\t}\n\n\tpublic boolean hasFactor() {\n\t\tfor (Ethnicity ethnicity : atRisk) {\n\t\t\tif (patient.getEthnicity().equals(ethnicity) && !Ethnicity.NotSpecified.equals(ethnicity))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}", "FamilyHistoryFactor.java": "package edu.ncsu.csc.itrust.risk.factors;\n\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\n\n/**\n * Checks if a patient has a family history of a given diagnosis range. Delegates straight to the DAO.\n * See {@link PatientRiskFactor} for details on what each method typically does.\n * \n * @author Andy\n * \n */\npublic class FamilyHistoryFactor extends PatientRiskFactor {\n\tprivate long patientID;\n\tprivate DAOFactory factory;\n\tprivate double icdUpper;\n\tprivate double icdLower;\n\n\tpublic FamilyHistoryFactor(DAOFactory factory, long patientID, double icdLower, double icdUpper) {\n\t\tthis.factory = factory;\n\t\tthis.patientID = patientID;\n\t\tthis.icdLower = icdLower;\n\t\tthis.icdUpper = icdUpper;\n\t}\n\n\tpublic String getDescription() {\n\t\treturn \"Patient has a family history of this disease\";\n\t}\n\n\tpublic boolean hasFactor() {\n\t\ttry {\n\t\t\treturn factory.getRiskDAO().hasFamilyHistory(patientID, icdLower, icdUpper);\n\t\t} catch (DBException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn false;\n\t\t}\n\t}\n}", "GenderFactor.java": "package edu.ncsu.csc.itrust.risk.factors;\n\nimport edu.ncsu.csc.itrust.beans.PatientBean;\nimport edu.ncsu.csc.itrust.enums.Gender;\n\n/**\n * Checks if the patient's gender matches the given at-risk one.\n * See {@link PatientRiskFactor} for details on what each method typically does.\n * \n * @author Andy\n * \n */\npublic class GenderFactor extends PatientRiskFactor {\n\tprivate PatientBean patient;\n\tprivate Gender gender;\n\n\tpublic GenderFactor(PatientBean patient, Gender gender) {\n\t\tthis.patient = patient;\n\t\tthis.gender = gender;\n\t}\n\n\tpublic String getDescription() {\n\t\treturn \"Patient is \" + patient.getGender().toString().toLowerCase();\n\t}\n\n\tpublic boolean hasFactor() {\n\t\treturn gender.equals(patient.getGender()) && !gender.equals(Gender.NotSpecified);\n\t}\n}", "HypertensionFactor.java": "package edu.ncsu.csc.itrust.risk.factors;\n\nimport edu.ncsu.csc.itrust.beans.HealthRecord;\n\n/**\n * Checks if the patient's blood pressure is above a given threshold.\n * See {@link PatientRiskFactor} for details on what each method typically does.\n * \n * @author Andy\n * \n */\npublic class HypertensionFactor extends PatientRiskFactor {\n\tprivate static final int systolicThreshold = 240;\n\tprivate static final int diastolicThreshold = 120;\n\tprivate HealthRecord record;\n\n\tpublic HypertensionFactor(HealthRecord currentHealthRecord) {\n\t\tthis.record = currentHealthRecord;\n\t}\n\n\tpublic String getDescription() {\n\t\treturn \"Patient has hypertension\";\n\t}\n\n\tpublic boolean hasFactor() {\n\t\treturn (record.getBloodPressureSystolic() > systolicThreshold)\n\t\t\t\t|| (record.getBloodPressureDiastolic() > diastolicThreshold);\n\t}\n}", "PatientRiskFactor.java": "package edu.ncsu.csc.itrust.risk.factors;\n\n/**\n * Abstract class for risk factors, the hasRiskFactor delegates to the protected version. Caches the result in\n * case it gets checked more than once.\n * \n * @author Andy\n * \n */\nabstract public class PatientRiskFactor {\n\tprivate Boolean hasRisk = null;\n\n\t/**\n\t * @return A textual description of what the patient's status is that's causing the risk.\n\t */\n\tabstract public String getDescription();\n\n\t/**\n\t * @return A boolean indicating whether the patient has the increased risk.\n\t */\n\tabstract protected boolean hasFactor();\n\n\t/**\n\t * @return A boolean indicating whether the patient has the increased risk.\n\t */\n\tpublic boolean hasRiskFactor() {\n\t\tif (hasRisk == null)\n\t\t\thasRisk = hasFactor();\n\t\treturn hasRisk;\n\t}\n}", "PriorDiagnosisFactor.java": "package edu.ncsu.csc.itrust.risk.factors;\n\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\n\n/**\n * Checks for prior diagnoses by delegatin to the DAO\n * See {@link PatientRiskFactor} for details on what each method typically does.\n * \n * @author Andy\n * \n */\npublic class PriorDiagnosisFactor extends PatientRiskFactor {\n\tprivate long patientID;\n\tprivate DAOFactory factory;\n\tprivate double lowerICDCode;\n\tprivate double upperICDCode;\n\n\tpublic PriorDiagnosisFactor(DAOFactory factory, long patientID, double lowerICDCode, double upperICDCode) {\n\t\tthis.factory = factory;\n\t\tthis.patientID = patientID;\n\t\tthis.lowerICDCode = lowerICDCode;\n\t\tthis.upperICDCode = upperICDCode;\n\t}\n\n\tpublic String getDescription() {\n\t\treturn \"Patient has had related diagnoses\";\n\t}\n\n\tpublic boolean hasFactor() {\n\t\ttry {\n\t\t\treturn factory.getRiskDAO().hadPriorDiagnoses(patientID, lowerICDCode, upperICDCode);\n\t\t} catch (DBException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn false;\n\t\t}\n\t}\n}", "SmokingFactor.java": "package edu.ncsu.csc.itrust.risk.factors;\n\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\n\n/**\n * Risk factor delegates to the DAO to see if a patient has ever smoked in their life\n * See {@link PatientRiskFactor} for details on what each method typically does.\n * \n * @author Andy\n * \n */\npublic class SmokingFactor extends PatientRiskFactor {\n\tprivate long patientID;\n\tprivate DAOFactory factory;\n\n\tpublic SmokingFactor(DAOFactory factory, long patientID) {\n\t\tthis.factory = factory;\n\t\tthis.patientID = patientID;\n\t}\n\n\tpublic String getDescription() {\n\t\treturn \"Patient is or was a smoker\";\n\t}\n\n\tpublic boolean hasFactor() {\n\t\ttry {\n\t\t\treturn factory.getRiskDAO().hasSmoked(patientID);\n\t\t} catch (DBException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn false;\n\t\t}\n\t}\n}", "WeightFactor.java": "package edu.ncsu.csc.itrust.risk.factors;\n\nimport edu.ncsu.csc.itrust.beans.HealthRecord;\n\n/**\n * Checks the patient's body mass index over the given threshold\n * See {@link PatientRiskFactor} for details on what each method typically does.\n * \n * @author Andy\n * \n */\npublic class WeightFactor extends PatientRiskFactor {\n\tprivate HealthRecord currentHealthRecord;\n\tprivate int bmiThreshold;\n\n\tpublic WeightFactor(HealthRecord currentHealthRecord, int bmiThreshold) {\n\t\tthis.currentHealthRecord = currentHealthRecord;\n\t\tthis.bmiThreshold = bmiThreshold;\n\t}\n\n\tpublic String getDescription() {\n\t\treturn \"Patient's body mass index is over \" + bmiThreshold;\n\t}\n\n\tpublic boolean hasFactor() {\n\t\tdouble bmi = currentHealthRecord.getBodyMassIndex();\n\t\treturn bmi > bmiThreshold && !Double.isInfinite(bmi);\n\t}\n}", "SessionTimeoutListener.java": "package edu.ncsu.csc.itrust.server;\n\nimport javax.servlet.http.HttpSession;\nimport javax.servlet.http.HttpSessionEvent;\nimport javax.servlet.http.HttpSessionListener;\nimport edu.ncsu.csc.itrust.dao.DAOFactory;\nimport edu.ncsu.csc.itrust.exception.DBException;\n\n/**\n * A listener which will time the user out after a pre-specified time limit. \n */\npublic class SessionTimeoutListener implements HttpSessionListener {\n\tprivate DAOFactory factory;\n\n\t/**\n\t * The default constructor.\n\t */\n\tpublic SessionTimeoutListener() {\n\t\tthis.factory = DAOFactory.getProductionInstance();\n\t}\n\n\t/**\n\t * The specialized constructor, which takes a particular DAOFactory to be used when checking for the pre-specified\n\t * timeout limit.\n\t * @param factory The DAOFactory to be used.\n\t */\n\tpublic SessionTimeoutListener(DAOFactory factory) {\n\t\tthis.factory = factory;\n\t}\n\n\t/**\n\t * Called when the HttpSession is created, this method pulls the pre-specified limit from the\n\t * database and sets it as a property of the HttpSession.\n\t * @param arg0 The HttpSessionEven which just occurred.\n\t */\n\tpublic void sessionCreated(HttpSessionEvent arg0) {\n\t\tHttpSession session = arg0.getSession();\n\t\tint mins = 20;\n\t\ttry {\n\t\t\tmins = factory.getAccessDAO().getSessionTimeoutMins();\n\t\t} catch (DBException e) {\n\t\t\tSystem.err.println(\"Unable to set session timeout, defaulting to 20 minutes\");\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (mins < 1)\n\t\t\tmins = 1;\n\t\tsession.setMaxInactiveInterval(mins * 60);\n\t}\n\n\t/**\n\t * Must be declared for compliance with the interface. Not implemented.\n\t */\n\tpublic void sessionDestroyed(HttpSessionEvent arg0) {\n\t\t// nothing to do here\n\t}\n}", "ICD9CMLink.java": "package edu.ncsu.csc.itrust.tags;\n\nimport java.io.IOException;\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.JspWriter;\nimport javax.servlet.jsp.PageContext;\nimport javax.servlet.jsp.tagext.Tag;\n\n/**\n * JSP tag used as a utility to link to the actual ICD9CM site\n * \n * @author Andy\n * \n */\npublic class ICD9CMLink implements Tag {\n\tprivate PageContext pageContext;\n\tprivate Tag parent;\n\tprivate String code;\n\n\tpublic ICD9CMLink() {\n\t\tsuper();\n\t}\n\n\tpublic int doStartTag() throws JspException {\n\t\ttry {\n\t\t\tJspWriter out = pageContext.getOut();\n\t\t\tout.write(\"<a href=\\\"http://icd9cm.chrisendres.com/2007/index.php?srchtype=diseases&srchtext=\"\n\t\t\t\t\t+ code + \"&Submit=Search&action=search\\\">\" + code + \"</a>\");\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn SKIP_BODY;\n\t}\n\n\tpublic int doEndTag() throws JspException {\n\t\treturn SKIP_BODY;\n\t}\n\n\tpublic void release() {\n\t}\n\n\tpublic void setPageContext(PageContext pageContext) {\n\t\tthis.pageContext = pageContext;\n\t}\n\n\tpublic void setParent(Tag parent) {\n\t\tthis.parent = parent;\n\t}\n\n\tpublic Tag getParent() {\n\t\treturn parent;\n\t}\n\n\tpublic String getCode() {\n\t\treturn code;\n\t}\n\n\tpublic void setCode(String code) {\n\t\tthis.code = code;\n\t}\n\n\tpublic void setCode(double code) {\n\t\tthis.code = String.valueOf(code);\n\t}\n}", "PatientNavigation.java": "package edu.ncsu.csc.itrust.tags;\n\nimport java.io.IOException;\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.JspWriter;\nimport javax.servlet.jsp.PageContext;\nimport javax.servlet.jsp.tagext.Tag;\n\n/**\n * JSP tag that is used as the patient navigation bar at the bottom of the screen.\n * \n * To add a new page, add to the two arrays, and make sure that the page accepts PID\n * \n * @author Andy\n * \n */\npublic class PatientNavigation implements Tag {\n\tprivate PageContext pageContext;\n\tprivate Tag parent;\n\t// A more elegant solution here would be to use enums and have a displayName, a name, and url\n\tprivate String pageTitles[] = { \"Health Records\", \"Basic Health History\", \"Demographics\",\n\t\t\t\"Document Office Visit\", \"Risk Factors\", \"Prescriptions\" };\n\tprivate String pageURLs[] = { \"editPHR.jsp\", \"editBasicHealth.jsp\", \"editPatient.jsp\",\n\t\t\t\"documentOfficeVisit.jsp\", \"chronicDiseaseRisks.jsp\", \"getPrescriptionReport.jsp\" };\n\tprivate String thisTitle;\n\n\tpublic PatientNavigation() {\n\t\tsuper();\n\t}\n\n\tpublic int doStartTag() throws JspException {\n\t\ttry {\n\t\t\tJspWriter out = pageContext.getOut();\n\t\t\tout.write(\"<span class=\\\"navigation\\\">\");\n\t\t\tfor (int i = 0; i < pageTitles.length; i++) {\n\t\t\t\tif (pageTitles[i].equals(thisTitle)) {\n\t\t\t\t\tout.write(pageTitles[i]);\n\t\t\t\t} else\n\t\t\t\t\tout.write(\"<a href=\\\"/iTrust/auth/hcp-uap/\" + pageURLs[i] + \"\\\">\"\n\t\t\t\t\t\t\t+ pageTitles[i] + \"</a>\");\n\t\t\t\tout.write(\" | \");\n\t\t\t}\n\t\t\tout.write(\"<a href=\\\"/iTrust/auth/hcp-uap/editPHR.jsp?switch=true\\\">Switch Patient</a>\");\n\t\t\tout.write(\"<br /></span>\");\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn SKIP_BODY;\n\t}\n\n\tpublic int doEndTag() throws JspException {\n\t\treturn SKIP_BODY;\n\t}\n\n\tpublic void release() {\n\t}\n\n\tpublic void setPageContext(PageContext pageContext) {\n\t\tthis.pageContext = pageContext;\n\t}\n\n\tpublic void setParent(Tag parent) {\n\t\tthis.parent = parent;\n\t}\n\n\tpublic Tag getParent() {\n\t\treturn parent;\n\t}\n\n\tpublic String getThisTitle() {\n\t\treturn thisTitle;\n\t}\n\n\tpublic void setThisTitle(String thisPage) {\n\t\tthis.thisTitle = thisPage;\n\t}\n}", "StateSelect.java": "package edu.ncsu.csc.itrust.tags;\n\nimport java.io.IOException;\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.JspWriter;\nimport javax.servlet.jsp.PageContext;\nimport javax.servlet.jsp.tagext.Tag;\nimport edu.ncsu.csc.itrust.enums.State;\n\n/**\n * JSP tag that adds an HTML select for states, from the enum.\n * \n * @see {@link State}\n * \n * Also selects the current state\n * @author Andy\n * \n */\npublic class StateSelect implements Tag {\n\tprivate PageContext pageContext;\n\tprivate Tag parent;\n\tprivate String name;\n\tprivate String value;\n\n\tpublic StateSelect() {\n\t\tsuper();\n\t}\n\n\tpublic int doStartTag() throws JspException {\n\t\ttry {\n\t\t\tJspWriter out = pageContext.getOut();\n\t\t\tout.write(\"<select name=\\\"\" + getName() + \"\\\" >\");\n\t\t\tif (name == null || \"\".equals(name))\n\t\t\t\tout.write(\"<option value=\\\"\\\">Select State</option>\");\n\t\t\tfor (State state : State.values()) {\n\t\t\t\tString selected = state.toString().equals(getValue()) ? \"selected=selected\" : \"\";\n\t\t\t\tout.write(\"<option value=\\\"\" + state.toString() + \"\\\" \" + selected + \">\" + state.getName()\n\t\t\t\t\t\t+ \"</option>\");\n\t\t\t}\n\t\t\tout.write(\"</select>\");\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn SKIP_BODY;\n\t}\n\n\tpublic int doEndTag() throws JspException {\n\t\treturn SKIP_BODY;\n\t}\n\n\tpublic void release() {\n\t}\n\n\tpublic void setPageContext(PageContext pageContext) {\n\t\tthis.pageContext = pageContext;\n\t}\n\n\tpublic void setParent(Tag parent) {\n\t\tthis.parent = parent;\n\t}\n\n\tpublic Tag getParent() {\n\t\treturn parent;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic String getValue() {\n\t\treturn value;\n\t}\n\n\tpublic void setValue(String value) {\n\t\tthis.value = value;\n\t}\n}", "AddPatientValidator.java": "package edu.ncsu.csc.itrust.validate;\n\nimport edu.ncsu.csc.itrust.action.AddPatientAction;\nimport edu.ncsu.csc.itrust.beans.PatientBean;\nimport edu.ncsu.csc.itrust.exception.ErrorList;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\n\n/**\n * The validator used by {@link AddPatientAction}. Only checks first name, last name, and email\n * \n * @author Andy\n * \n */\npublic class AddPatientValidator extends BeanValidator<PatientBean> {\n\t/**\n\t * The default constructor.\n\t */\n\tpublic AddPatientValidator() {\n\t}\n\n\t/**\n\t * Performs the act of validating the bean in question, which varies depending on the\n\t * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.\n\t * \n\t * @param p A bean of the type to be validated.\n\t */\n\t@Override\n\tpublic void validate(PatientBean p) throws FormValidationException {\n\t\tErrorList errorList = new ErrorList();\n\t\terrorList.addIfNotNull(checkFormat(\"First name\", p.getFirstName(), ValidationFormat.NAME, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Last name\", p.getLastName(), ValidationFormat.NAME, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Email\", p.getEmail(), ValidationFormat.EMAIL, false));\n\t\tif (errorList.hasErrors())\n\t\t\tthrow new FormValidationException(errorList);\n\t}\n\t\n}", "AddPersonnelValidator.java": "package edu.ncsu.csc.itrust.validate;\n\nimport edu.ncsu.csc.itrust.action.AddPatientAction;\nimport edu.ncsu.csc.itrust.beans.PersonnelBean;\nimport edu.ncsu.csc.itrust.exception.ErrorList;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\n\n/**\n * The validator used by {@link AddPatientAction}. Only checks first name, last name, and email\n * \n * @author Andy\n * \n */\npublic class AddPersonnelValidator extends BeanValidator<PersonnelBean> {\n\t\n\t/**\n\t * The default constructor.\n\t */\n\tpublic AddPersonnelValidator() {\n\t}\n\n\t/**\n\t * Performs the act of validating the bean in question, which varies depending on the\n\t * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.\n\t * \n\t * @param p A bean of the type to be validated.\n\t */\n\t@Override\n\tpublic void validate(PersonnelBean p) throws FormValidationException {\n\t\tErrorList errorList = new ErrorList();\n\t\terrorList.addIfNotNull(checkFormat(\"First name\", p.getFirstName(), ValidationFormat.NAME, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Last name\", p.getLastName(), ValidationFormat.NAME, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Email\", p.getEmail(), ValidationFormat.EMAIL, false));\n\t\tif (errorList.hasErrors())\n\t\t\tthrow new FormValidationException(errorList);\n\t}\n}", "AdverseEventValidator.java": "package edu.ncsu.csc.itrust.validate;\n\nimport edu.ncsu.csc.itrust.beans.AdverseEventBean;\nimport edu.ncsu.csc.itrust.exception.ErrorList;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\n\n/**\n * Validates an adverse event bean, from {@link AdverseEventAction}\n * \n */\npublic class AdverseEventValidator extends BeanValidator<AdverseEventBean> {\n\t/**\n\t * The default constructor.\n\t */\n\tpublic AdverseEventValidator() {\n\t}\n\n\t/**\n\t * Performs the act of validating the bean in question, which varies depending on the\n\t * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.\n\t * \n\t * @param d A bean of the type to be validated.\n\t */\n\t@Override\n\tpublic void validate(AdverseEventBean b) throws FormValidationException {\n\t\tErrorList errorList = new ErrorList();errorList.addIfNotNull(checkFormat(\"comment\", b.getDescription(), ValidationFormat.ADVERSE_EVENT_COMMENTS,false));\n\t\tif (errorList.hasErrors())\n\t\t\tthrow new FormValidationException(errorList);\n\t}\n}", "AllergyBeanValidator.java": "package edu.ncsu.csc.itrust.validate;\n\nimport edu.ncsu.csc.itrust.action.EditOfficeVisitAction;\nimport edu.ncsu.csc.itrust.beans.AllergyBean;\nimport edu.ncsu.csc.itrust.exception.ErrorList;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\n\n/**\n * Validator used to validate adding a new allergy in {@link EditOfficeVisitAction}\n * \n * @author Andy\n * \n */\npublic class AllergyBeanValidator extends BeanValidator<AllergyBean> {\n\t/**\n\t * The default constructor.\n\t */\n\tpublic AllergyBeanValidator() {\n\t}\n\t\n\t/**\n\t * Performs the act of validating the bean in question, which varies depending on the\n\t * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.\n\t * \n\t * @param p A bean of the type to be validated.\n\t */\n\t@Override\n\tpublic void validate(AllergyBean m) throws FormValidationException {\n\t\tErrorList errorList = new ErrorList();\n\t\terrorList.addIfNotNull(checkFormat(\"Allergy Description\", m.getDescription(),\n\t\t\t\tValidationFormat.ALLERGY_DESCRIPTION, false));\n\t\tif (errorList.hasErrors())\n\t\t\tthrow new FormValidationException(errorList);\n\t}\n}", "ApptBeanValidator.java": "package edu.ncsu.csc.itrust.validate;\n\nimport edu.ncsu.csc.itrust.beans.ApptBean;\nimport edu.ncsu.csc.itrust.exception.ErrorList;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\n\npublic class ApptBeanValidator extends BeanValidator<ApptBean>{\n\n\tpublic void validate(ApptBean bean) throws FormValidationException {\n\t\tErrorList errorList = new ErrorList();\n\t\tif(bean.getComment() == null)\n\t\t\treturn;\n\t\terrorList.addIfNotNull(checkFormat(\"Appointment Comment\", bean.getComment(), ValidationFormat.APPT_COMMENT, false));\n\t\tif (errorList.hasErrors())\n\t\t\tthrow new FormValidationException(errorList);\n\t}\n\n}", "ApptTypeBeanValidator.java": "package edu.ncsu.csc.itrust.validate;\n\nimport edu.ncsu.csc.itrust.beans.ApptTypeBean;\nimport edu.ncsu.csc.itrust.exception.ErrorList;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\n\npublic class ApptTypeBeanValidator extends BeanValidator<ApptTypeBean> {\n\n\t@Override\n\tpublic void validate(ApptTypeBean a) throws FormValidationException {\n\t\tErrorList errorList = new ErrorList();\n\t\terrorList.addIfNotNull(checkFormat(\"Appointment Type Name\", a.getName(), ValidationFormat.APPT_TYPE_NAME, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Appointment Type Duration\", a.getDuration()+\"\", ValidationFormat.APPT_TYPE_DURATION, false));\n\t\tif (errorList.hasErrors())\n\t\t\tthrow new FormValidationException(errorList);\n\t}\n\n}", "BeanValidator.java": "package edu.ncsu.csc.itrust.validate;\n\nimport edu.ncsu.csc.itrust.enums.Gender;\nimport edu.ncsu.csc.itrust.exception.ErrorList;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\n\n\n/**\n * Abstract class used by all validators that provides utility methods for checking formatting of a particular\n * field. Specify the Bean to be validated\n * \n * @author Andy\n * \n * @param <T>\n *            The bean type to be validated\n */\nabstract public class BeanValidator<T> {\n\tabstract public void validate(T bean) throws FormValidationException;\n\t\n\t/**\n\t * Check the format against the given enum. isNullable will check if the string is empty or a Java null.\n\t * Otherwise, an error message will be returned. Use this in conjunction with {@link ErrorList}.\n\t * \n\t * @param name\n\t * @param value\n\t * @param format\n\t * @param isNullable\n\t * @return\n\t */\n\tprotected String checkFormat(String name, String value, ValidationFormat format, boolean isNullable) {\n\t\t \n\t\tString errorMessage = name + \": \" + format.getDescription();\n\t\t if (value == null || \"\".equals(value))\n\t\t\treturn isNullable ? \"\" : errorMessage;\n\t\telse if (format.getRegex().matcher(value).matches())\n\t\t\treturn \"\";\n\t\telse\n\t\t\treturn errorMessage;\n\t}\n\n\t/**\n\t * Check a long value against a particular format. isNullable will check if it is empty or a Java null.\n\t * Otherwise, an error message will be returned. Use this in conjunction with {@link ErrorList}.\n\t * \n\t * @param name\n\t * @param longValue\n\t * @param format\n\t * @param isNullable\n\t * @return\n\t */\n\tprotected String checkFormat(String name, Long longValue, ValidationFormat format, boolean isNullable) {\n\t\tString str = \"\";\n\t\tif (longValue != null)\n\t\t\tstr = String.valueOf(longValue);\n\t\treturn checkFormat(name, str, format, isNullable);\n\t}\n\n\t/**\n\t * Check the format against the given enum. isNullable will check if it is a Java null. Otherwise, an\n\t * error message will be returned. Use this in conjunction with {@link ErrorList}.\n\t * \n\t * @param name\n\t * @param doubleValue\n\t * @param format\n\t * @param isNullable\n\t * @return\n\t */\n\tprotected String checkFormat(String name, Double doubleValue, ValidationFormat format, boolean isNullable) {\n\t\tString str = \"\";\n\t\tif (doubleValue != null)\n\t\t\tstr = String.valueOf(doubleValue);\n\t\treturn checkFormat(name, str, format, isNullable);\n\t}\n\n\t/**\n\t * Check against the proper gender\n\t * \n\t * @param name\n\t * @param gen\n\t * @param format\n\t * @param isNullable\n\t * @return\n\t */\n\tprotected String checkGender(String name, Gender gen, ValidationFormat format, boolean isNullable) {\n\t\tString str = \"\";\n\t\tif (gen != null)\n\t\t\tstr = gen.toString();\n\t\treturn checkFormat(name, str, format, isNullable);\n\t}\n\n\t/**\n\t * The that an integer is the proper format, and is in the correct range\n\t * \n\t * @param name\n\t * @param value\n\t * @param lower\n\t * @param upper\n\t * @param isNullable\n\t * @return\n\t */\n\tprotected String checkInt(String name, String value, int lower, int upper, boolean isNullable) {\n\t\tif (isNullable && (value == null || \"\".equals(value)))\n\t\t\treturn \"\";\n\t\ttry {\n\t\t\tint intValue = Integer.valueOf(value);\n\t\t\tif (lower <= intValue && intValue <= upper)\n\t\t\t\treturn \"\";\n\t\t} catch (NumberFormatException e) {\n\t\t\t// just fall through to returning the error message\n\t\t}\n\n\t\treturn name + \" must be an integer in [\" + lower + \",\" + upper + \"]\";\n\t}\n\n\t/**\n\t * Check that a double is in the proper format and is in the correct range\n\t * \n\t * @param name\n\t * @param value\n\t * @param lower\n\t * @param upper\n\t * @return\n\t */\n\tprotected String checkDouble(String name, String value, double lower, double upper) {\n\t\ttry {\n\t\t\tdouble doubleValue = Double.valueOf(value);\n\t\t\tif (lower <= doubleValue && doubleValue < upper)\n\t\t\t\treturn \"\";\n\t\t} catch (NumberFormatException e) {\n\t\t\t// just fall through to returning the error message\n\t\t}\n\t\treturn name + \" must be a decimal in [\" + lower + \",\" + upper + \")\";\n\t}\n\n\t/**\n\t * Check that the value fits the \"true\" or \"false\"\n\t * \n\t * @param name\n\t * @param value\n\t * @return\n\t */\n\tprotected String checkBoolean(String name, String value) {\n\t\tif (\"true\".equals(value) || \"false\".equals(value))\n\t\t\treturn \"\";\n\t\telse\n\t\t\treturn name + \" must be either 'true' or 'false'\";\n\t}\n}", "DiagnosisBeanValidator.java": "package edu.ncsu.csc.itrust.validate;\n\nimport edu.ncsu.csc.itrust.beans.DiagnosisBean;\nimport edu.ncsu.csc.itrust.exception.ErrorList;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\n\n/**\n * Validates an ICD9CM code\n * \n * @author Andy\n * \n */\npublic class DiagnosisBeanValidator extends BeanValidator<DiagnosisBean> {\n\t/**\n\t * The default constructor.\n\t */\n\tpublic DiagnosisBeanValidator() {\n\t}\n\n\t/**\n\t * Performs the act of validating the bean in question, which varies depending on the\n\t * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.\n\t * \n\t * @param p A bean of the type to be validated.\n\t */\n\t@Override\n\tpublic void validate(DiagnosisBean d) throws FormValidationException {\n\t\tErrorList errorList = new ErrorList();\n\t\terrorList.addIfNotNull(checkFormat(\"ICD9CM Code\", d.getICDCode(), ValidationFormat.ICD9CM, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Description\", d.getDescription(),\n\t\t\t\tValidationFormat.ICD_CODE_DESCRIPTION, false));\n\t\tif (errorList.hasErrors())\n\t\t\tthrow new FormValidationException(errorList);\n\t}\n\n}", "DrugInteractionValidator.java": "package edu.ncsu.csc.itrust.validate;\n\nimport edu.ncsu.csc.itrust.beans.DrugInteractionBean;\nimport edu.ncsu.csc.itrust.exception.ErrorList;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\n\n/**\n * Validates a drug interaction bean, from {@link DrugInteractionAction}\n * \n */\npublic class DrugInteractionValidator extends BeanValidator<DrugInteractionBean> {\n\t/**\n\t * The default constructor.\n\t */\n\tpublic DrugInteractionValidator() {\n\t}\n\n\t/**\n\t * Performs the act of validating the bean in question, which varies depending on the\n\t * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.\n\t * \n\t * @param d A bean of the type to be validated.\n\t */\n\t@Override\n\tpublic void validate(DrugInteractionBean d) throws FormValidationException {\n\t\tErrorList errorList = new ErrorList();\n\t\terrorList.addIfNotNull(checkFormat(\"FirstDrug\", d.getFirstDrug(), ValidationFormat.ND,false));\n\t\terrorList.addIfNotNull(checkFormat(\"SecondDrug\", d.getSecondDrug(), ValidationFormat.ND,false));\n\t\terrorList.addIfNotNull(checkFormat(\"description\", d.getDescription(), ValidationFormat.DRUG_INT_COMMENTS,false));\n\t\tif (errorList.hasErrors())\n\t\t\tthrow new FormValidationException(errorList);\n\t}\n}", "EditOfficeVisitValidator.java": "package edu.ncsu.csc.itrust.validate;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport edu.ncsu.csc.itrust.action.EditOfficeVisitAction;\nimport edu.ncsu.csc.itrust.beans.forms.EditOfficeVisitForm;\nimport edu.ncsu.csc.itrust.exception.ErrorList;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\n\n/**\n * Used to validate updating an office visit, by {@link EditOfficeVisitAction}\n * \n * @author Andy\n * \n */\npublic class EditOfficeVisitValidator extends BeanValidator<EditOfficeVisitForm> {\n\tprivate boolean validatePrescription = false;\n\n\t/**\n\t * The default constructor.\n\t */\n\tpublic EditOfficeVisitValidator() {\n\t}\n\n\tpublic EditOfficeVisitValidator(boolean validatePrescription) {\n\t\tthis.validatePrescription = validatePrescription;\n\t}\n\n\t/**\n\t * Performs the act of validating the bean in question, which varies depending on the\n\t * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.\n\t * \n\t * @param p A bean of the type to be validated.\n\t */\n\t@Override\n\tpublic void validate(EditOfficeVisitForm form) throws FormValidationException {\n\t\tErrorList errorList = new ErrorList();\n\t\terrorList.addIfNotNull(checkFormat(\"HCP ID\", form.getHcpID(), ValidationFormat.MID, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Hospital ID\", form.getHospitalID(), ValidationFormat.HOSPITAL_ID,\n\t\t\t\ttrue));\n\t\terrorList.addIfNotNull(checkFormat(\"Notes\", form.getNotes(), ValidationFormat.NOTES, true));\n\t\terrorList.addIfNotNull(checkFormat(\"Patient ID\", form.getPatientID(), ValidationFormat.MID, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Visit Date\", form.getVisitDate(), ValidationFormat.DATE, false));\n\t\tif (validatePrescription) {\n\t\t\terrorList.addIfNotNull(checkFormat(\"Start Date\", form.getStartDate(), ValidationFormat.DATE,\n\t\t\t\t\tfalse));\n\t\t\terrorList.addIfNotNull(checkFormat(\"End Date\", form.getEndDate(), ValidationFormat.DATE, false));\n\t\t\terrorList.addIfNotNull(checkFormat(\"Instructions\", form.getInstructions(),\n\t\t\t\t\tValidationFormat.NOTES, true));\n\t\t\terrorList.addIfNotNull(checkInt(\"Dosage\", form.getDosage(), 0, 9999, false));\n\t\t\tif ((checkFormat(\"Start Date\", form.getStartDate(), ValidationFormat.DATE, false)) == \"\"\n\t\t\t\t\t&& (checkFormat(\"End Date\", form.getEndDate(), ValidationFormat.DATE, false)) == \"\") {\n\t\t\t\tDate sd = null;\n\t\t\t\tDate ed = null;\n\t\t\t\ttry {\n\t\t\t\t\tsd = new SimpleDateFormat(\"MM/dd/yyyy\").parse(form.getStartDate());\n\t\t\t\t\ted = new SimpleDateFormat(\"MM/dd/yyyy\").parse(form.getEndDate());\n\t\t\t\t\tString dateError = null;\n\t\t\t\t\tif (sd.after(ed)) {\n\t\t\t\t\t\tdateError = \"The start date of the prescription must be before the end date.\";\n\t\t\t\t\t}\n\t\t\t\t\terrorList.addIfNotNull(dateError);\n\t\t\t\t} catch (ParseException e) {\n\t\t\t\t\terrorList.addIfNotNull(ValidationFormat.DATE.getDescription());\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tif (errorList.hasErrors())\n\t\t\tthrow new FormValidationException(errorList);\n\t}\n}", "EMailValidator.java": "package edu.ncsu.csc.itrust.validate;\n\nimport edu.ncsu.csc.itrust.beans.MessageBean;\nimport edu.ncsu.csc.itrust.exception.ErrorList;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\n\n\npublic class EMailValidator extends BeanValidator<MessageBean>  {\n\t/**\n\t * The default constructor.\n\t */\n\tpublic EMailValidator(){\n\t\t\n\t}\n\t/**\n\t * Performs the act of validating the bean in question, which varies depending on the\n\t * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.\n\t * \n\t * @param m A bean of the type to be validated.\n\t */\n\t\n\tpublic void validate(MessageBean m) throws FormValidationException {\n\t\tErrorList errorList = new ErrorList();\n\t\terrorList.addIfNotNull(checkFormat(\"body\", m.getBody(), ValidationFormat.EMAILS,\n\t\t\t\tfalse));\n\n\t\tif (errorList.hasErrors())\n\t\t\tthrow new FormValidationException(errorList);\n\t}\n\n}", "HealthRecordFormValidator.java": "package edu.ncsu.csc.itrust.validate;\n\nimport edu.ncsu.csc.itrust.action.EditHealthHistoryAction;\nimport edu.ncsu.csc.itrust.beans.forms.HealthRecordForm;\nimport edu.ncsu.csc.itrust.exception.ErrorList;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\n\n/**\n * Validator used in adding health information on Basic Health History, {@link EditHealthHistoryAction}\n * \n * @author Andy\n * \n */\npublic class HealthRecordFormValidator extends BeanValidator<HealthRecordForm> {\n\t/**\n\t * Performs the act of validating the bean in question, which varies depending on the\n\t * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.\n\t * \n\t * @param p A bean of the type to be validated.\n\t */\n\t@Override\n\tpublic void validate(HealthRecordForm bean) throws FormValidationException {\n\t\tErrorList errorList = new ErrorList();\n\t\terrorList.addIfNotNull(checkInt(\"Systolic blood pressure\", bean.getBloodPressureN(), 0, 999, false));\n\t\terrorList.addIfNotNull(checkInt(\"Diastolic blood pressure\", bean.getBloodPressureD(), 0, 999, false));\n\t\terrorList.addIfNotNull(checkInt(\"Cholesterol HDL\", bean.getCholesterolHDL(), 0, 89, false));\n\t\terrorList.addIfNotNull(checkInt(\"Cholesterol LDL\", bean.getCholesterolLDL(), 0, 600, false));\n\t\terrorList.addIfNotNull(checkInt(\"Cholesterol Triglycerides\", bean.getCholesterolTri(), 100, 600,\n\t\t\t\tfalse));\n\t\terrorList.addIfNotNull(checkFormat(\"Height\", bean.getHeight(), ValidationFormat.Height, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Weight\", bean.getWeight(), ValidationFormat.Weight, false));\n\t\terrorList.addIfNotNull(checkBoolean(\"Smoker\", bean.getIsSmoker()));\n\t\tif (errorList.hasErrors())\n\t\t\tthrow new FormValidationException(errorList);\n\t}\n\n}", "HospitalBeanValidator.java": "package edu.ncsu.csc.itrust.validate;\n\nimport edu.ncsu.csc.itrust.action.UpdateHospitalListAction;\nimport edu.ncsu.csc.itrust.beans.HospitalBean;\nimport edu.ncsu.csc.itrust.exception.ErrorList;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\n\n/**\n * Validates the input for hospital beans, {@link UpdateHospitalListAction}\n * \n * @author Andy\n * \n */\npublic class HospitalBeanValidator extends BeanValidator<HospitalBean> {\n\t/**\n\t * The default constructor.\n\t */\n\tpublic HospitalBeanValidator() {\n\t}\n\n\t/**\n\t * Performs the act of validating the bean in question, which varies depending on the\n\t * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.\n\t * \n\t * @param p A bean of the type to be validated.\n\t */\n\t@Override\n\tpublic void validate(HospitalBean h) throws FormValidationException {\n\t\tErrorList errorList = new ErrorList();\n\t\terrorList.addIfNotNull(checkFormat(\"Hospital ID\", h.getHospitalID(), ValidationFormat.HOSPITAL_ID,\n\t\t\t\tfalse));\n\t\terrorList.addIfNotNull(checkFormat(\"Hospital Name\", h.getHospitalName(),\n\t\t\t\tValidationFormat.HOSPITAL_NAME, false));\n\t\tif (errorList.hasErrors())\n\t\t\tthrow new FormValidationException(errorList);\n\t}\n\n}", "LabProcedureValidator.java": "package edu.ncsu.csc.itrust.validate;\n\nimport edu.ncsu.csc.itrust.beans.LabProcedureBean;\nimport edu.ncsu.csc.itrust.exception.ErrorList;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\n\npublic class LabProcedureValidator {\n\t\n\t/**\n\t * Performs the act of validating the bean in question, which varies depending on the\n\t * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.\n\t * \n\t * @param p A bean of the type to be validated.\n\t */\n\tpublic void validate(LabProcedureBean b) throws FormValidationException {\n\t\tErrorList errorList = new ErrorList();\n\t\terrorList.addIfNotNull(checkFormat(\"LOINC\", b.getLoinc(), ValidationFormat.LOINC, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Commentary\", b.getCommentary(), ValidationFormat.COMMENTS, true));\n\t\terrorList.addIfNotNull(checkFormat(\"Results\", b.getCommentary(), ValidationFormat.COMMENTS, true));\n\t\terrorList.addIfNotNull(checkFormat(\"Status\", b.getStatus(), ValidationFormat.LAB_STATUS, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Rights\", b.getRights(), ValidationFormat.LAB_RIGHTS, false));\n\t\tif (errorList.hasErrors())\n\t\t\tthrow new FormValidationException(errorList);\n\t}\n\n\tprotected String checkFormat(String name, String value, ValidationFormat format, boolean isNullable) {\n\t\tString errorMessage = name + \": \" + format.getDescription();\n\t\tif (value == null || \"\".equals(value))\n\t\t\treturn isNullable ? \"\" : errorMessage;\n\t\tif (format.getRegex().matcher(value).matches())\n\t\t\treturn \"\";\n\t\telse\n\t\t\treturn errorMessage;\n\t}\n}", "LOINCBeanValidator.java": "package edu.ncsu.csc.itrust.validate;\n\n\nimport edu.ncsu.csc.itrust.beans.LOINCbean;\nimport edu.ncsu.csc.itrust.exception.ErrorList;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\n\n\n/**\n * Validator used to validate LOINCbean\n */\npublic class LOINCBeanValidator extends BeanValidator<LOINCbean> {\n\t/**\n\t * The default constructor.\n\t */\n\tpublic LOINCBeanValidator() {\n\t}\n\n\t/**\n\t * Performs the act of validating the bean in question, which varies depending on the\n\t * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.\n\t * \n\t * @param p A bean of the type to be validated.\n\t */\n\t@Override\n\tpublic void validate(LOINCbean m) throws FormValidationException {\n\t\tErrorList errorList = new ErrorList();\n\t\tif(m.getLabProcedureCode()==null || m.getComponent()==null || m.getKindOfProperty()==null){\n\t\t\tthrow new FormValidationException(\"You must have a Lab Procedure Code, Component and Kind Of Property\");\n\t\t}\n\t\terrorList.addIfNotNull(checkFormat(\"LaboratoryProcedureCode\", m.getLabProcedureCode(), ValidationFormat.LOINC, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Component\", m.getComponent(), ValidationFormat.LOINC_ITEM, false));\n\t\terrorList.addIfNotNull(checkFormat(\"KindOfProperty\", m.getKindOfProperty(), ValidationFormat.LOINC_ITEM, false));\n\t\terrorList.addIfNotNull(checkFormat(\"TimeAspect\", m.getTimeAspect(), ValidationFormat.LOINC_ITEM, true));\n\t\terrorList.addIfNotNull(checkFormat(\"System\", m.getSystem(), ValidationFormat.LOINC_ITEM, true));\n\t\terrorList.addIfNotNull(checkFormat(\"ScaleType\",m.getScaleType(), ValidationFormat.LOINC_ITEM, true));\n\t\terrorList.addIfNotNull(checkFormat(\"MethodType\", m.getMethodType(), ValidationFormat.LOINC_ITEM, true));\n\n\t\tif (errorList.hasErrors())\n\t\t\tthrow new FormValidationException(errorList);\n\t}\n}", "MailValidator.java": "package edu.ncsu.csc.itrust.validate;\n\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\nimport org.apache.commons.validator.*;\n\n\npublic class MailValidator extends EmailValidator {\n\t/**\n\t * The default constructor.\n\t */\n\tpublic MailValidator(){\n\t\t\n\t}\n\t/**\n\t * Performs the act of validating the bean in question, which varies depending on the\n\t * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.\n\t * \n\t * @param p A bean of the type to be validated.\n\t */\n\tpublic boolean validateEmail(String email) throws FormValidationException {\n\t\tMailValidator val = new MailValidator();\n\t\n\t\treturn val.isValid(email);\n\t\t\n\t}\n\t\n\n}", "MedicationBeanValidator.java": "package edu.ncsu.csc.itrust.validate;\n\nimport edu.ncsu.csc.itrust.action.UpdateNDCodeListAction;\nimport edu.ncsu.csc.itrust.beans.MedicationBean;\nimport edu.ncsu.csc.itrust.exception.ErrorList;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\n\n/**\n * Validates ND code beans, from {@link UpdateNDCodeListAction}\n * \n * @author Andy\n * \n */\npublic class MedicationBeanValidator extends BeanValidator<MedicationBean> {\n\t/**\n\t * The default constructor.\n\t */\n\tpublic MedicationBeanValidator() {\n\t}\n\n\t/**\n\t * Performs the act of validating the bean in question, which varies depending on the\n\t * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.\n\t * \n\t * @param p A bean of the type to be validated.\n\t */\n\t@Override\n\tpublic void validate(MedicationBean m) throws FormValidationException {\n\t\tErrorList errorList = new ErrorList();\n\t\terrorList.addIfNotNull(checkFormat(\"ND Code\", m.getNDCode(), ValidationFormat.ND, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Description\", m.getDescription(),\n\t\t\t\tValidationFormat.ND_CODE_DESCRIPTION, false));\n\t\tif (errorList.hasErrors())\n\t\t\tthrow new FormValidationException(errorList);\n\t}\n}", "MessageValidator.java": "package edu.ncsu.csc.itrust.validate;\n\nimport edu.ncsu.csc.itrust.action.EditOfficeVisitAction;\nimport edu.ncsu.csc.itrust.beans.MessageBean;\nimport edu.ncsu.csc.itrust.exception.ErrorList;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\n\n/**\n * Used to validate updating an office visit, by {@link EditOfficeVisitAction}\n * \n * @author Andy\n * \n */\npublic class MessageValidator extends BeanValidator<MessageBean> {\n\n\tpublic MessageValidator() {\n\t}\n\t\n\tpublic void validate(MessageBean mBean) throws FormValidationException {\n\t\tErrorList errorList = new ErrorList();\n\t\terrorList.addIfNotNull(checkFormat(\"body\", mBean.getBody(), ValidationFormat.MESSAGES_BODY, false));\n\t\terrorList.addIfNotNull(checkFormat(\"subject\", mBean.getSubject(), ValidationFormat.MESSAGES_SUBJECT, false));\n\t\t\n\t\tif (errorList.hasErrors())\n\t\t\tthrow new FormValidationException(errorList);\n\t}\n\n}", "PatientValidator.java": "package edu.ncsu.csc.itrust.validate;\n\nimport edu.ncsu.csc.itrust.action.EditPatientAction;\nimport edu.ncsu.csc.itrust.beans.PatientBean;\nimport edu.ncsu.csc.itrust.exception.ErrorList;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\nimport org.apache.commons.validator.CreditCardValidator;\nimport java.util.Date;\n\n/**\n * Validates a patient bean, from {@link EditPatientAction}\n * \n * @author Andy\n * \n */\npublic class PatientValidator extends BeanValidator<PatientBean> {\n\t/**\n\t * The default constructor.\n\t */\n\tpublic PatientValidator() {\n\t}\n\n\t/**\n\t * Performs the act of validating the bean in question, which varies depending on the\n\t * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.\n\t * \n\t * @param p A bean of the type to be validated.\n\t */\n\t@Override\n\tpublic void validate(PatientBean p) throws FormValidationException {\n\t\tErrorList errorList = new ErrorList();\n\t\terrorList.addIfNotNull(checkFormat(\"First name\", p.getFirstName(), ValidationFormat.NAME, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Last name\", p.getLastName(), ValidationFormat.NAME, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Date of Birth\", p.getDateOfBirthStr(), ValidationFormat.DATE,\n\t\t\t\tfalse));\n\t\terrorList.addIfNotNull(checkFormat(\"Date of Death\", p.getDateOfDeathStr(), ValidationFormat.DATE,\n\t\t\t\ttrue));\n\t\ttry {\n\t\t\tif (p.getDateOfDeath() == null && \"\".equals(p.getDateOfDeathStr())){\n\t\t\t\tif( p.getDateOfBirth().after(new Date())){\n\t\t\t\t\terrorList.addIfNotNull(\"Birth date cannot be in the future!\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (p.getDateOfDeath().before(p.getDateOfBirth()))\n\t\t\t\terrorList.addIfNotNull(\"Death date cannot be before birth date!\");\n\t\t\tif( p.getDateOfDeath().after(new Date())){\n\t\t\t\terrorList.addIfNotNull(\"Death date cannot be in the future!\");\n\t\t\t}\n\t\t\tif( p.getDateOfBirth().after(new Date())){\n\t\t\t\terrorList.addIfNotNull(\"Birth date cannot be in the future!\");\n\t\t\t}\n\t\t} catch (NullPointerException e) {\n\t\t\t// ignore this\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\t\n\t\tboolean deathCauseNull = (null == p.getDateOfDeathStr() || p.getDateOfDeathStr().equals(\"\"));\n\t\terrorList.addIfNotNull(checkFormat(\"Cause of Death\", p.getCauseOfDeath(), ValidationFormat.ICD9CM,\n\t\t\t\tdeathCauseNull));\n\t\terrorList.addIfNotNull(checkFormat(\"Email\", p.getEmail(), ValidationFormat.EMAIL, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Street Address 1\", p.getStreetAddress1(),\n\t\t\t\tValidationFormat.ADDRESS, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Street Address 2\", p.getStreetAddress2(),\n\t\t\t\tValidationFormat.ADDRESS, true));\n\t\terrorList.addIfNotNull(checkFormat(\"City\", p.getCity(), ValidationFormat.CITY, false));\n\t\terrorList.addIfNotNull(checkFormat(\"State\", p.getState(), ValidationFormat.STATE, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Zip Code\", p.getZip(), ValidationFormat.ZIPCODE, false));\n\t\terrorList\n\t\t\t\t.addIfNotNull(checkFormat(\"Phone Number\", p.getPhone(), ValidationFormat.PHONE_NUMBER, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Emergency Contact Name\", p.getEmergencyName(),\n\t\t\t\tValidationFormat.NAME, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Emergency Contact Phone\", p.getEmergencyPhone(),\n\t\t\t\tValidationFormat.PHONE_NUMBER, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Insurance Company Name\", p.getIcName(), ValidationFormat.NAME,\n\t\t\t\tfalse));\n\t\terrorList.addIfNotNull(checkFormat(\"Insurance Company Address 1\", p.getIcAddress1(),\n\t\t\t\tValidationFormat.ADDRESS, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Insurance Company Address 2\", p.getIcAddress2(),\n\t\t\t\tValidationFormat.ADDRESS, true));\n\t\terrorList.addIfNotNull(checkFormat(\"Insurance Company City\", p.getIcCity(), ValidationFormat.CITY,\n\t\t\t\tfalse));\n\t\terrorList.addIfNotNull(checkFormat(\"Insurance Company State\", p.getIcState(), ValidationFormat.STATE,\n\t\t\t\tfalse));\n\t\terrorList.addIfNotNull(checkFormat(\"Insurance Company Zip\", p.getIcZip(), ValidationFormat.ZIPCODE,\n\t\t\t\tfalse));\n\t\terrorList.addIfNotNull(checkFormat(\"Insurance Company Phone\", p.getIcPhone(),\n\t\t\t\tValidationFormat.PHONE_NUMBER, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Insurance Company ID\", p.getIcID(),\n\t\t\t\tValidationFormat.INSURANCE_ID, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Mother MID\", p.getMotherMID(), ValidationFormat.MID, true));\n\t\terrorList.addIfNotNull(checkFormat(\"Father MID\", p.getFatherMID(), ValidationFormat.MID, true));\n\t\terrorList\n\t\t\t\t.addIfNotNull(checkFormat(\"Topical Notes\", p.getTopicalNotes(), ValidationFormat.NOTES, true));\n\t\t\n\t\t/* This block was added for Theme 5 by Tyler Arehart */\n\t\t\n\t\tif (!(p.getCreditCardNumber().equals(\"\") && p.getCreditCardType().equals(\"\"))) {\n\t\t\n\t\t\tString s = null;\n\t\t\tCreditCardValidator c;\n\t\t\tint type = -1;\n\t\t\tif (p.getCreditCardType().equals(\"VISA\")) type = CreditCardValidator.VISA;\n\t\t\tif (p.getCreditCardType().equals(\"MASTERCARD\")) type = CreditCardValidator.MASTERCARD;\n\t\t\tif (p.getCreditCardType().equals(\"DISCOVER\")) type = CreditCardValidator.DISCOVER;\n\t\t\tif (p.getCreditCardType().equals(\"AMEX\")) type = CreditCardValidator.AMEX;\n\t\t\t\n\t\t\tif (type != -1) {\t\n\t\t\t\tc = new CreditCardValidator(type);\n\t\t\t\tif (!c.isValid(p.getCreditCardNumber())) {\n\t\t\t\t\ts = \"Credit Card Number\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts = \"Credit Card Type\";\n\t\t\t}\n\t\t\terrorList.addIfNotNull(s);\n\t\t}\n\t\t\n\t\tif (errorList.hasErrors())\n\t\t\tthrow new FormValidationException(errorList);\n\t}\n}", "PersonnelValidator.java": "package edu.ncsu.csc.itrust.validate;\n\nimport edu.ncsu.csc.itrust.action.EditPersonnelAction;\nimport edu.ncsu.csc.itrust.beans.PersonnelBean;\nimport edu.ncsu.csc.itrust.exception.ErrorList;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\n\n/**\n * Validates a personnel bean, from {@link EditPersonnelAction}\n * \n * @author Andy\n * \n */\npublic class PersonnelValidator extends BeanValidator<PersonnelBean> {\n\t/**\n\t * The default constructor.\n\t */\n\tpublic PersonnelValidator() {\n\t}\n\n\t/**\n\t * Performs the act of validating the bean in question, which varies depending on the\n\t * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.\n\t * \n\t * @param p A bean of the type to be validated.\n\t */\n\t@Override\n\tpublic void validate(PersonnelBean p) throws FormValidationException {\n\t\tErrorList errorList = new ErrorList();\n\t\terrorList.addIfNotNull(checkFormat(\"First name\", p.getFirstName(), ValidationFormat.NAME, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Last name\", p.getLastName(), ValidationFormat.NAME, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Street Address 1\", p.getStreetAddress1(),\n\t\t\t\tValidationFormat.ADDRESS, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Street Address 2\", p.getStreetAddress2(),\n\t\t\t\tValidationFormat.ADDRESS, true));\n\t\terrorList.addIfNotNull(checkFormat(\"City\", p.getCity(), ValidationFormat.CITY, false));\n\t\terrorList.addIfNotNull(checkFormat(\"State\", p.getState(), ValidationFormat.STATE, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Zip Code\", p.getZip(), ValidationFormat.ZIPCODE, false));\n\t\terrorList\n\t\t\t\t.addIfNotNull(checkFormat(\"Phone Number\", p.getPhone(), ValidationFormat.PHONE_NUMBER, false));\n\t\terrorList\n\t\t.addIfNotNull(checkFormat(\"Email\", p.getEmail(), ValidationFormat.EMAIL, true));\n\t\tif (errorList.hasErrors())\n\t\t\tthrow new FormValidationException(errorList);\n\t}\n\n}", "ProcedureBeanValidator.java": "package edu.ncsu.csc.itrust.validate;\n\nimport edu.ncsu.csc.itrust.action.UpdateNDCodeListAction;\nimport edu.ncsu.csc.itrust.beans.ProcedureBean;\nimport edu.ncsu.csc.itrust.exception.ErrorList;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\n\n/**\n * Validates an ND code, from {@link UpdateNDCodeListAction}\n * \n * @author Andy\n * \n */\npublic class ProcedureBeanValidator extends BeanValidator<ProcedureBean> {\n\t/**\n\t * The default constructor.\n\t */\n\tpublic ProcedureBeanValidator() {\n\t}\n\n\t/**\n\t * Performs the act of validating the bean in question, which varies depending on the\n\t * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.\n\t * \n\t * @param p A bean of the type to be validated.\n\t */\n\t@Override\n\tpublic void validate(ProcedureBean p) throws FormValidationException {\n\t\tErrorList errorList = new ErrorList();\n\t\terrorList.addIfNotNull(checkFormat(\"CPT Code\", p.getCPTCode(), ValidationFormat.CPT, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Description\", p.getDescription(),\n\t\t\t\tValidationFormat.CPT_CODE_DESCRIPTION, false));\n\t\tif (errorList.hasErrors())\n\t\t\tthrow new FormValidationException(errorList);\n\t}\n\n}", "RemoteMonitoringDataBeanValidator.java": "package edu.ncsu.csc.itrust.validate;\n\nimport edu.ncsu.csc.itrust.action.AddRemoteMonitoringDataAction;\nimport edu.ncsu.csc.itrust.beans.RemoteMonitoringDataBean;\nimport edu.ncsu.csc.itrust.exception.ErrorList;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\n\n/**\n * Validator used to validate adding new remote monitoring data in {@link AddRemoteMonitoringDataAction}\n * \n */\npublic class RemoteMonitoringDataBeanValidator extends BeanValidator<RemoteMonitoringDataBean> {\n\t/**\n\t * The default constructor.\n\t */\n\tpublic RemoteMonitoringDataBeanValidator() {\n\t}\n\t\n\t/**\n\t * Performs the act of validating the bean in question, which varies depending on the\n\t * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.\n\t * \n\t * @param p A bean of the type to be validated.\n\t */\n\t@Override\n\tpublic void validate(RemoteMonitoringDataBean m) throws FormValidationException {\n\t\tErrorList errorList = new ErrorList();\n\t\terrorList.addIfNotNull(checkFormat(\"Systolic Blood Pressure\", \"\" + m.getSystolicBloodPressure(),\n\t\t\t\tValidationFormat.SYSTOLIC_BLOOD_PRESSURE, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Diastolic Blood Pressure\", \"\" + m.getDiastolicBloodPressure(),\n\t\t\t\tValidationFormat.DIASTOLIC_BLOOD_PRESSURE, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Glucose Level\", \"\" + m.getGlucoseLevel(),\n\t\t\t\tValidationFormat.GLUCOSE_LEVEL, false));\n\t\tif (errorList.hasErrors()){\n\t\t\tthrow new FormValidationException(errorList);\n\t\t}\n\t}\n}", "SecurityQAValidator.java": "package edu.ncsu.csc.itrust.validate;\n\nimport edu.ncsu.csc.itrust.action.SetSecurityQuestionAction;\nimport edu.ncsu.csc.itrust.beans.SecurityQA;\nimport edu.ncsu.csc.itrust.exception.ErrorList;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\n\n/**\n * Validates the security question and answer. This doesn't follow the same format as the others because this\n * validator is used for the various states of reset password, {@link SetSecurityQuestionAction}\n * \n * @author Andy\n * \n */\npublic class SecurityQAValidator extends BeanValidator<SecurityQA> {\n\t/**\n\t * Performs the act of validating the bean in question, which varies depending on the\n\t * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.\n\t * \n\t * @param p A bean of the type to be validated.\n\t */\n\t@Override\n\tpublic void validate(SecurityQA bean) throws FormValidationException {\n\t\tErrorList errorList = new ErrorList();\n\t\tif (null == bean)\n\t\t\tthrow new FormValidationException(\"Null form\");\n\n\t\tif (null == bean.getConfirmAnswer())\n\t\t\tthrow new FormValidationException(\"Confirm answer cannot be empty\");\n\n\t\tif (!bean.getAnswer().equals(bean.getConfirmAnswer()))\n\t\t\tthrow new FormValidationException(\"Security answers do not match\");\n\n\t\terrorList.addIfNotNull(checkFormat(\"Security Question\", bean.getQuestion(),\n\t\t\t\tValidationFormat.QUESTION, false));\n\t\terrorList.addIfNotNull(checkFormat(\"Security Answer\", bean.getAnswer(), ValidationFormat.ANSWER,\n\t\t\t\tfalse));\n\n\t\tif (errorList.hasErrors())\n\t\t\tthrow new FormValidationException(errorList);\n\t}\n\n}", "SurveySearchValidator.java": "package edu.ncsu.csc.itrust.validate;\n\nimport edu.ncsu.csc.itrust.beans.SurveyResultBean;\nimport edu.ncsu.csc.itrust.exception.ErrorList;\nimport edu.ncsu.csc.itrust.exception.FormValidationException;\n\n/**\n * Validator for zip code that is entered when a user searches for HCP survey results.\n */\npublic class SurveySearchValidator extends BeanValidator<SurveyResultBean>{\n\n\t/**\n\t * Performs the act of validating the bean in question, which varies depending on the\n\t * type of validator.  If the validation does not succeed, a {@link FormValidationException} is thrown.\n\t * \n\t * @param p A bean of the type to be validated.\n\t */\n\t@Override\n\tpublic void validate(SurveyResultBean bean) throws FormValidationException {\n\t\tErrorList errorList = new ErrorList();\n\t\terrorList.addIfNotNull(checkFormat(\"Zip Code\", bean.getHCPzip(), ValidationFormat.ZIPCODE, false));\n\t\t\n\t\tif (errorList.hasErrors())\n\t\t\tthrow new FormValidationException(errorList);\n\t}\n\n}", "ValidationFormat.java": "package edu.ncsu.csc.itrust.validate;\n\nimport java.util.regex.Pattern;\n\n/**\n * Enum with all of the validation formats that fit into a regex.\n * \n * @author Andy\n * \n *\n */\n\n\npublic enum ValidationFormat {\n\tNAME(\"[\\\\sa-zA-Z'-]{1,20}\", \"Up to 20 Letters, space, ' and -\"), DATE(\"[\\\\d]{2}/[\\\\d]{2}/[\\\\d]{4}\",\n\t\t\t\"MM/DD/YYYY\"),\n\t\t\tPHONE_NUMBER(\"[\\\\d]{3}-[\\\\d]{3}-[\\\\d]{4}\", \"xxx-xxx-xxxx\"),\n\t\t\tMID(\"[\\\\d]{1,10}\",\n\t\t\t\"Between 1 and 10 digits\"), ROLE(\"^(?:admin|hcp|uap|test)$\",\n\t\t\t\"must be one of {admin, hcp, uap, test}\"),\n\t\t\tEMAIL(\"^[_A-Za-z0-9-]+(\\\\.[_A-Za-z0-9-]+)*@[A-Za-z0-9-]+(\\\\.[A-Za-z0-9-]+)*((\\\\.[A-Za-z]{2,}){1}$)\",\n\t\t\t\t\t\"Up to 30 alphanumeric characters and symbols . and _ @\"), \n\tQUESTION(\"[a-zA-Z0-9?\\\\-'.\\\\s]{1,50}\", \"Up to 50 alphanumeric characters and symbols ?-'.\"),\n\tANSWER(\"[a-zA-Z0-9\\\\s]{1,30}\", \"Up to 30 alphanumeric characters\"),\n\tADDRESS(\"[a-zA-Z0-9.\\\\s]{1,30}\", \"Up to 30 alphanumeric characters, and .\"),\n\tAPPT_COMMENT(\"[0-9a-zA-Z\\\\s'\\\"?!:;\\\\-._\\n\\t]{1,1000}\", \"Between 0 and 1000 alphanumerics with space, and other punctuation\"),\n\tAPPT_TYPE_NAME(\"[a-zA-Z ]{1,30}\", \"Between 1 and 30 alpha characters and space\"),\n\tAPPT_TYPE_DURATION(\"[0-9]{1,5}\", \"Between 1 and 5 numberics\"),\n\tCITY(\"[a-zA-Z\\\\s]{1,15}\", \"Up to 15 characters\"),\n\tSTATE(\"[A-Z]{2}\", \"Two capital letters\"),\n\tZIPCODE(\"([0-9]{5})|([0-9]{5}-[0-9]{4})\", \"xxxxx or xxxxx-xxxx\"), // ^[0-9]{5}(?:-[0-9]{4})?$\n\tBLOODTYPE(\"((O)|(A)|(B)|(AB))([+-]{1})\", \"Must be [O,A,B,AB]+/-\"), // ^(?:O|A|B|AB)[+-]$\n\tGENDER(\"(Male)|(Female)\", \"Only Male or Female\"), // ^(?:Male|Female)$\n\tNOTES(\"[a-zA-Z0-9\\\\s'\\\"?!:;\\\\-._\\n\\t]{1,300}\",\n\t\t\t\"Up to 300 alphanumeric characters, with space, and other punctuation\"),\n\tMESSAGES_BODY(\"[a-zA-Z0-9\\\\s'\\\"?!:;\\\\-.,_\\n\\t()]{1,1000}\",\n\t\t\t\"Up to 1000 alphanumeric characters, with space, and other punctuation\"),\n\tMESSAGES_SUBJECT(\"[a-zA-Z0-9\\\\s'\\\"?!:;\\\\-._\\n\\t()]{1,100}\",\n\t\t\t\"Up to 100 alphanumeric characters, with space, and other punctuation\"),\n\tPASSWORD(\"[a-zA-Z0-9]{8,20}\", \"8-20 alphanumeric characters\"),\n\tINSURANCE_ID(\"[\\\\s\\\\da-zA-Z'-]{1,20}\", \"Up to 20 letters, digits, space, ' and -\"),\n\tHOSPITAL_ID(\"[\\\\d]{1,10}\", \"Between 1 and 10 digits\"),\n\tHOSPITAL_NAME(\"[0-9a-zA-Z' .]{1,30}\", \"Between 1 and 30 alphanumerics, space, ', and .\"),\n\tND_CODE_DESCRIPTION(\"[a-zA-Z0-9\\\\s]{1,100}\", \"Up to 100 characters, letters, numbers, and a space\"),\n\tDRUG_INT_COMMENTS(\"[a-zA-Z0-9.\\\\-',!;:()?\\\\s]{1,500}\", \"Up to 500 alphanumeric characters and .-',!;:()?\"),\n\tEMAILS(\"[a-zA-Z0-9.\\\\-',!;:()?\\\\s]{1,500}\", \"Up to 500 alphanumeric characters and .-',!;:()?\"),\n\tADVERSE_EVENT_COMMENTS(\"[a-zA-Z0-9.\\\\-',!;:()?\\\\s]{1,2000}\", \"Up to 2000 alphanumeric characters and .-',!;:()?\"),\n\tICD_CODE_DESCRIPTION(\"[a-zA-Z0-9\\\\s]{1,30}\", \"Up to 30 characters, letters, numbers, and a space\"),\n\tCPT_CODE_DESCRIPTION(\"[a-zA-Z0-9\\\\s]{1,30}\", \"Up to 30 characters, letters, numbers, and a space\"),\n\tALLERGY_DESCRIPTION(\"[a-zA-Z0-9\\\\s]{1,30}\", \"Up to 30 characters, letters, numbers, and a space\"),\n\tICD9CM(\"([\\\\d]{1,3})|([\\\\d]{1,3}\\\\.[\\\\d]{0,2})\", \"xxx.xx\"),\n\tCPT(\"[\\\\d]{1,4}[A-Za-z0-9]\", \"Up to four digit integer plus a letter or digit\"),\n\tHeight(\"[\\\\d]{0,3}(\\\\.(\\\\d){0,1}){0,1}\", \"Up to 3-digit number + up to 1 decimal place\"),\n\tWeight(\"[\\\\d]{0,4}(\\\\.(\\\\d){0,1}){0,1}\", \"Up to 4-digit number + up to 1 decimal place\"),\n\tYEAR(\"[\\\\d]{4}\", \"Must be 4 digits\"), \n\tGENDERCOD(\"(Male)|(Female)|(Not Specified)\", \"Only Male, Female, or All Patients\"),\n\tND(\"[\\\\d]{1,9}\", \"Up to nine digit integer\"),\n\tLOINC(\"[\\\\d]{5}[-]{1}[\\\\d]{1}\", \"Must be in format nnnnn-n\"),\n\tLOINC_ITEM(\"[a-zA-Z0-9\\\\s]{1,100}\", \"Up to 100 characters, letters, numbers, and a space\"),\n\tCOMMENTS(\"[a-zA-Z0-9.\\\\s]{1,500}\", \"Up to 500 alphanumeric characters\"),\n\tLAB_STATUS(\"(NOT YET RECEIVED)|(PENDING)|(COMPLETED)\", \"Only NOT YET RECEIVED, PENDING, or COMPLETED\"),\n\tLAB_RIGHTS(\"(ALLOWED)|(RESTRICTED)\", \"Only ALLOWED, or RESTRICTED\"),\n\tSYSTOLIC_BLOOD_PRESSURE(\"^([4-9][0-9]|1[0-9][0-9]|2[0-3][0-9]|240)$\", \"Must be between 40 and 240\"),\n\tDIASTOLIC_BLOOD_PRESSURE(\"^([4-9][0-9]|1[0-4][0-9]|150)$\", \"Must be between 40 and 150\"),\n\tGLUCOSE_LEVEL(\"^([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|250)$\", \"Must be between 0 and 250\");\n\t\n\n\tprivate Pattern regex;\n\tprivate String description;\n\n\tValidationFormat(String regex, String errorMessage) {\n\t\tthis.regex = Pattern.compile(regex);\n\t\tthis.description = errorMessage;\n\t}\n\n\tpublic Pattern getRegex() {\n\t\treturn regex;\n\t}\n\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n}"}